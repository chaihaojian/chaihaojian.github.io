[{"content":"数据的表示和运算 数制与编码 进位计数制 ![Image 7](chap2_ 7.png)\nr进制计数法 二进制 \u0026lt;\u0026ndash;\u0026gt; 八进制 二进制中的三位数正好可以表示八进制中的一位数\n3位一组，每组转换成对应的8进制符号；首尾如果不足3位，则用0补全\n![Image 1](chap2_ 1.png)\n同理，八进制中的一位数对应二进制中的3位数\n![Image 3](chap2_ 3.png)\n二进制 \u0026lt;\u0026ndash;\u0026gt; 十六进制 二进制中的四位数正好可以表示十六进制中的一位数\n4位一组，每组转换成对应的十六进制符号，首尾如果不足3位，则用0补全\n![Image 2](chap2_ 2.png)\n同理，十六进制中的一位数对应二进制中的4位数\n![Image 4](chap2_ 4.png)\n十进制 \u0026ndash;\u0026gt; 任意进制 ![Image 5](chap2_ 5.png)\n![Image 6](chap2_ 6.png)\n上述小数部分的0.3在转换成二进制时会无限循环下去，表明十进制中的0.3无法在二进制中精确表示\n真值和机器数 真值：符合人类习惯的数字，如：2，5，-3，-11\n机器数：数字实际存储到机器里的形式，正负号需要被数字化，在数字开头加 ‘0‘ 或 ’1’ 来表示正负\nBCD码 BCD：Binary-Coded Decimal，用二进制编码的十进制\n![Image 12](chap2_ 12.png)\n8421码 考虑用四个二进制位表示十进制中的0～9\n四个二进制位一共能表示16种状态，十进制0～9表示10种状态，因此这种表示会产生6种冗余状态，需要舍弃\n![Image 8](chap2_ 8.png)\n![Image 9](chap2_ 9.png)\n上述计算结果 13 (1101) 恰好处在8421码需要舍弃的6种状态中，因此通过加 6 (0110) 来剔除这六种冗余，从而得到十进制数13的正确8421码表示\n由于四个二进制码可以表示16种不同的状态，因此在表示十进制中的0～9时，可以产生不同的映射方案\n余3码：8421码 + (0011)2 ![Image 10](chap2_ 10.png)\n特点：8421码中，四个二进制位都有其固定的权值，分别为 8 - 4 - 2 - 1，但在余3码中，四个二进制位没有其固定的权值\n2421码：将四个二进制位的权值变为 2 - 4 - 2 - 1 ![Image 11](chap2_ 11.png)\n特点：十进制中的4～9在2421码中会有多种编码方式，因此规定在表示5～9时，第一个二进制位即最高位必须是1\n无符号整数的表示和运算 ","date":"2024-07-18T10:08:09+08:00","image":"https://chaihaojian.github.io/post/computer_composition_principles/chapter_2/cover_huc74df9617fcc19736cc959ce67738010_601682_120x120_fill_q75_box_smart1.JPG","permalink":"https://chaihaojian.github.io/post/computer_composition_principles/chapter_2/","title":"数据的表示和运算"},{"content":"数组 数组是多个变量值的集合，数组是Array对象的实例，因此数组可以调用方法\n数组是一个引用类型\n数组的声明 创建数组 1//使用对象方式创建数组 2let arr1 = new Array(1, \u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;); 3console.log(arr1); 4//使用字面量创建数组 推荐做法 5let arr2 = [2, \u0026#34;你好\u0026#34;, \u0026#34;世界\u0026#34;]; 6console.log(arr2); 7//多维数组创建 8let arr3 = [[1, \u0026#34;Tom\u0026#34;],[2, \u0026#34;Mike\u0026#34;, \u0026#34;boy\u0026#34;]]; 9console.log(arr3); 数组是引用类型 数组类型有length属性 数组可以设置任何值 若直接设置一个数组的第三个值，会将该数组的第一、第二个值设置为空值 使用Array.of创建数组 使用Array.of与new Array不同是设置只有一个元素的数组时不会创建空元素数组\n1let arr4 = Array.of(3); 2console.log(arr4); 3let arr5 = Array.of(1, 2, 3); 4console.log(arr5); 5 6let arr6 = new Array(3); 7console.log(arr6); ![Image 1](chap4_ 1.png)\n类型检测 检测变量是否为数组类型\n1console.log(Array.isArray([1, 2, 3])); 2console.log(Array.isArray(3)); ![Image 2](chap4_ 2.png)\n类型转换 可以将数组转换为字符串，也可以将其他类型转换为数组\n将数组转换为字符串 1//可以使用.toString()函数转换为字符串 2console.log(([1, 2, 3]).toString()); 3//可以使用函数String转换为字符串 4console.log(String([1, 2, 3])); 5//使用join连接为字符串 6console.log([1,2,3].join(\u0026#34;-\u0026#34;)); ![Image 3](chap4_ 3.png)\nArray.from 使用Array.from可以将类数组转换为数组，类数组指包含length属性或可迭代的对象\nArray.from()包含两个参数，第一个参数为要转换的数据，第二个参数为类似于map函数的回调方法\n1\u0026lt;body\u0026gt; 2 \u0026lt;button message=\u0026#34;hello\u0026#34;\u0026gt;\u0026lt;/button\u0026gt; 3\u0026lt;button message=\u0026#34;world\u0026#34;\u0026gt;\u0026lt;/button\u0026gt; 4\u0026lt;script\u0026gt; 5 //Array.from 将类数组转换为数组 6 //Array.from()包含两个参数 第一个为需要转换的数据 第二个为一个类似map函数的回调 7 let str = \u0026#34;hello world\u0026#34;; 8\tconsole.log(Array.from(str)) 9 10\t//为对象设置 length 属性后也可以转换为数组 但属性字段名要为数值或数值字符串 11\t//如果字段名是其它 该字段的值将不会被转换 12\tlet user = { 13 0: \u0026#34;hello\u0026#34;, 14 name: \u0026#34;tom\u0026#34;, 15 \u0026#34;1\u0026#34;: 18, 16 length: 2 17\t}; 18\tconsole.log(Array.from(user)); 19 20\t//获取DOM元素将其转换为数组 通过Array.from()的第二个参数 对DOM元素进行操作 21\tlet btns = document.querySelectorAll(\u0026#39;button\u0026#39;); 22\tconsole.log(btns); 23\tArray.from(btns, (item) =\u0026gt; { 24 item.style.background = \u0026#39;red\u0026#39;; 25\t}); 26\u0026lt;/script\u0026gt; 27\u0026lt;/body\u0026gt; ![Image 4](chap4_ 4.png)\n展开语法 展开语法将NodeList类型的数据转换为数组\n1\u0026lt;style\u0026gt; 2 .hide { 3 display: none; 4 } 5\u0026lt;/style\u0026gt; 6 7\u0026lt;body\u0026gt; 8 \u0026lt;div\u0026gt;hdcms\u0026lt;/div\u0026gt; 9\u0026lt;div\u0026gt;houdunren\u0026lt;/div\u0026gt; 10\u0026lt;/body\u0026gt; 11 12\u0026lt;script\u0026gt; 13 let divs = document.querySelectorAll(\u0026#34;div\u0026#34;); 14[...divs].map(function(div) {//[...divs] 展开语法 15 div.addEventListener(\u0026#34;click\u0026#34;, function() { 16 this.classList.toggle(\u0026#34;hide\u0026#34;); 17 }); 18}); 19\u0026lt;/script\u0026gt; 展开语法 数组合并 可以使用展开语法合并数组，使用\u0026hellip;可将数组展开为多个值\n1//展开语法合并数组 2let a = [1, 2, 3]; 3let b = [\u0026#39;a\u0026#39;, \u0026#39;hello\u0026#39;, ...a]; 4console.log(b); 5 6//也可以使用concat方法合并 7let c = [1, 2, 3]; 8let d = a.concat([\u0026#39;a\u0026#39;, \u0026#39;hello\u0026#39;]); 9console.log(d); ![Image 5](chap4_ 5.png)\n在函数中使用展开语法 在函数参数列表中使用展开语法，来接受任意数量的参数\n1//在函数参数列表中使用展开语法 2function test1(...args) { 3 console.log(args); 4} 5test1(1, 2, 3, \u0026#39;a\u0026#39;, \u0026#39;hello\u0026#39;); 6//也可以接受部分参数 7function test2(idx, ...args) { 8 console.log(idx, args); 9} 10test2(\u0026#39;idx000\u0026#39;, 1, 2, 3, \u0026#39;a\u0026#39;, \u0026#39;hello\u0026#39;); ![Image 6](chap4_ 6.png)\n解构赋值 解构是一种更简洁的赋值特性，可以理解为分解一个数据的结构\n1//解构赋值 2let [name, age] = [\u0026#39;Tom\u0026#39;, 18]; 3console.log(name, age); 4 5function test1() { 6 return [\u0026#39;Miki\u0026#39;, 22]; 7}; 8let [a, b] = test1(); 9console.log(a, b); 10 11//剩余结构 通过展开语法 用一个变量来接受剩余参数 12let [c, ...d] = [\u0026#39;idx000\u0026#39;, 1, 2, \u0026#39;hello\u0026#39;]; 13console.log(c, d); 14 15//只赋值部分变量 16let [, n] = [\u0026#39;joe\u0026#39;, 23]; 17console.log(n); ![Image 7](chap4_ 7.png)\n管理数组中的元素 基本用法 数组的索引从0开始 可以通过索引改变数组 也可以向数组追加元素\n1//通过索引修改元素 2let arr = [1, \u0026#39;hello\u0026#39;, \u0026#39;world\u0026#39;]; 3arr[1] = \u0026#39;hi\u0026#39;; 4console.log(arr); 5//向数组追加元素 6arr[arr.length] = \u0026#39;Tom\u0026#39;; 7console.log(arr); ![Image 8](chap4_ 8.png)\n扩展语法 使用展开语法批量向数组追加元素\n1//使用展开语法批量追加元素 2let arr1 = [\u0026#39;hello\u0026#39;, \u0026#39;world\u0026#39;]; 3let arr2 = [\u0026#39;hi\u0026#39;, 18]; 4arr1.push(...arr2); 5console.log(arr1); ![Image 9](chap4_ 9.png)\npush()方法 将元素压入数组，直接改变元数组，返回值为数组元素数量\n1//push()方法 2let arr = [1, \u0026#39;hello\u0026#39;, \u0026#39;world\u0026#39;]; 3console.log(arr.push(\u0026#39;Tom\u0026#39;, 22)); 4console.log(arr); ![Image 10](chap4_ 10.png)\npop()方法 从数组的末尾弹出元素，直接改变元数组，返回值为弹出的元素\n1//pop()方法 2let arr = [1, \u0026#39;hello\u0026#39;, \u0026#39;world\u0026#39;]; 3console.log(arr.pop()); 4console.log(arr); ![Image 11](chap4_ 11.png)\nshift()方法 从数组头部取出一个元素\n1//shift()方法 2let arr = [1, \u0026#39;hello\u0026#39;, \u0026#39;world\u0026#39;]; 3console.log(arr.shift()); 4console.log(arr); ![Image 12](chap4_ 12.png)\nunshift()方法 从数组的头部添加元素\n1//unshift()方法 2let arr = [1, \u0026#39;hello\u0026#39;, \u0026#39;world\u0026#39;]; 3console.log(arr.unshift(\u0026#39;hi\u0026#39;)); 4console.log(arr); ![Image 13](chap4_ 13.png)\nfill()方法 使用fill填充数组元素\n1//fill()方法 2//填充数组 3console.log(Array(4).fill(\u0026#39;hello\u0026#39;)); 4//指定填充位置 5console.log([1, 2, 3, 4].fill(\u0026#39;hello\u0026#39;, 1, 3)); ![Image 14](chap4_ 14.png)\nslice()方法 使用slice方法从数组中截取部分元素组合成新数组（并不会改变原数组），不传第二个参数时，截取到数组的最后元素\n1//slice()方法 2let arr = [0, 1, 2, 3, 4, 5, 6]; 3console.log(arr.slice(1, 3)); 4console.log(arr.slice(2)); 5console.log(arr.slice()); ![Image 15](chap4_ 15.png)\nsplice()方法 使用splice方法可以添加、删除、替换数组中的元素，会对原数组造成改变，返回值为删除的元素\n1let arr = [0, 1, 2, 3, 4, 5, 6]; 2console.log(arr.slice(1, 3)); 3console.log(arr.slice(2)); 4console.log(arr.slice()); 清空数组 将数组指修改为 [] 即可清空数组，如果有多个引用时\n1let user = [{name:\u0026#34;tom\u0026#34;}, {name:\u0026#34;jim\u0026#34;}]; 2let person = user; 3user = []; 4console.log(user); 5console.log(person); ![Image 16](chap4_ 16.png)\n将数组的 length 属性设置为0也可以清空数组\n1let user = [{name:\u0026#34;tom\u0026#34;}, {name:\u0026#34;jim\u0026#34;}]; 2user.length = 0; 3console.log(user); ![Image 17](chap4_ 17.png)\n使用 splice 方法删除所有元素\n1let user = [{name:\u0026#34;tom\u0026#34;}, {name:\u0026#34;jim\u0026#34;}]; 2user.splice(0, user.length); 3console.log(user); ![Image 18](chap4_ 18.png)\n使用 pop/shift 删除所有元素来清空数组\n1let user =[{name:\u0026#34;tom\u0026#34;}, {name:\u0026#34;jim\u0026#34;}]; 2while (user.pop()){}; 3console.log(user); ![Image 19](chap4_ 19.png)\n合并拆分 join 使用 join 将数组元素连接成字符串\n1let arr = [1, \u0026#34;hello\u0026#34;, \u0026#34;tim\u0026#34;]; 2console.log(arr.join(\u0026#39;-\u0026#39;)) ![Image 20](chap4_ 20.png)\nsplit split 方法用于将字符串分割成数组，类似 join 方法的反函数\n1let score = \u0026#34;99,98,78\u0026#34;; 2console.log(score.split(\u0026#34;,\u0026#34;)); ![Image 21](chap4_ 21.png)\nconcat concat 方法用于连接两个或多个数组，元素是值类型的是复制操作，如果是引用类型还是指向同一对象\n1let arr0 = [\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;]; 2let arr1 = [1, 2]; 3let arr2 = [{name: \u0026#34;tom\u0026#34;}, {name: \u0026#34;jim\u0026#34;}]; 4arr1[0] = 3; 5console.log(arr0.concat(arr1, arr2)); 6//arr1中的元素是值类型 而arr2中的元素是引用类型 7arr1[1] = 4; 8arr2[1].name = \u0026#34;mike\u0026#34;; ![Image 22](chap4_ 22.png)\n也可以使用展开语法实现数组连接\n1let arr0 = [\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;]; 2let arr1 = [1, 2]; 3let arr2 = [{name: \u0026#34;tom\u0026#34;}, {name: \u0026#34;jim\u0026#34;}]; 4console.log([...arr0, ...arr1, ...arr2]); ![Image 23](chap4_ 23.png)\ncopyWithin 使用 copyWithin 方法从数组中复制一部分到同数组中的另外位置\n1//array.copyWithin(target, start, end); 2//target: 必需，复制到指定目标索引位置 3//start: 可选，元素复制的起始位置 4//end: 可选，停止复制的索引位置，默认为array.length，负值表示倒数 5const arr = [1, 2, 3, 4]; 6console.log(arr.copyWithin(2, 0, 2)); ![Image 24](chap4_ 24.png)\n查找元素 indexOf 使用 indexOf 方法从前向后查找元素出现的位置，如果找不到返回 -1\n","date":"2024-04-14T21:37:25+08:00","image":"https://chaihaojian.github.io/post/javascript_note/%E6%95%B0%E7%BB%84/cover_hu7c4cdf01cea81a03b0eb35f8c46fc90c_1264985_120x120_fill_q75_box_smart1.JPG","permalink":"https://chaihaojian.github.io/post/javascript_note/%E6%95%B0%E7%BB%84/","title":"数组"},{"content":"C++ 核心编程 内存分区模型 c++程序在执行时，将内存大方向划分为4个区域\n代码区：存放函数体的二进制代码，由操作系统进行管理 全局区：存放全局变量和静态变量以及常量 栈区：由编译器自动分配释放，存放函数的参数值、局部变量等 堆区：由程序员分配和释放，若程序员不释放，程序结束时由操作系统回收 内存四区的意义\n不同区域存放的数据，赋予不同的生命周期，给我们更大的灵活编程\n程序运行前 在程序编译后，生成了exe可执行程序，未执行该程序前分为两个区域\n代码区\n存放CPU执行的机器指令\n代码区是共享的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可\n代码区是只读的，使其只读的原因是防止程序意外的修改了它的指令\n全局区\n全局变量和静态变量存放在此 全局区还包含了常量区，字符串常量和其他常量也存放在此 该区域的数据在程序结束后由操作系统释放 1//全局变量 2int g_a = 10; 3//全局常量 4const int g_c_a = 10; 5 6int main() 7{ 8 //普通局部变量 9 int a = 10; 10 //const 修饰的局部变量 11 const int l_c_a = 10; 12 cout \u0026lt;\u0026lt; \u0026#34;address of l_c_a: \u0026#34; \u0026lt;\u0026lt; \u0026amp;l_c_a \u0026lt;\u0026lt;endl; 13 //静态变量 14 static int s_a = 10; 15 cout \u0026lt;\u0026lt; \u0026#34;address of a: \u0026#34; \u0026lt;\u0026lt; \u0026amp;a \u0026lt;\u0026lt;endl; 16 cout \u0026lt;\u0026lt; \u0026#34;address of g_a: \u0026#34; \u0026lt;\u0026lt; \u0026amp;g_a \u0026lt;\u0026lt;endl; 17 cout \u0026lt;\u0026lt; \u0026#34;address of s_a: \u0026#34; \u0026lt;\u0026lt; \u0026amp;s_a \u0026lt;\u0026lt;endl; 18 cout \u0026lt;\u0026lt; \u0026#34;address of g_c_a: \u0026#34; \u0026lt;\u0026lt; \u0026amp;g_c_a \u0026lt;\u0026lt;endl; 19 //常量 20 //字符串常量 21 cout \u0026lt;\u0026lt; \u0026#34;address of str: \u0026#34; \u0026lt;\u0026lt; \u0026amp;\u0026#34;world\u0026#34; \u0026lt;\u0026lt;endl; 22 23 return 0; 24} 程序运行后 栈区\n由编译器自动分配释放，存放函数的参数值，局部变量等 注意：不要返回局部变量的地址，栈区开辟的数据由编译器自动释放 1int* func()//如果函数有形参 形参数据也会存放在栈区 2{ 3 int a = 10;//局部变量 存放在栈区 4 return \u0026amp;a; 5}; 6 7int main() 8{ 9 int * p = func(); 10 cout \u0026lt;\u0026lt; *p \u0026lt;\u0026lt; endl;//第一次输出正常 是因为C++编译器会做一次保留 11 cout \u0026lt;\u0026lt; *p \u0026lt;\u0026lt; endl;//第二次访问该地址时 因为编译器已经将内存释放 所以拿到的值不是10 12 13 return 0; 14} ![Image 1](chap2_ 1.png)\n堆区\n由程序员分配释放，若程序员不释放，程序结束时由操作系统回收 在C++中主要利用new在堆区开辟内存 1int* func() 2{ 3 //使用new创建的数据存放在堆区 但是指针变量p的值存放在栈区 因为p是一个局部变量 4 int * p = new int(10);//使用new创建的数据存放在堆区 返回该数据的地址 5 return p; 6}; 7 8int main() 9{ 10 int * p = func();//指针p存的地址在堆区 因此该地址中的数据不会被自动释放 11 cout \u0026lt;\u0026lt; *p \u0026lt;\u0026lt; endl; 12 cout \u0026lt;\u0026lt; *p \u0026lt;\u0026lt; endl; 13 14 return 0; 15} ![Image 2](chap2_ 2.png)\nnew 操作符 C++中使用new操作符在堆区开辟数据 堆区开辟的数据，由程序员手动开辟，手动释放，释放利用操作符delete 语法：new 数据类型 利用new创建的数据，会返回该数据对应的类型的指针 使用new在堆区创建一个数组\n1void CreateArr() 2{ 3 int * arr = new int[5]; 4 for (int i = 0; i \u0026lt; 5; i++) 5 { 6 arr[i] = i + 10; 7 } 8 for (int i = 0; i \u0026lt; 5; i++) 9 { 10 cout \u0026lt;\u0026lt; arr[i] \u0026lt;\u0026lt; endl; 11 } 12 delete[] arr;//delete[] 告诉编译器释放的内存中是存储的是一个数组 13 for (int i = 0; i \u0026lt; 5; i++) 14 { 15 cout \u0026lt;\u0026lt; arr[i] \u0026lt;\u0026lt; endl; 16 } 17}; 18 19int main() 20{ 21 CreateArr(); 22 23 return 0; 24} ![Image 3](chap2_ 3.png)\n引用 引用的基本使用 **作用：**给变量起别名\n**语法：**数据类型 \u0026amp;别名 = 原名\n1int main() 2{ 3 int a = 10; 4 int \u0026amp;b = a; 5 6 cout \u0026lt;\u0026lt; \u0026#34;a: \u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; 7 cout \u0026lt;\u0026lt; \u0026#34;b: \u0026#34; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; endl; 8 9 b = 100; 10 cout \u0026lt;\u0026lt; \u0026#34;a: \u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; 11 cout \u0026lt;\u0026lt; \u0026#34;b: \u0026#34; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; endl; 12 return 0; 13} ![Image 4](chap2_ 4.png)\n引用的注意事项 引用必须初始化 引用在初始化后，不可以改变 1int main() 2{ 3 int a = 10; 4 //int \u0026amp;b;\t//只声明不初始化会报错 声明的引用必须要初始化 5 int \u0026amp;b = a; 6 int c = 20; 7 cout \u0026lt;\u0026lt; \u0026#34;a:\u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#34; b:\u0026#34; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; \u0026#34; c:\u0026#34; \u0026lt;\u0026lt; c \u0026lt;\u0026lt; endl; 8 //引用在初始化后 不可以改变 9 b = c;//赋值操作，而不是更改引用 10 cout \u0026lt;\u0026lt; \u0026#34;a:\u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#34; b:\u0026#34; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; \u0026#34; c:\u0026#34; \u0026lt;\u0026lt; c \u0026lt;\u0026lt; endl; 11 return 0; 12} ![Image 5](chap2_ 5.png)\n引用做函数参数 作用：函数传参时，可以利用引用的技术让形参修饰实参\n优点：可以简化指针修改实参\n1void swap(int \u0026amp;a, int \u0026amp;b) 2{ 3 int temp = a; 4 a = b; 5 b = temp; 6} 7 8int main() 9{ 10 int a = 10; 11 int b = 20; 12 swap(a, b);//引用传递 形参会修饰实参 13 cout \u0026lt;\u0026lt; \u0026#34;a = \u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#34; b = \u0026#34; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; endl; 14 return 0; 15} ![Image 6](chap2_ 6.png)\n引用做函数返回值 注意：\n不要返回局部变量的引用 1int\u0026amp; func() 2{ 3 int a = 100;//a是局部变量 存放在栈区 4 return a; 5}; 6 7int main() 8{ 9 int \u0026amp;p = func(); 10 cout \u0026lt;\u0026lt; p \u0026lt;\u0026lt; endl;//编译器会对栈区数据做一次保留 因此第一次cout正常 11 cout \u0026lt;\u0026lt; p \u0026lt;\u0026lt; endl;//第二次cout输出的才是内存地址a中的数据 已经被编译器释放 12 13 return 0; 14} ![Image 7](chap2_ 7.png)\n函数的调用可以作为左值 1int\u0026amp; func() 2{ 3 static int a = 100;//a是静态变量 存放在全局区 4 return a; 5}; 6 7int main() 8{ 9 int \u0026amp;p = func(); 10 cout \u0026lt;\u0026lt; p \u0026lt;\u0026lt; endl; 11 cout \u0026lt;\u0026lt; p \u0026lt;\u0026lt; endl; 12 13 func() = 1000;//如果函数的返回值是引用，则这个函数调用可以用作左值 14 cout \u0026lt;\u0026lt; p \u0026lt;\u0026lt; endl; 15 cout \u0026lt;\u0026lt; p \u0026lt;\u0026lt; endl; 16 17 return 0; 18} ![Image 8](chap2_ 8.png)\n引用的本质 引用的本质在C++内部实现是一个指针常量\n1void func(int\u0026amp; ref) 2{ 3 ref = 100; 4} 5 6int main() 7{ 8 int a = 10; 9 10 //发现是引用 自动转换为 int* const ref = \u0026amp;a; 11 //指针常量的指向不可以更改 因此引用在初始化后不可以更改 12 int\u0026amp; ref = a; 13 ref = 20;//发现是引用 自动转换为：*ref = 20 14 cout \u0026lt;\u0026lt; \u0026#34;a = \u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; 15 cout \u0026lt;\u0026lt; \u0026#34;ref = \u0026#34; \u0026lt;\u0026lt; ref \u0026lt;\u0026lt; endl; 16 17 func(a); 18 cout \u0026lt;\u0026lt; \u0026#34;a = \u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; 19 cout \u0026lt;\u0026lt; \u0026#34;ref = \u0026#34; \u0026lt;\u0026lt; ref \u0026lt;\u0026lt; endl; 20 21 return 0; 22} ![Image 9](chap2_ 9.png)\n常量引用 **作用：**常量引用主要用来修饰形参，防止误操作\n在函数的形参列表中，可以加const修饰形参，防止形参改变实参\n1void show(const int\u0026amp; val) 2{ 3 //val = 1000;//如果参数列表中不加const 该行会成功执行 导致main函数中的a的值发生变化 4 cout \u0026lt;\u0026lt; \u0026#34;val = \u0026#34; \u0026lt;\u0026lt; val \u0026lt;\u0026lt; endl; 5}; 6 7int main() 8{ 9 int a = 10; 10 11 //int \u0026amp;ref = 10;这一行会报错 引用必须引一块合法的内存空间 而这里的10只是一个字面量 12 //int \u0026amp;ref = 10; 13 14 //加上const之后 编译器会将代码修改为 15 //int temp = 10; 16 //const int \u0026amp;ref = temp; 17 //因此不会报错 18 const int \u0026amp;ref = 10; 19 20 //ref = 20;//加上const后变为只读 不可以修改 21 cout \u0026lt;\u0026lt; \u0026#34;ref = \u0026#34; \u0026lt;\u0026lt; ref \u0026lt;\u0026lt; endl; 22 23 show(a); 24 cout \u0026lt;\u0026lt; \u0026#34;a in main: \u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; 25 26 return 0; 27} ![Image 10](chap2_ 10.png)\n函数提高 函数默认参数 在C++中，函数的形参列表中的形参是可以有默认值的\n语法：返回值类型 函数名(参数 = 默认值) { }\n注意：\n如果某个位置已经有了默认参数，那么从这个位置往后，从左到右的参数都必须要有默认值 如果函数声明有默认参数，函数实现就不能有默认参数 1int SumNum(int a, int b = 20, int c = 30) 2{ 3 return a + b + c; 4}; 5 6//声明和实现只能有一个有默认参数 7int SumNum1(int a = 10, int b = 20); 8 9//声明中带默认参数 实现中也有默认参数会报错 10// int SumNum1(int a = 30, int b = 40) 11// { 12// return a + b; 13// }; 14 15int SumNum1(int a, int b) 16{ 17 return a + b; 18}; 19 20int main() 21{ 22 cout \u0026lt;\u0026lt; SumNum(10) \u0026lt;\u0026lt; endl; 23 cout \u0026lt;\u0026lt; SumNum(10, 20, 30) \u0026lt;\u0026lt; endl; 24 cout \u0026lt;\u0026lt; SumNum(10, 40, 50) \u0026lt;\u0026lt; endl; 25 26 cout \u0026lt;\u0026lt; SumNum1() \u0026lt;\u0026lt; endl; 27 cout \u0026lt;\u0026lt; SumNum1(40, 50) \u0026lt;\u0026lt; endl; 28 29 return 0; 30} ![Image 11](chap2_ 11.png)\n函数占位参数 C++中函数的形参列表里可以有占位参数，用来做占位，调用函数时必须填补该位置\n语法：返回值类型 函数名(数据类型){ }\n1void func(int a, int)//第二个int类型参数就是占位参数 占位参数可以有默认值 2{ 3 cout \u0026lt;\u0026lt; \u0026#34;hello\u0026#34; \u0026lt;\u0026lt; endl; 4} 5 6int main() 7{ 8 func(10, 10);//调用func函数必须要传入占位参数 否则会报错 9 return 0; 10} 函数重载 作用：允许函数名相同，提高复用性\n函数重载满足条件：\n同一个作用域下 函数名称相同 函数参数类型不同 或者 个数不同 或者顺序不同 注意：函数的返回值不可以作为函数重载的条件\n1void func() 2{ 3 cout \u0026lt;\u0026lt; \u0026#34;func()的调用\u0026#34; \u0026lt;\u0026lt; endl; 4}; 5 6void func(int a) 7{ 8 cout \u0026lt;\u0026lt; \u0026#34;func(int a)的调用\u0026#34; \u0026lt;\u0026lt; endl; 9} 10void func(double a) 11{ 12 cout \u0026lt;\u0026lt; \u0026#34;func(double a)的调用\u0026#34; \u0026lt;\u0026lt; endl; 13} 14 15void func(int a, double b) 16{ 17 cout \u0026lt;\u0026lt; \u0026#34;func(int a, double b)的调用\u0026#34; \u0026lt;\u0026lt; endl; 18} 19 20void func(double a, int b) 21{ 22 cout \u0026lt;\u0026lt; \u0026#34;func(double a, int b)的调用\u0026#34; \u0026lt;\u0026lt; endl; 23} 24 25//int func(double a, int b){} 26//会报错：functions that differ only in their return type cannot be overloaded 27// int func(double a, int b) 28// { 29// cout \u0026lt;\u0026lt; \u0026#34;func(double a, int b)的调用\u0026#34; \u0026lt;\u0026lt; endl; 30// return 10; 31// } 32 33int main() 34{ 35 func(); 36 func(10); 37 func(3.14); 38 func(10, 3.14); 39 func(3.14, 10); 40 return 0; 41} ![Image 12](chap2_ 12.png)\n引用作为重载条件 1//func(int \u0026amp;a)接受 int\u0026amp; 类型的变量 2void func(int \u0026amp;a) 3{ 4 cout \u0026lt;\u0026lt; \u0026#34;func(int \u0026amp;a)的调用\u0026#34; \u0026lt;\u0026lt; endl; 5} 6//func(const int \u0026amp;a)接受 const int\u0026amp; 类型的变量 7//两个函数的参数类型不同 因此可以重载 8void func(const int \u0026amp;a) 9{ 10 cout \u0026lt;\u0026lt; \u0026#34;func(const int \u0026amp;a)的调用\u0026#34; \u0026lt;\u0026lt; endl; 11} 12 13int main() 14{ 15 int a = 10; 16 func(a);//a = 10 是一个变量 因此调用func(int \u0026amp;a) 17 //func(10) 尝试调用func(int \u0026amp;a)时，会发生：int \u0026amp;a = 10; 这是不合法的 因此不会调用func(int \u0026amp;a) 18 //而调用func(const int \u0026amp;a)时，会有 const int \u0026amp;a = 10; 这是合法的 因此会调用func(const int \u0026amp;a) 19 func(10); 20 return 0; 21} ![Image 13](chap2_ 13.png)\n函数重载碰到函数默认参数 1void func(int a, int b = 20) 2{ 3 cout \u0026lt;\u0026lt; \u0026#34;func(int a, int b = 20)的调用\u0026#34; \u0026lt;\u0026lt; endl; 4} 5 6void func(int a) 7{ 8 cout \u0026lt;\u0026lt; \u0026#34;func(int a)的调用\u0026#34; \u0026lt;\u0026lt; endl; 9} 10 11int main() 12{ 13 func(10);//func(10)调用func(int a, int b = 20)和func(int a)都会成功 出现歧义 因此会报错 14 return 0; 15} ![Image 14](chap2_ 14.png)\n类和对象 C++面向对象的三大特性为：封装、继承、多态\nC++认为万事万物皆为对象，对象上有其属性和行为\n封装 封装的意义 将属性和行为作为一个整体，表现生活中的事物 1//设计一个圆类 求圆的周长 2const double PI = 3.14; 3//定义圆类 4class Circle 5{ 6//访问权限 7public:\t//公共权限 8 //圆的属性 9 double m_r; 10 //圆的行为 11 double calculateZC() 12 { 13 return 2 * PI * m_r; 14 } 15}; 16 17int main() 18{ 19 //实例化一个圆类cl 20 Circle cl; 21 cl.m_r = 10; 22 cout \u0026lt;\u0026lt; \u0026#34;圆的周长为：\u0026#34; \u0026lt;\u0026lt; cl.calculateZC() \u0026lt;\u0026lt; endl;//62.8 return 0; 23} 将属性和行为加以权限控制 访问权限有三种：\npublic 公共权限：类内可以访问，类外也可以访问 protected 保护权限：类内可以访问，类外不可以访问，子类可以访问父类中的protected权限的内容 private 私有权限：类内可以访问，类外不可以访问，子类也不可以访问父类中的private权限的内容 1class Person 2{ 3 public: 4 string p_name; 5 int p_age; 6 private: 7 string card_psd; 8 protected: 9 string p_addr; 10 public: 11 void Init() 12 { 13 p_name = \u0026#34;Tom\u0026#34;; 14 p_age = 18; 15 card_psd = \u0026#34;123456\u0026#34;; 16 p_addr = \u0026#34;c_building\u0026#34;; 17 }; 18 //Show函数定义在Person类内 因此可以访问到Person的所有属性 19 void Show() 20 { 21 cout \u0026lt;\u0026lt; \u0026#34;Name: \u0026#34; \u0026lt;\u0026lt; p_name \u0026lt;\u0026lt; \u0026#34;;\u0026#34; \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34; 22 \u0026lt;\u0026lt; \u0026#34;Age: \u0026#34; \u0026lt;\u0026lt; p_age \u0026lt;\u0026lt; \u0026#34;;\u0026#34; \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34; 23 \u0026lt;\u0026lt; \u0026#34;Card_Psd: \u0026#34; \u0026lt;\u0026lt; card_psd \u0026lt;\u0026lt; \u0026#34;;\u0026#34; \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34; 24 \u0026lt;\u0026lt; \u0026#34;Addr: \u0026#34; \u0026lt;\u0026lt; p_addr \u0026lt;\u0026lt; \u0026#34;;\u0026#34; \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34; 25 \u0026lt;\u0026lt; endl; 26 } 27}; 28 29int main() 30{ 31 Person p1; 32 p1.Init(); 33 p1.Show(); 34 p1.p_name = \u0026#34;Mike\u0026#34;; 35 p1.p_age = 20; 36 p1.Show(); 37 38 //以下操作会报错 39 //因为p_addr属性是protected权限，card_psd属性是private权限 40 //两者在类外均不可访问 41 // p1.p_addr = \u0026#34;b_building\u0026#34;; 42 // p1.card_psd = \u0026#34;654321\u0026#34;; 43 // p1.Show(); 44 45 return 0; 46} ![Image 15](chap2_ 15.png)\nstruct 和 class 的区别 在C++中，struct和class唯一的区别就在于默认的访问权限不同\n区别：\nstruct默认权限为公共 class默认权限为私有 1class C1 2{ 3 //默认为私有权限 4 int c1_v; 5}; 6 7struct S1 8{ 9 //默认为公共权限 10 int s1_v; 11}; 12 13int main() 14{ 15 C1 c; 16 S1 s; 17 c.c1_v = 10;//类外访问私有权限的属性 报错 18 s.s1_v = 10;//该行正常执行 19 20 return 0; 21} ![Image 16](chap2_ 16.png)\n成员属性设置为私有 优点1：将所有成员属性设置为私有，可以自己控制读写权限\n优点2：对于写权限，可以检测数据的有效性\n1class Person 2{ 3 //将属性都设置为私有 4 private: 5 string name; 6 int age; 7 string addr; 8 //通过定义public权限的方法，赋予私有属性读与写权限，以及验证写操作的合法性 9 public: 10 string getName()//赋予name读权限 11 { 12 return name; 13 }; 14 void setName(string s) 15 { 16 name = s; 17 }; 18 void setAge(int a)//赋予age写权限 并且验证age的合法性 19 { 20 if (a \u0026lt;= 0 || a \u0026gt; 150) 21 { 22 cout \u0026lt;\u0026lt; \u0026#34;输入的年龄\u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#34;不合法，\u0026#34; \u0026lt;\u0026lt; \u0026#34;请输入1-150之间的年龄\u0026#34; \u0026lt;\u0026lt; endl; 23 } 24 age = a; 25 }; 26 void show() 27 { 28 cout \u0026lt;\u0026lt; \u0026#34;name: \u0026#34; \u0026lt;\u0026lt; name \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34; 29 \u0026lt;\u0026lt; \u0026#34;age: \u0026#34; \u0026lt;\u0026lt; age \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34; 30 \u0026lt;\u0026lt; endl; 31 }; 32}; 33 34int main() 35{ 36 Person p1; 37 p1.setName(\u0026#34;Tom\u0026#34;); 38 p1.setAge(160); 39 p1.setAge(18); 40 p1.show(); 41 42 return 0; 43} ![Image 17](chap2_ 17.png)\n对象的初始化和清理 构造函数和析构函数 对象的初始化和清理也是两个非常重要的安全问题\n一个对象或者变量没有初始状态，对其使用后果是未知 同样的，使用完一个对象和变量，没有及时清理，也会造成一定的安全问题 C++利用了构造函数和析构函数解决上述问题，这两个函数将会被编译器自动调用，完成对象初始化和清理工作。\n对象的初始化和清理工作时编译器强制要求我们要做的事情，因此如果我们不提供构造和析构，编译器会提供\n编译器提供的构造函数和析构函数是空实现\n构造函数：主要作用在于 创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无需手动调用 析构函数：主要作用在于 对象销毁前系统自动调用，执行一些清理工作 构造函数语法： 类名 ( ) { }\n构造函数，没有返回值也不写void 函数名称与类名相同 构造函数可以有参数，因此可以发生重载 程序在调用对象的时候回自动调用构造函数，无需手动调用，而且只会调用一次 析构函数语法：~类名 ( ) { }\n析构函数，没有返回值也没有void 函数名称与类名相同，在名称前加符号 ~ 析构函数不可以有参数，因此不可以发生重载 程序在对象销毁前回自动调用析构，无需手动调用，而且只会调用一次 1//对象的初始化和清理 2class Person 3{ 4 public: 5 string Name; 6 7 Person() 8 { 9 cout \u0026lt;\u0026lt; \u0026#34;Person 的构造函数\u0026#34; \u0026lt;\u0026lt; endl; 10 }; 11 12 ~Person() 13 { 14 cout \u0026lt;\u0026lt; \u0026#34;Person 的析构函数\u0026#34; \u0026lt;\u0026lt; endl; 15 } 16}; 17 18void Test() 19{ 20 //p是存放在栈上的数据 Test函数执行完毕后 会释放p这个对象 21 //在释放p之前 编译器会自动调用析构函数 22 Person p; 23 p.Name = \u0026#34;Tom\u0026#34;; 24 cout \u0026lt;\u0026lt; p.Name \u0026lt;\u0026lt; endl; 25} 26 27int main() { 28 Test(); 29 30 return 0; 31} ![Image 18](chap2_ 18.png)\n构造函数的分类及调用 两种分类方式：\n按参数分为：有参构造和无参构造 按类型分为：普通构造和拷贝构造 三种调用方式：\n括号法 显示法 隐式转换法 1class Person 2{ 3 public: 4 string Name; 5 int Age; 6 7 Person() 8 { 9 cout \u0026lt;\u0026lt; \u0026#34;Person 的构造函数\u0026#34; \u0026lt;\u0026lt; endl; 10 }; 11 12 Person(int a) 13 { 14 cout \u0026lt;\u0026lt; \u0026#34;Person 的有参构造函数\u0026#34; \u0026lt;\u0026lt; endl; 15 Age = a; 16 }; 17 18 Person(const Person \u0026amp;p)//需要保证被拷贝的对象不会被修改 19 { 20 cout \u0026lt;\u0026lt; \u0026#34;Person 的拷贝构造函数\u0026#34; \u0026lt;\u0026lt; endl; 21 Age = p.Age; 22 }; 23 24 ~Person() 25 { 26 cout \u0026lt;\u0026lt; \u0026#34;Person 的析构函数\u0026#34; \u0026lt;\u0026lt; endl; 27 } 28}; 29 30void Test() 31{ 32 Person p1;//调用默认构造函数 Person(){} 33 p1.Age = 18; 34 cout \u0026lt;\u0026lt; \u0026#34;p1的Age：\u0026#34; \u0026lt;\u0026lt; p1.Age \u0026lt;\u0026lt; endl; 35 cout \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34; \u0026lt;\u0026lt; endl; 36 37 Person p2(10);//括号法 此时调用 Person(int a){} 38 cout \u0026lt;\u0026lt; \u0026#34;p2的Age：\u0026#34; \u0026lt;\u0026lt; p2.Age \u0026lt;\u0026lt; endl; 39 Person p3(p1);//括号法 此时调用 Person(const Person \u0026amp;p){} 40 cout \u0026lt;\u0026lt; \u0026#34;p3的Age：\u0026#34; \u0026lt;\u0026lt; p3.Age \u0026lt;\u0026lt; endl; 41 //发生拷贝构造时不会改变被拷贝对象p1的值 42 cout \u0026lt;\u0026lt; \u0026#34;p1的Age：\u0026#34; \u0026lt;\u0026lt; p1.Age \u0026lt;\u0026lt; endl; 43 //cout \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34; \u0026lt;\u0026lt; endl; 44 45 //注意 默认构造函数的调用不需要加括号 46 //编译器会认为这是一个函数声明 47 //不会报错 但是也不会实例p4 48 Person p4(); 49 cout \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34; \u0026lt;\u0026lt; endl; 50 51 Person p5 = Person(10);//显示法的有参构造 52 cout \u0026lt;\u0026lt; \u0026#34;p5的Age：\u0026#34; \u0026lt;\u0026lt; p5.Age \u0026lt;\u0026lt; endl; 53 Person p6 = Person(p1);//显示法的拷贝构造 54 cout \u0026lt;\u0026lt; \u0026#34;p6的Age：\u0026#34; \u0026lt;\u0026lt; p6.Age \u0026lt;\u0026lt; endl; 55 cout \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34; \u0026lt;\u0026lt; endl; 56 57 //匿名对象 特点：当前行执行结束后就会被释放 58 Person(20); 59 cout \u0026lt;\u0026lt; \u0026#34;aaaaa\u0026#34; \u0026lt;\u0026lt; endl; 60 //注意：不要用拷贝构造函数初始化一个匿名函数 61 //编译器会认为 Person(p1) 等价于 Person p1 62 //因此编译器会报错 p1被重定义 63 //Person(p1); 64 cout \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34; \u0026lt;\u0026lt; endl; 65 66 Person p7 = 22;//隐式转换法 等价于 Person p7 = Person(22) 67 cout \u0026lt;\u0026lt; \u0026#34;p7的Age：\u0026#34; \u0026lt;\u0026lt; p7.Age \u0026lt;\u0026lt; endl; 68 Person p8 = p1;//隐式转换法 等价于 Person p7 = Person(22) 69 cout \u0026lt;\u0026lt; \u0026#34;p8的Age：\u0026#34; \u0026lt;\u0026lt; p8.Age \u0026lt;\u0026lt; endl; 70 cout \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34; \u0026lt;\u0026lt; endl; 71} 72 73int main() { 74 Test(); 75 76 return 0; 77} ![Image 19](chap2_ 19.png)\n拷贝构造函数的调用时机 C++中拷贝构造函数的调用时机通常有三种情况：\n使用一个已经创建完毕的对象来初始化一个新对象 值传递的方式给函数参数传值 以值方式返回局部对象 1//拷贝构造函数的调用时机 2class Person 3{ 4 public: 5 string Name; 6 int Age; 7 8 Person() 9 { 10 cout \u0026lt;\u0026lt; \u0026#34;Person 的默认构造函数\u0026#34; \u0026lt;\u0026lt; endl; 11 }; 12 13 Person(int a) 14 { 15 cout \u0026lt;\u0026lt; \u0026#34;Person 的有参构造函数\u0026#34; \u0026lt;\u0026lt; endl; 16 Age = a; 17 }; 18 19 Person(const Person \u0026amp;p)//需要保证被拷贝的对象不会被修改 20 { 21 cout \u0026lt;\u0026lt; \u0026#34;Person 的拷贝构造函数\u0026#34; \u0026lt;\u0026lt; endl; 22 Age = p.Age; 23 }; 24 25 ~Person() 26 { 27 cout \u0026lt;\u0026lt; \u0026#34;Person 的析构函数\u0026#34; \u0026lt;\u0026lt; endl; 28 } 29}; 30 31void test_1() 32{ 33 cout \u0026lt;\u0026lt; \u0026#34;------使用一个已经创建完毕的对象来初始化一个新对象------\u0026#34; \u0026lt;\u0026lt; endl; 34 Person p1; 35 p1.Age = 18; 36 Person p2(p1);//此时产生了一个p1的副本 p2拷贝的是这个p1的副本 因此p2的修改不会影响p1 37 p2.Age = 22; 38 cout \u0026lt;\u0026lt; \u0026#34;p1.Age: \u0026#34; \u0026lt;\u0026lt; p1.Age \u0026lt;\u0026lt; endl; 39 cout \u0026lt;\u0026lt; \u0026#34;p2.Age: \u0026#34; \u0026lt;\u0026lt; p2.Age \u0026lt;\u0026lt; endl; 40}; 41 42void goWork(Person p) 43{ 44 p.Age = 22; 45 cout \u0026lt;\u0026lt; \u0026#34;p.Age: \u0026#34; \u0026lt;\u0026lt; p.Age \u0026lt;\u0026lt; endl; 46}; 47 48void test_2() 49{ 50 cout \u0026lt;\u0026lt; \u0026#34;------值传递的方式给函数参数传值------\u0026#34; \u0026lt;\u0026lt; endl; 51 Person p1; 52 p1.Age = 18; 53 goWork(p1);//该函数进行值传递 因此会产生一个p1的副本 函数goWork拷贝该副本 54 cout \u0026lt;\u0026lt; \u0026#34;p1.Age: \u0026#34; \u0026lt;\u0026lt; p1.Age \u0026lt;\u0026lt; endl; 55}; 56 57Person goWork() 58{ 59 Person p; 60 p.Age = 18; 61 //cout \u0026lt;\u0026lt; \u0026#34;p.Age: \u0026#34; \u0026lt;\u0026lt; p.Age \u0026lt;\u0026lt; endl; 62 cout \u0026lt;\u0026lt; \u0026#34;address of p: \u0026#34; \u0026lt;\u0026lt; (int*)\u0026amp;p \u0026lt;\u0026lt; endl; 63 return p; 64} 65 66void test_3() 67{ 68 cout \u0026lt;\u0026lt; \u0026#34;------以值方式返回局部对象------\u0026#34; \u0026lt;\u0026lt; endl; 69 Person p1 = goWork(); 70 //cout \u0026lt;\u0026lt; \u0026#34;p1.Age: \u0026#34; \u0026lt;\u0026lt; p1.Age \u0026lt;\u0026lt; endl; 71 cout \u0026lt;\u0026lt; \u0026#34;address of p1: \u0026#34; \u0026lt;\u0026lt; (int*)\u0026amp;p1 \u0026lt;\u0026lt; endl; 72} 73 74int main() 75{ 76 test_1(); 77 test_2(); 78 test_3(); 79 return 0; 80} ![Image 20](chap2_ 20.png)\n注意：在函数 test_3() 中实际需要调用3次构造函数，但在实际编译运行中只调用了一次默认构造函数，且对象p与对象p1的地址相同，这是因为g++编译器默认开启了返回值优化RVO(return value optimization)，通过命令 -fno-elide-constructors 关闭RVO则会输出以下结果：\n1g++ main.cpp -fno-elide-constructors -o ../../target/main \u0026amp;\u0026amp; ../../target/main ![Image 21](chap2_ 21.png)\n","date":"2024-03-16T14:18:58+08:00","image":"https://chaihaojian.github.io/post/c_plus_note/chapter2_%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/cover_huae254b8ee1ab91911036d94a912fa4f7_868221_120x120_fill_q75_box_smart1.JPG","permalink":"https://chaihaojian.github.io/post/c_plus_note/chapter2_%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/","title":"C++核心编程"},{"content":"","date":"2024-03-09T13:31:05+08:00","image":"https://chaihaojian.github.io/post/javascript_note/javascript%E5%80%BC%E7%B1%BB%E5%9E%8B%E4%BD%BF%E7%94%A8/cover_hu5d37d57dbb2a2417866d45a70fddc4ea_305553_120x120_fill_q75_box_smart1.JPG","permalink":"https://chaihaojian.github.io/post/javascript_note/javascript%E5%80%BC%E7%B1%BB%E5%9E%8B%E4%BD%BF%E7%94%A8/","title":"Javascript值类型使用"},{"content":"运算符与流程控制 一元运算符的前置与后置操作(++n与n++的区别) 两者在不参与其他运算时结果相同，都是n自增；\n1let a = 1; 2let b = 1; 3++a; 4console.log(a); 5b++; 6console.log(b); 在参与其他运算时，++n先自增，再进行运算；n++先进行运算，再自增。\n1let n = 1; 2let m = 1; 3let f = 2; 4let d = f + ++n;//n先自增，然后运算f + n 5console.log(d); 6console.log(n); 7let e = f + m++;//先运算f + n, 然后n自增 8console.log(e); 9console.log(m); 比较运算符 == 与 === a == b，如果a, b不是相同类型的变量，js会自动将两个变量转换成相同类型再进行比较；a === b 则会直接进行比较。\n1let a = 1; 2let b = \u0026#34;1\u0026#34;; 3console.log(a == b); 4console.log(a \u0026gt;= b); 5console.log(a === b); 逻辑运算符 逻辑与： \u0026amp;\u0026amp;\n逻辑或： ||\n逻辑非： !\n短路运算 1可以表示true；0可以表示false；\n1let a = 1, b = 0; 2console.log(a == true) 3console.log(a == false) 4console.log(b == true) 5console.log(b == false) 在逻辑或进行判断时，如 （a || b）：若a为真，则不再判断b，直接返回真；若a为假，则继续判断b的真假；\n短路运算在赋值中的妙用 1let a = 3; 2let b; 3let c = 4; 4let f = b || a;//b为空，因此将a的值赋给f 5console.log(f); 6let p = c || a;//c不为空，因此不需要判断a，直接将c的值赋给p 7console.log(p); 流程控制 if else 三元表达式 1let h = true?2:5; 2console.log(h); 3let l = false?2:5; 4console.log(l); switch 1let name = \u0026#34;hi\u0026#34; 2switch(name){ 3 case \u0026#34;hello\u0026#34;: 4 console.log(\u0026#34;hello\u0026#34;); 5 break; 6 case \u0026#34;hi\u0026#34;: 7 console.log(\u0026#34;hi\u0026#34;); 8 break; 9 default: 10 console.log(\u0026#34;default\u0026#34;); 11}; while 循环控制 1function genTable(options = {tr: 5, td: 3}){ 2 document.write(`\u0026lt;table border = \u0026#34;1\u0026#34; width=\u0026#34;100%\u0026#34;`); 3 while(options.tr-- != 0){ 4 let td = options.td; 5 document.write(`\u0026lt;tr\u0026gt;`); 6 while(td-- != 0){ 7 document.write(`\u0026lt;td\u0026gt;${td}\u0026lt;/td\u0026gt;`); 8 } 9 document.write(`\u0026lt;/tr\u0026gt;`); 10 } 11 document.write(`\u0026lt;/table\u0026gt;`); 12} 13genTable(); 14document.write(`\u0026lt;br/\u0026gt;`); 15genTable({tr: 3, td: 5}); do while 循环控制 1function genStars(row = 5){ 2 let l = 0; 3 do { 4 let n = 0; 5 do { 6 document.write(\u0026#34;*\u0026#34;); 7 } while (++n \u0026lt;= l); 8 document.write(`\u0026lt;br/\u0026gt;`); 9 } while(++l \u0026lt; row); 10}; 11genStars(); 12document.write(`\u0026lt;br/\u0026gt;`); 13genStars(8); for 循环 1function genStars(row = 5){ 2 for (let i = 1; i \u0026lt;= row; i++){ 3 for (let n = row - i; n \u0026gt; 0; n--){ 4 document.write(`\u0026lt;span style=\u0026#34;color: white\u0026#34;\u0026gt;^\u0026lt;/span\u0026gt;`); 5 } 6 for (let m = i * 2 - 1; m \u0026gt; 0; m--){ 7 document.write(`*`); 8 } 9 document.write(`\u0026lt;br/\u0026gt;`); 10 } 11} 12genStars(); 13document.write(`\u0026lt;br/\u0026gt;`); 14genStars(8); continue 与 break continue：停止当前循环，进行下一次循环；\nbreak：终止当前循环；\n如果需要从子循环直接终止更上一级的循环，需要通过标签：\n1pa: for (let i = 1; i \u0026lt;= 10; i++){ 2 ch: for (let j = 1; j \u0026lt;= 10; j++){ 3 if (j % 2 == 0){ 4 console.log(i, j); 5 } 6 if (i + j \u0026gt; 10){ 7 break pa; 8 }; 9 }; 10}; for-in 与 for-of 1let array = [1, 2, 3, 4]; 2for (let key in array){ 3 console.log(key, array[key]); 4}; 1let array = [1, 2, 3, 4]; 2for (const value of array) { 3 console.log(value); 4}; ","date":"2024-03-06T11:44:29+08:00","image":"https://chaihaojian.github.io/post/javascript_note/%E8%BF%90%E7%AE%97%E7%AC%A6%E4%B8%8E%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/cover_hu7c4cdf01cea81a03b0eb35f8c46fc90c_1264985_120x120_fill_q75_box_smart1.JPG","permalink":"https://chaihaojian.github.io/post/javascript_note/%E8%BF%90%E7%AE%97%E7%AC%A6%E4%B8%8E%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/","title":"运算符与流程控制"},{"content":"C++基础语法 变量 创建变量 1//数据类型 变量名 = 变量初始值; 2int a = 10; 常量 常量的作用 用于记录程序中不可更改的数据\nC++定义常量的两种方式 1.#define 宏常量 1#include \u0026lt;iostream\u0026gt; 2using namespace std; 3 4#define Day 7 5 6int main() 7{ 8 cout \u0026lt;\u0026lt; Day \u0026lt;\u0026lt; endl; 9 10 return 0; 11} 2.const修饰的变量 1#include \u0026lt;iostream\u0026gt; 2using namespace std; 3 4int main() 5{ 6 const int month = 12; 7 8 cout \u0026lt;\u0026lt; month \u0026lt;\u0026lt; endl; 9 10 return 0; 11} 关键字 关键字是C++中预先保留的单词（标识符），在定义变量或常量时，不要用关键字，否则会产生歧义。\n标识符命名规则 标识符不能是关键字；\n标识符只能由字母、数字、下划线组成；\n第一个字符必须为字母或下划线；\n标识符中的字母区分大小写；\n数据类型（给变量或常量分配合适的内存空间） C++规定在创建一个变量或者常量时，必须要指定相应的数据类型，否则无法给变量分配内存。\nsizeof 关键字 利用sizeof关键字可以统计数据类型所占内存大小：sizeof(数据类型 / 变量)\n1#include \u0026lt;iostream\u0026gt; 2using namespace std; 3 4int main() 5{ 6 short num1 = 10; 7 cout \u0026lt;\u0026lt; \u0026#34;space occupied by num1:\u0026#34; \u0026lt;\u0026lt; sizeof(num1) \u0026lt;\u0026lt; endl; 8 //space occupied by num1:2 9 10 int num2 = 10; 11 cout \u0026lt;\u0026lt; \u0026#34;space occupied by int:\u0026#34; \u0026lt;\u0026lt; sizeof(int) \u0026lt;\u0026lt; endl; 12 //space occupied by int:4 13 14 return 0; 15} 整型 C++中能够表示整型的类型有以下几种方式，区别在于所占内存空间不同：\n数据类型 占用空间 取值范围 short（短整型） 2 字节 （-2^15 - 2^15-1） Int（整型） 4 字节 （-2^31 - 2^31-1） long（长整型） Windows为 4 字节，Linux为 4 字节（32 位），8字节（64 位） （-2^31 - 2^31-1） long long（长长整型） 8 字节 （-2^63 - 2^63-1） 当需要保存的值超出当前数据类型的取值范围时，c++会提示警告超出内存，但不会报错，该变量值会变为在该数据类型的取值范围内最接近该变量值的值：\n1#include \u0026lt;iostream\u0026gt; 2using namespace std; 3 4int main() 5{ 6 //短整型 7 short num1 = 10; 8 //整型 9 int num2 = 10; 10 //长整型 11 long num3 = 10; 12 //长长整型 13 long long num4 = 10; 14 15 cout \u0026lt;\u0026lt; \u0026#34;num1:\u0026#34; \u0026lt;\u0026lt; num1 \u0026lt;\u0026lt; endl; 16 cout \u0026lt;\u0026lt; \u0026#34;num2:\u0026#34; \u0026lt;\u0026lt; num2 \u0026lt;\u0026lt; endl; 17 cout \u0026lt;\u0026lt; \u0026#34;num3:\u0026#34; \u0026lt;\u0026lt; num3 \u0026lt;\u0026lt; endl; 18 cout \u0026lt;\u0026lt; \u0026#34;num4:\u0026#34; \u0026lt;\u0026lt; num4 \u0026lt;\u0026lt; endl; 19 20 num1 = 32768; 21 cout \u0026lt;\u0026lt; \u0026#34;num1:\u0026#34; \u0026lt;\u0026lt; num1 \u0026lt;\u0026lt; endl; 22 23 num1 = -32769; 24 cout \u0026lt;\u0026lt; \u0026#34;num1:\u0026#34; \u0026lt;\u0026lt; num1 \u0026lt;\u0026lt; endl; 25 26 return 0; 27} 实型（浮点型） 浮点型变量分为两种：\n单精度 float 双精度 double 两者的区别在于表示的有效数字范围不同。\n数据类型 占用空间 有效数字范围 float 4字节 7位有效数字 double 8字节 15-16位有效数字 1float a = 3.14f;//(float)(3.14F) 建议使用该方法声明一个float变量 2float b = 3.14;//(double)(3.14) 上述两种方法都声明了一个float变量，但第二种方法c++默认值小数3.14是double类型，在声明后需要将double类型的3.14转换为float类型，在变量值后加f则表明3.14是float类型；\n1float a = 3.1415926f; 2float b = 3.14; 3 4cout \u0026lt;\u0026lt; \u0026#34;a = \u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; 5 6double m = 3.1415926; 7cout \u0026lt;\u0026lt; \u0026#34;m = \u0026#34; \u0026lt;\u0026lt; m \u0026lt;\u0026lt; endl; 注意：默认情况下，float和double类型的变量在输出时，都只会显示出6位有效数字。\n科学计数法 1float c = 3e2;//3 * 10^2 2float d = 3e-2;//3 * 10^-2 3cout \u0026lt;\u0026lt; \u0026#34;c = \u0026#34; \u0026lt;\u0026lt; c \u0026lt;\u0026lt; endl; 4cout \u0026lt;\u0026lt; \u0026#34;d = \u0026#34; \u0026lt;\u0026lt; d \u0026lt;\u0026lt; endl; 字符型（表示单个字符） 1char ch = \u0026#39;a\u0026#39;; 2cout \u0026lt;\u0026lt; \u0026#34;ch: \u0026#34; \u0026lt;\u0026lt; ch \u0026lt;\u0026lt; endl; 3cout \u0026lt;\u0026lt; \u0026#34;size of ch: \u0026#34; \u0026lt;\u0026lt; sizeof(ch) \u0026lt;\u0026lt; endl; 4cout \u0026lt;\u0026lt; \u0026#34;ASCII of ch: \u0026#34; \u0026lt;\u0026lt; (int)ch \u0026lt;\u0026lt; endl; 注意：\n在显示字符型变量时，用单引号将字符括起来，不要用双引号； 单引号内只能有一个字符，不可以是字符串； C和C++中字符型变量只占用一个字节； 字符型变量并不是把字符本身放到内存中存储，而是将字符对应的ASCII编码放入到存储单元。 字符型变量对应的ASCII码 a - 97 A - 65 转义字符 用于表示一些不能直接输出的ASCII字符\n转义字符 含义 ASCII码（十进制） \\n 换行 010 \\t 水平制表（跳到下一个TAB位置） 009 \\\\ 代表一个反斜杠字符\u0026quot;\\\u0026quot; 092 字符串型（表示一串字符） C风格字符串 1char str1[] = \u0026#34;hello\u0026#34;; C++风格字符串 1#include\\\u0026lt;string\u0026gt; 2using namespace std； 3 4string str2 = \u0026#34;world\u0026#34;; 注意：使用C++风格字符串需要包含一个头文件 #include\u0026lt;string\u0026gt;和using namespace std\n布尔类型 bool类型只有两个值：\ntrue 表示真，本质是1； false 表示假，本质是0； bool类型占一个字节\n运算符（执行代码的运算） 算数运算符（处理四则运算） 运算符 术语 示例 结果 + - + - * / % 取余 ++ 前置递增（先让变量+1，然后进行表达式运算） a=2; b=++a; a=3; b=3; ++ 后置递增（先进行表达式运算，后让变量+1） a=2; b=a++; a=3; b=2; \u0026ndash; 前置递减 a=2; b=\u0026ndash;a; a=1; b=1; \u0026ndash; 后置递减 a=2; b=a\u0026ndash;; a=1; b=2; 赋值运算符（将表达式的值赋给变量） 运算符 术语 示例 结果 = += -= *= /= %= 比较运算符（用于表达式的比较，返回一个真值或假值） 运算符 术语 示例 结果 == != \u0026lt; \u0026gt; \u0026lt;= \u0026gt;= 逻辑运算符 运算符 术语 示例 结果 ! \u0026amp;\u0026amp; || 程序流程控制结构 顺序结构（程序按顺序执行，不发生跳转） 选择结构（依据条件是否满足，有选择地执行相应功能） if 语句 三目运算符 语法：表达式1 ？表达式2 ：表达式3；\n如果表达式1为真，执行表达式2，并返回表达式2的结果；\n如果表达式1为假，执行表达式3，并返回表达式3的结果；\nswitch 语句 循环结构 数组 数组的特点 数组中的每一个数据元素都是相同的数据类型； 数组是由连续的内存位置组成的； 数组的定义 数据类型 数组名[数组长度]； 数据类型 数组名[数组长度] = {值1，值2 \u0026hellip;}; 数据类型 数组名[] = {值1，值2 \u0026hellip;}; 一维数组 一维数组在内存中的长度 1int arr[5] = {1,2,3,4,5}; 2cout \u0026lt;\u0026lt; \u0026#34;arrdress of arr: \u0026#34; \u0026lt;\u0026lt; arr \u0026lt;\u0026lt; endl; 3cout \u0026lt;\u0026lt; \u0026#34;size of arr: \u0026#34; \u0026lt;\u0026lt; sizeof(arr) \u0026lt;\u0026lt; endl; 4cout \u0026lt;\u0026lt; \u0026#34;size of arr[0]: \u0026#34; \u0026lt;\u0026lt; sizeof(arr[0]) \u0026lt;\u0026lt; endl; 5cout \u0026lt;\u0026lt; \u0026#34;length of arr: \u0026#34; \u0026lt;\u0026lt; sizeof(arr) / sizeof(arr[0]) \u0026lt;\u0026lt; endl; 一维数组的冒泡排序 思路（升序）：\n比较相邻的两个元素，如果第一个比第二个大，就交换它们的位置； 对每一个元素做同样的工作，执行完第一次后，找到数组中的第一个最大值； 重复上述步骤，每次比较次数-1，直到不需要比较； 二维数组 二维数组在内存中的长度 1int arr[2][3] = 2{ 3 {1,2,3}, 4 {4,5,6} 5}; 6 7cout \u0026lt;\u0026lt; \u0026#34;arrdress of arr: \u0026#34; \u0026lt;\u0026lt; arr \u0026lt;\u0026lt; endl; 8cout \u0026lt;\u0026lt; \u0026#34;size of arr: \u0026#34; \u0026lt;\u0026lt; sizeof(arr) \u0026lt;\u0026lt; endl; 9cout \u0026lt;\u0026lt; \u0026#34;size of arr[0]: \u0026#34; \u0026lt;\u0026lt; sizeof(arr[0]) \u0026lt;\u0026lt; endl; 10cout \u0026lt;\u0026lt; \u0026#34;length of arr: \u0026#34; \u0026lt;\u0026lt; sizeof(arr) / sizeof(arr[0]) \u0026lt;\u0026lt; endl; 11cout \u0026lt;\u0026lt; \u0026#34;items of arr: \u0026#34; \u0026lt;\u0026lt; sizeof(arr) / sizeof(arr[0][0]) \u0026lt;\u0026lt; endl; 函数 函数的定义 1//定义一个函数 2返回值类型 函数名（参数列表） 3{ 4 函数体语句 5 6 return表达式 7} 函数的调用 值传递 函数在发生调用时，实参将值传递给形参；\n值传递时，形参发生变化，并不会影响实参；\n函数的声明 作用：提前告诉编译器函数名称及如何调用函数，函数的实际主体可以单独定义；函数的声明可以多次，但是函数的定义只能有一次；\n1int main() 2{ 3 int m = 2; 4 int n = 4; 5 cout \u0026lt;\u0026lt; maxNum(m, n) \u0026lt;\u0026lt; endl; 6 7 return 0; 8} 9 10int maxNum(int a, int b) 11{ 12 return a \u0026gt; b ? a : b; 13} 函数maxNum定义在main函数之后会产生报错；需要在执行main函数之前告诉编译器有maxNum这样一个函数存在，因此可以将maxNum函数定义在main函数之前，或者在main函数之前使用声明语句；\n1int maxNum(int a, int b); 2 3int maxNum(int a, int b) 4{ 5 return a \u0026gt; b ? a : b; 6} 7 8int main() 9{ 10 int m = 2; 11 int n = 4; 12 cout \u0026lt;\u0026lt; maxNum(m, n) \u0026lt;\u0026lt; endl;//4 13 14 return 0; 15} 函数的分文件编写 函数分文件编写的步骤：\n创建后缀名为.h的头文件； 创建后缀名为.cpp的源文件； 在头文件中写函数的声明； 在源文件中写函数的定义； 一个c++项目的文件结构如下：\n1//maxNum.h 2 3#include \u0026lt;iostream\u0026gt; 4using namespace std; 5 6int maxNum(int a, int b); 1//maxNum.cpp 2 3#include \u0026#34;../inc/maxNum.h\u0026#34; 4// #include \u0026lt;iostream\u0026gt; 5// using namespace std; 6 7int maxNum(int a, int b) 8{ 9 cout \u0026lt;\u0026lt; \u0026#34;helllo\u0026#34; \u0026lt;\u0026lt; endl; 10 return a \u0026gt; b ? a : b; 11} 1//main.cpp 2 3int main() 4{ 5 int m = 2; 6 int n = 4; 7 cout \u0026lt;\u0026lt; maxNum(m, n) \u0026lt;\u0026lt; endl; 8 9 return 0; 10} 指针 作用：可以通过指针直接访问内存\n内存编号是从0开始记录的，一般用16进制数字表示；\n可以利用指针变量保存地址；\n指针变量的定义和使用 定义语法：数据类型 * 变量名；\n使用方法：可以通过解引用的方式来找到指针指向的内存中保存的值；指针变量前加*代表解引用，找到指针指向的内存中的数据；\n1int main() 2{ 3 int a = 10; 4 int * p; 5 p = \u0026amp;a; 6 cout \u0026lt;\u0026lt; \u0026#34;the value of a: \u0026#34; \u0026lt;\u0026lt; p \u0026lt;\u0026lt; endl; 7 cout \u0026lt;\u0026lt; \u0026#34;address of a: \u0026#34; \u0026lt;\u0026lt; \u0026amp;a \u0026lt;\u0026lt; endl; 8 cout \u0026lt;\u0026lt; \u0026#34;the value of p: \u0026#34; \u0026lt;\u0026lt; p \u0026lt;\u0026lt; endl; 9 cout \u0026lt;\u0026lt; \u0026#34;the value pointed to by pointer p: \u0026#34; \u0026lt;\u0026lt; *p \u0026lt;\u0026lt; endl; 10 11 *p = 100; 12 cout \u0026lt;\u0026lt; \u0026#34;the value of a: \u0026#34; \u0026lt;\u0026lt; p \u0026lt;\u0026lt; endl; 13 cout \u0026lt;\u0026lt; \u0026#34;address of a: \u0026#34; \u0026lt;\u0026lt; \u0026amp;a \u0026lt;\u0026lt; endl; 14 cout \u0026lt;\u0026lt; \u0026#34;the value of p: \u0026#34; \u0026lt;\u0026lt; p \u0026lt;\u0026lt; endl; 15 cout \u0026lt;\u0026lt; \u0026#34;the value pointed to by pointer p: \u0026#34; \u0026lt;\u0026lt; *p \u0026lt;\u0026lt; endl; 16 17 return 0; 18} 指针类型所占的内存空间 编译器编译的程序是32位时(X86)，指针类型占4个字节的内存空间； 编译器编译的程序是64位时(X64, ARM64)，指针类型占8个字节的内存空间； 空指针和野指针 空指针：指针变量指向内存中编号为0的空间；\n用途：初始化指针变量；\n注意：空指针指向的内存是不可以访问的；\n野指针：指针变量指向非法的内存空间；\n空指针和野指针都不是自己申请的空间，因此不能访问；\n1int main() 2{ 3 //声明了一个空指针p1 4 int * p1 = NULL; 5 *p1 = 10; 6 cout \u0026lt;\u0026lt; \u0026#34;the value pointed to by pointer p1: \u0026#34; \u0026lt;\u0026lt; *p1 \u0026lt;\u0026lt; endl; 7 8 //给指针类型变量p2赋了一个地址值(int *)0x1100， 9 //但该地址值不是本程序申请的，因此无法对该地址指向的内存空间进行读写 10 int * p2 = (int *)0x1100; 11 *p2 = 10; 12 cout \u0026lt;\u0026lt; \u0026#34;the value pointed to by pointer p2: \u0026#34; \u0026lt;\u0026lt; *p2 \u0026lt;\u0026lt; endl; 13 14 return 0; 15} const修饰指针 const修饰指针有三种情况：\nconst修饰指针\t\u0026mdash;常量指针（常量的指针，该指针指向的值是一个常量）； const修饰常量 \u0026mdash;指针常量（该指针类型变量是一个常量）； const既修饰指针，又修饰常量； 常量指针 const int * p = \u0026amp;a; 指针的指向可以修改； 指针指向的值不可以修改； 1int main() 2{ 3 int a = 10; 4 int b = 100; 5 6 const int * p = \u0026amp;a;//声明了一个常量指针p 7 8 *p = 20;//对指针p指向的值进行修改，会报错 9 p = \u0026amp;b;//改变指针p的指向，不会报错 10 11 return 0; 12} 指针常量 int * const p = \u0026amp;a; 指针的指向不可以修改； 指针指向的值可以修改； 1int main() 2{ 3 int a = 10; 4 int b = 100; 5 6 int * const p = \u0026amp;a;//声明了一个指针常量 7 8 *p = 20;//该指针常量指向的值可以修改 9 p = \u0026amp;b;//该指针类型p是一个常量，因此p的值不能修改 10 11 return 0; 12} const既修饰指针，又修饰常量 指针的指向和指针指向的值都不可以修改； 1int main() 2{ 3 int a = 10; 4 int b = 100; 5 const int * const p = \u0026amp;a;//既修饰指针，又修饰常量 6 7 *p = 20;//指针p指向的值是一个常量，因此不可以修改 8 p = \u0026amp;b;//指针p是一个常量，因此指针p的值即指针p的指向不可以修改 9 10 return 0; 11} 指针和数组（利用指针访问数组中的元素） 1 2int main() 3{ 4 int arr[5] = {1,2,3,4,5}; 5 int * p = arr; 6 7 cout \u0026lt;\u0026lt; \u0026#34;pointer p points to the head of arr: \u0026#34; \u0026lt;\u0026lt; *p \u0026lt;\u0026lt; endl; 8 9 p++; 10 cout \u0026lt;\u0026lt; \u0026#34;pointer p points to the second element of arr: \u0026#34; \u0026lt;\u0026lt; *p \u0026lt;\u0026lt; endl; 11 12 return 0; 13} 指针和函数 值传递 1void swap01(int a, int b) 2{ 3 int temp = a; 4 a = b; 5 b = temp; 6 7 cout \u0026lt;\u0026lt; \u0026#34;swap01 a = \u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; 8 cout \u0026lt;\u0026lt; \u0026#34;swap01 b = \u0026#34; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; endl; 9} 10 11int main() 12{ 13 int a = 1; 14 int b = 2; 15 swap01(a, b);//swap01()函数中的参数是值传递，因此不会改变实参的值 16 17 cout \u0026lt;\u0026lt; \u0026#34;main a = \u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; 18 cout \u0026lt;\u0026lt; \u0026#34;main b = \u0026#34; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; endl; 19 return 0; 20} 地址传递 1void swap(int * a, int * b) 2{ 3 int temp = *a; 4 *a = *b; 5 *b = temp; 6 7 cout \u0026lt;\u0026lt; \u0026#34;swap *a = \u0026#34; \u0026lt;\u0026lt; *a \u0026lt;\u0026lt; endl; 8 cout \u0026lt;\u0026lt; \u0026#34;swap *b = \u0026#34; \u0026lt;\u0026lt; *b \u0026lt;\u0026lt; endl; 9} 10 11int main() 12{ 13 int a = 1; 14 int b = 2; 15 swap(\u0026amp;a, \u0026amp;b);//传入swap()函数的是a，b的地址，因此会对实参造成改变 16 17 cout \u0026lt;\u0026lt; \u0026#34;main a = \u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; 18 cout \u0026lt;\u0026lt; \u0026#34;main b = \u0026#34; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; endl; 19 return 0; 20} 结构体 结构体术语用户自定义的数据类型，允许用户存储不同的数据类型 结构体的定义和使用 通过结构体创建变量的方式：\nstruct 结构体名 变量名 struct 结构体名 变量名 = {成员1值，成员2值\u0026hellip;} 定义结构体时顺便创建变量 1struct Student 2{ 3 string Name; 4 int age; 5 float score; 6}s3;//在定义结构体时顺便声明了一个Student类型的结构体s3 7 8int main() 9{ 10 struct Student s1;//声明一个Student类型的结构体s1，并给s1赋值 11 s1.Name = \u0026#34;mike\u0026#34;; 12 s1.age = 22; 13 s1.score = 88.88; 14 cout \u0026lt;\u0026lt; \u0026#34;姓名：\u0026#34; \u0026lt;\u0026lt; s1.Name\u0026lt;\u0026lt; \u0026#34;; \u0026#34; 15 \u0026lt;\u0026lt;\u0026#34;年龄：\u0026#34; \u0026lt;\u0026lt; s1.age \u0026lt;\u0026lt; \u0026#34;; \u0026#34; 16 \u0026lt;\u0026lt; \u0026#34;分数：\u0026#34; \u0026lt;\u0026lt; s1.score \u0026lt;\u0026lt; endl; 17 18 struct Student s2 = {\u0026#34;tom\u0026#34;, 21, 89};//声明s2的同时给s2赋值 19 cout \u0026lt;\u0026lt; \u0026#34;姓名：\u0026#34; \u0026lt;\u0026lt; s2.Name\u0026lt;\u0026lt; \u0026#34;; \u0026#34; 20 \u0026lt;\u0026lt;\u0026#34;年龄：\u0026#34; \u0026lt;\u0026lt; s2.age \u0026lt;\u0026lt; \u0026#34;; \u0026#34; 21 \u0026lt;\u0026lt; \u0026#34;分数：\u0026#34; \u0026lt;\u0026lt; s2.score \u0026lt;\u0026lt; endl; 22 23 s3.Name = \u0026#34;bob\u0026#34;;//在定义结构体时已经声明了s3 24 s3.age = 19; 25 s3.score = 87; 26 cout \u0026lt;\u0026lt; \u0026#34;姓名：\u0026#34; \u0026lt;\u0026lt; s3.Name\u0026lt;\u0026lt; \u0026#34;;\u0026#34; 27 \u0026lt;\u0026lt;\u0026#34;年龄：\u0026#34; \u0026lt;\u0026lt; s3.age \u0026lt;\u0026lt; \u0026#34;; \u0026#34; 28 \u0026lt;\u0026lt; \u0026#34;分数：\u0026#34; \u0026lt;\u0026lt; s3.score \u0026lt;\u0026lt; endl; 29 30 return 0; 31} 结构体数组 1struct Student 2{ 3 string Name; 4 int age; 5 float score; 6}; 7 8int main() 9{ 10 struct Student stuArr[3] = 11 { 12 {\u0026#34;tom\u0026#34;, 15, 88}, 13 {\u0026#34;bob\u0026#34;, 16, 89}, 14 {\u0026#34;mike\u0026#34;, 18, 78} 15 }; 16 17 stuArr[1].score = 92; 18 19 for (int i = 0; i \u0026lt; sizeof(stuArr) / sizeof(stuArr[0]); i++) 20 { 21 cout \u0026lt;\u0026lt; \u0026#34;姓名：\u0026#34; \u0026lt;\u0026lt; stuArr[i].Name\u0026lt;\u0026lt; \u0026#34;;\u0026#34; 22 \u0026lt;\u0026lt;\u0026#34;年龄：\u0026#34; \u0026lt;\u0026lt; stuArr[i].age \u0026lt;\u0026lt; \u0026#34;; \u0026#34; 23 \u0026lt;\u0026lt; \u0026#34;分数：\u0026#34; \u0026lt;\u0026lt; stuArr[i].score \u0026lt;\u0026lt; endl; 24 } 25 26 return 0; 27} 结构体指针 利用操作符 -\u0026gt; 可以通过结构体指针访问结构体属性 1struct Student 2{ 3 string Name; 4 int age; 5 float score; 6}; 7 8int main() 9{ 10 struct Student s1 = {\u0026#34;tom\u0026#34;, 21, 89}; 11 12 struct Student * p = \u0026amp;s1; 13 14 cout \u0026lt;\u0026lt; \u0026#34;姓名：\u0026#34; \u0026lt;\u0026lt; p-\u0026gt;Name\u0026lt;\u0026lt; \u0026#34;; \u0026#34; 15 \u0026lt;\u0026lt;\u0026#34;年龄：\u0026#34; \u0026lt;\u0026lt; p-\u0026gt;age \u0026lt;\u0026lt; \u0026#34;; \u0026#34; 16 \u0026lt;\u0026lt; \u0026#34;分数：\u0026#34; \u0026lt;\u0026lt; p-\u0026gt;score \u0026lt;\u0026lt; endl; 17 18 return 0; 19} 结构体嵌套 1struct Student 2{ 3 string Name; 4 int age; 5 float score; 6}; 7 8struct teacher 9{ 10 string Name; 11 int age; 12 struct Student stuArr[3]; 13}; 14 15int main() 16{ 17 struct teacher t1 = 18 { 19 \u0026#34;tim\u0026#34;, 20 26, 21 { 22 {\u0026#34;tom\u0026#34;, 15, 88}, 23 {\u0026#34;bob\u0026#34;, 16, 89}, 24 {\u0026#34;mike\u0026#34;, 18, 78} 25 } 26 27 }; 28 29 cout \u0026lt;\u0026lt; \u0026#34;教师姓名：\u0026#34; \u0026lt;\u0026lt; t1.Name \u0026lt;\u0026lt; \u0026#34;; \u0026#34; 30 \u0026lt;\u0026lt; \u0026#34;教师年龄：\u0026#34; \u0026lt;\u0026lt; t1.age \u0026lt;\u0026lt; \u0026#34;; \u0026#34; \u0026lt;\u0026lt; endl; 31 32 cout \u0026lt;\u0026lt; \u0026#34;教的学生：\u0026#34; \u0026lt;\u0026lt; endl; 33 for (int i = 0; i \u0026lt; sizeof(t1.stuArr) / sizeof(t1.stuArr[0]); i++) 34 { 35 cout \u0026lt;\u0026lt; \u0026#34;姓名：\u0026#34; \u0026lt;\u0026lt; t1.stuArr[i].Name\u0026lt;\u0026lt; \u0026#34;; \u0026#34; 36 \u0026lt;\u0026lt;\u0026#34;年龄：\u0026#34; \u0026lt;\u0026lt; t1.stuArr[i].age \u0026lt;\u0026lt; \u0026#34;; \u0026#34; 37 \u0026lt;\u0026lt; \u0026#34;分数：\u0026#34; \u0026lt;\u0026lt; t1.stuArr[i].score \u0026lt;\u0026lt; endl; 38 } 39 40 return 0; 41} 结构体做函数参数 传递方式有两种：\n值传递 地址传递 1struct Student 2{ 3 string Name; 4 int age; 5 float score; 6}; 7 8//值传递 9void prtStu01(Student s) 10{ 11 s.age = 22; 12 cout \u0026lt;\u0026lt; \u0026#34;通过值传递prtStu01()中的s：\u0026#34; \u0026lt;\u0026lt; endl; 13 cout \u0026lt;\u0026lt; \u0026#34;姓名：\u0026#34; \u0026lt;\u0026lt; s.Name\u0026lt;\u0026lt; \u0026#34;; \u0026#34; 14 \u0026lt;\u0026lt;\u0026#34;年龄：\u0026#34; \u0026lt;\u0026lt; s.age \u0026lt;\u0026lt; \u0026#34;; \u0026#34; 15 \u0026lt;\u0026lt; \u0026#34;分数：\u0026#34; \u0026lt;\u0026lt; s.score \u0026lt;\u0026lt; endl; 16} 17 18//地址传递 19void prtStu02(Student * s) 20{ 21 s-\u0026gt;age = 22; 22 cout \u0026lt;\u0026lt; \u0026#34;通过地址传递prtStu02()中的s：\u0026#34; \u0026lt;\u0026lt; endl; 23 cout \u0026lt;\u0026lt; \u0026#34;姓名：\u0026#34; \u0026lt;\u0026lt; s-\u0026gt;Name\u0026lt;\u0026lt; \u0026#34;; \u0026#34; 24 \u0026lt;\u0026lt;\u0026#34;年龄：\u0026#34; \u0026lt;\u0026lt; s-\u0026gt;age \u0026lt;\u0026lt; \u0026#34;; \u0026#34; 25 \u0026lt;\u0026lt; \u0026#34;分数：\u0026#34; \u0026lt;\u0026lt; s-\u0026gt;score \u0026lt;\u0026lt; endl; 26} 27 28int main() 29{ 30 struct Student s = {\u0026#34;tom\u0026#34;, 21, 89}; 31 32 prtStu01(s); 33 cout \u0026lt;\u0026lt; \u0026#34;main中的s：\u0026#34; \u0026lt;\u0026lt; endl; 34 cout \u0026lt;\u0026lt; \u0026#34;姓名：\u0026#34; \u0026lt;\u0026lt; s.Name\u0026lt;\u0026lt; \u0026#34;; \u0026#34; 35 \u0026lt;\u0026lt;\u0026#34;年龄：\u0026#34; \u0026lt;\u0026lt; s.age \u0026lt;\u0026lt; \u0026#34;; \u0026#34; 36 \u0026lt;\u0026lt; \u0026#34;分数：\u0026#34; \u0026lt;\u0026lt; s.score \u0026lt;\u0026lt; endl; 37 38 prtStu02(\u0026amp;s); 39 cout \u0026lt;\u0026lt; \u0026#34;main中的s：\u0026#34; \u0026lt;\u0026lt; endl; 40 cout \u0026lt;\u0026lt; \u0026#34;姓名：\u0026#34; \u0026lt;\u0026lt; s.Name\u0026lt;\u0026lt; \u0026#34;; \u0026#34; 41 \u0026lt;\u0026lt;\u0026#34;年龄：\u0026#34; \u0026lt;\u0026lt; s.age \u0026lt;\u0026lt; \u0026#34;; \u0026#34; 42 \u0026lt;\u0026lt; \u0026#34;分数：\u0026#34; \u0026lt;\u0026lt; s.score \u0026lt;\u0026lt; endl; 43 44 return 0; 45} 结构体中使用const防止误操作 1struct Student 2{ 3 string Name; 4 int age; 5 float score; 6}; 7 8//在参数类型前加const修饰表明该函数只对参数有读权限，不能修改参数的值 9void prtStu(const Student * s) 10{ 11 s-\u0026gt;age = 22;//该操作会报错 12 cout \u0026lt;\u0026lt; \u0026#34;通过地址传递prtStu()中的s：\u0026#34; \u0026lt;\u0026lt; endl; 13 cout \u0026lt;\u0026lt; \u0026#34;姓名：\u0026#34; \u0026lt;\u0026lt; s-\u0026gt;Name\u0026lt;\u0026lt; \u0026#34;; \u0026#34; 14 \u0026lt;\u0026lt;\u0026#34;年龄：\u0026#34; \u0026lt;\u0026lt; s-\u0026gt;age \u0026lt;\u0026lt; \u0026#34;; \u0026#34; 15 \u0026lt;\u0026lt; \u0026#34;分数：\u0026#34; \u0026lt;\u0026lt; s-\u0026gt;score \u0026lt;\u0026lt; endl; 16} 17 18int main() 19{ 20 struct Student s = {\u0026#34;tom\u0026#34;, 21, 89}; 21 22 prtStu(\u0026amp;s); 23 24 cout \u0026lt;\u0026lt; \u0026#34;main中的s：\u0026#34; \u0026lt;\u0026lt; endl; 25 cout \u0026lt;\u0026lt; \u0026#34;姓名：\u0026#34; \u0026lt;\u0026lt; s.Name\u0026lt;\u0026lt; \u0026#34;; \u0026#34; 26 \u0026lt;\u0026lt;\u0026#34;年龄：\u0026#34; \u0026lt;\u0026lt; s.age \u0026lt;\u0026lt; \u0026#34;; \u0026#34; 27 \u0026lt;\u0026lt; \u0026#34;分数：\u0026#34; \u0026lt;\u0026lt; s.score \u0026lt;\u0026lt; endl; 28 29 return 0; 30} ","date":"2024-03-05T22:29:24+08:00","image":"https://chaihaojian.github.io/post/c_plus_note/chapter1_%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/cover_hudb412b59d0d815ead8ba404fe2018587_757370_120x120_fill_q75_box_smart1.JPG","permalink":"https://chaihaojian.github.io/post/c_plus_note/chapter1_%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/","title":"C++基础语法"},{"content":"走进JavaScript JS从上到下顺序执行 1\u0026lt;!DOCTYPE html\u0026gt; 2\u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; 3\u0026lt;head\u0026gt; 4 \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; 5 \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; 6 \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; 7 \u0026lt;script\u0026gt; 8 alert(3); 9 \u0026lt;/script\u0026gt; 10\u0026lt;/head\u0026gt; 11\u0026lt;body\u0026gt; 12 \u0026lt;h1\u0026gt;aaaaaaa\u0026lt;/h1\u0026gt; 13\u0026lt;/body\u0026gt; 14\u0026lt;/html\u0026gt; 1\u0026lt;!DOCTYPE html\u0026gt; 2\u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; 3\u0026lt;head\u0026gt; 4 \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; 5 \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; 6 \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; 7\u0026lt;/head\u0026gt; 8\u0026lt;body\u0026gt; 9 \u0026lt;h1\u0026gt;aaaaaaa\u0026lt;/h1\u0026gt; 10 \u0026lt;script\u0026gt; 11 alert(3); 12 \u0026lt;/script\u0026gt; 13\u0026lt;/body\u0026gt; 14\u0026lt;/html\u0026gt; 两种写法的页面效果不同 将js放在前面时，后续内容需要等当前js执行结束再加载，因此一般将js放在页面的最后\n注释 单行注释：//\n多行注释：/*\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;*/\n执行符 js每行结束后必须加分号 ；\n变量声明 1var a = \u0026#34;abcdef\u0026#34;; 2 3var a 4a = \u0026#34;abcdef\u0026#34; 5 6var a = \u0026#34;hello\u0026#34;, age = 18, url = \u0026#34;chai.com\u0026#34;; 7 8var a = b = c = \u0026#34;hello\u0026#34;; 变量提升 在浏览器执行代码前，解析器会先分析代码：\n1var web = \u0026#34;hello\u0026#34;; 2console.log(web); 3var class = \u0026#34;world\u0026#34; 上述代码在执行时会直接报错，因为解析器在执行代码前分析时发现了问题；\n1console.log(web); 2var web = \u0026#34;hello.com\u0026#34;; 3 4//上述代码相当于 5console.log(web); 6var web ; 7web = \u0026#34;hello.com\u0026#34;; 8 9//变量提升 10var web ; 11console.log(web); 12web = \u0026#34;hello.com\u0026#34;; 解析器在分析时，会将变量声明的语句提升，因此执行时会输出undefined；\n1function hd() { 2 if(false) { 3 var web = \u0026#34;hello.com\u0026#34;; 4 } 5 console.log(web); 6} 7hd(); 8 9//变量提升 10function hd() { 11 var web; 12 if(false) { 13 web = \u0026#34;hello.com\u0026#34;; 14 } 15 console.log(web); 16} 17hd(); 使用 let 或 const 声明变量 1console.log(web); 2let web = \u0026#34;hello.com\u0026#34;; 1let web = \u0026#34;hello.com\u0026#34;; 2console.log(web); 使用let声明的变量，必须要先声明，在使用；上述代码的第一种情况会产生临时性死区TDZ；\n块作用域与全局污染 全局污染 1function show() { 2 web = \u0026#34;hello.com\u0026#34;; 3 console.log(web); 4}; 5show(); 6console.log(web); 上述代码中web并没有通过var，let，const声明，但仍可以使用；然而web应该只在show()函数中被使用，但此时在函数外也能使用该变量，这就造成了全局污染。\n使用严格模式 1\u0026#34;use strict\u0026#34; 2function show() { 3 web = \u0026#34;hello.com\u0026#34;; 4 console.log(web); 5}; 6show(); 7console.log(web); 1\u0026#34;use strict\u0026#34; 2function show() { 3 let web = \u0026#34;hello.com\u0026#34;; 4 console.log(web); 5}; 6show(); 7console.log(web); 在js代码中添加\u0026quot;use strict\u0026quot;语句表明使用严格模式，要求变量必须先声明再使用。\n块作用域 var声明的变量只有函数作用域和全局作用域：\n1var i = 99; 2 3for (var i = 0; i \u0026lt; 5; i++) { 4 console.log(\u0026#34;循环内的i：\u0026#34;,i); 5}; 6console.log(\u0026#34;循环外的i：\u0026#34;, i); for循环内声明的i影响到了for循环外的i，造成了污染；\n1var i = 99; 2for (let i = 0; i \u0026lt; 5; i++) { 3 console.log(\u0026#34;循环内的i：\u0026#34;,i); 4}; 5console.log(\u0026#34;循环外的i：\u0026#34;, i); 6 7let i = 99; 8for (let i = 0; i \u0026lt; 5; i++) { 9 console.log(\u0026#34;循环内的i：\u0026#34;,i); 10}; 11console.log(\u0026#34;循环外的i：\u0026#34;, i); let声明的变量拥有块作用域，因此for循环内的i不会影响到for循环外的i。\n对于var拥有函数作用域的进一步解释 1(function(){ 2 var $ = (window.$ = {}); 3 $.web = \u0026#34;hello.com\u0026#34;; 4 var url = \u0026#34;nihao.com\u0026#34;; 5}.bind(window)());//这是一个立即执行函数 6 7console.log(url); 在上述代码中，用var声明的变量$被定义在一个立即执行函数中，由于var拥有函数作用域，因此在这个立即执行函数外无法访问到$；通过在该立即执行函数内声明getUrl()和get$()子函数，可以将在该立即执行函数中的声明的变量暴露给外界使用。\n1(function(){ 2 var $ = (window.$ = {}); 3 $.web = \u0026#34;hello.com\u0026#34;; 4 var url = \u0026#34;nihao.com\u0026#34;; 5 $.getUrl = function() { 6 return url; 7 }; 8 $.get$ = function() { 9 return $; 10 }; 11}.bind(window)()); 12 13console.log($.getUrl()); 14console.log($.get$()); 由于let拥有块作用域，因此上述代码又可以改写为：\n1{ 2 let $ = (window.$ = {}); 3 $.web = \u0026#34;hello.com\u0026#34;; 4 let url = \u0026#34;nihao.com\u0026#34;; 5 }; 6}//变量$, url都在一个用{}包起来的代码块中 7 8console.log(url); 1{ 2 let $ = (window.$ = {}); 3 $.web = \u0026#34;hello.com\u0026#34;; 4 let url = \u0026#34;nihao.com\u0026#34;; 5 $.getUrl = function() { 6 return url; 7 }; 8 $.get$ = function() { 9 return $; 10 }; 11} 12 13console.log($.getUrl()); 14console.log($.get$()); const常量声明 const也拥有块作用域，在同一作用域里，const声明的常量无法更改:\n1const URL = \u0026#34;hello.com\u0026#34;; 2{ 3 const URL = \u0026#34;world.com\u0026#34; 4 console.log(URL); 5} 6console.log(URL); 1const URL = \u0026#34;hello.com\u0026#34;; 2URL = \u0026#34;world.com\u0026#34;; 3console.log(URL); 1const URL = \u0026#34;hello.com\u0026#34;; 2function show() { 3 const URL = \u0026#34;world.com\u0026#34;; 4 console.log(URL); 5} 6show(); 7console.log(URL); 当const声明的常量是引用类型时，可以进行更改：\n1const CONFIG = { 2 URL: \u0026#34;hello.com\u0026#34; 3}; 4console.log(CONFIG); 5CONFIG.URL = \u0026#34;world.com\u0026#34;; 6console.log(CONFIG); 对造成上述结果的分析：\n使用const声明一个基本类型的常量时，当改变该常量的值时，会造成该常量引用的地址发生改变，在上述代码中，\u0026ldquo;hello.com\u0026quot;和\u0026quot;world.com\u0026quot;在计算机中存储的地址不同，因此再次赋值会导致URL所引用的地址发生改变，因此报错；但是声明的是一个引用类型的常量时，由于更改CONFIG.URL并不会导致CONFIG所引用的地址发生改变，因此不会报错。\n对var与let的进一步说明 1var web0 = \u0026#34;hello.com\u0026#34;; 2console.log(window.web0); 3 4let web1 = \u0026#34;world.com\u0026#34;; 5console.log(window.web1); 6console.log(web1); 由var声明的变量会保存到全局对象window中，而let不会；且在同一作用域下，var出现重复声明不会报错，但let和const会报错。\n变量冻结 使用Object.freeze()可以使由const声明的引用类型的常量不发生改变，在严格模式下，对被Object.freeze()冻结的变量进行修改会报错。\n1 \u0026#34;use strict\u0026#34; 2const CONFIG = { 3 URL: \u0026#34;hello.com\u0026#34; 4}; 5console.log(CONFIG); 6Object.freeze(CONFIG); 7CONFIG.URL = \u0026#34;world.com\u0026#34;; 8console.log(CONFIG); \u0026ldquo;use strict\u0026rdquo;\n传值与传址 1//传值 2let a = 1; 3let b = a; 4console.log(a, b); 5b = 2; 6console.log(a, b); 7 8//传址 9let c = {url: \u0026#34;hello.com\u0026#34;}; 10let d = c; 11console.log(c, d); 12d.url = \u0026#34;world.com\u0026#34;; 13console.log(c, d); null与undefined 两者都表示没有值\nnull：当声明了一个引用类型变量，但没有赋值时，此时该引用类型变量为null\nundefin：当声明了一个基本类型变量，但没有赋值时，此时该基本类型变量为null\n在js函数中，当传递的参数，或着返回值没有值时，默认都是undefined\n1function show(name){ 2 console.log(name); 3}; 4console.log(show()); use strict 严格模式 严格模式的作用域包含当前作用域及其子作用域：\n1function show(){ 2 \u0026#34;use strict\u0026#34; 3 web = \u0026#34;hello.com\u0026#34;; 4 console.log(web); 5}; 6function hd(){ 7 site = \u0026#34;world.com\u0026#34;; 8 console.log(site); 9}; 10hd(); 11show(); 1function show(){ 2 web = \u0026#34;hello.com\u0026#34;; 3 console.log(web); 4 function handle(){ 5 \u0026#34;use strict\u0026#34; 6 url = \u0026#34;nihao.com\u0026#34;; 7 console.log(url); 8 }; 9 handle(); 10}; 11function hd(){ 12 site = \u0026#34;world.com\u0026#34;; 13 console.log(site); 14}; 15hd(); 16show(); 推荐在编写js代码时添加严格模式，使代码在更多的环境中运行。\n","date":"2024-02-27T13:42:01+08:00","image":"https://chaihaojian.github.io/post/javascript_note/%E8%B5%B0%E8%BF%9Bjavascript/cover_hub8b395643672f7ca335685551bcb8ad3_728006_120x120_fill_q75_box_smart1.JPG","permalink":"https://chaihaojian.github.io/post/javascript_note/%E8%B5%B0%E8%BF%9Bjavascript/","title":"走进JavaScript"},{"content":"第一章 计算机系统概述 计算机通过电信号传递数据 低电平表示二进制0\n高电平表示二进制1\n计算机系统 包括硬件和软件两大方面。\n计算机硬件的发展 第一代：第一台电子数字计算机：ENIAC（1946） 逻辑元件：电子管；\n第二代：晶体管 体积、功耗降低 出现面向过程的程序设计语言：FORTRAN 有了操作系统雏形；\n第三代： 中小规模集成电路 计算机主要用于科学计算等专业用途 高级语言迅速发展 开始有了分时操作系统；\n第四代：大规模、超大规模集成电路 开始出现微处理器、微型计算机 个人计算机（PC）萌芽 ；\n微型计算机的发展以微处理器技术为标志；\n机器字长：计算机一次整数运算所能处理的二进制位数；\n摩尔定律：集成电路上可容纳的晶体管数目，约每隔18个月便会增加一倍，整体性能也将提升一倍；该定律揭示了信息技术进步的速度。\n计算机软件的发展 机器语言 \u0026ndash;\u0026gt; 汇编语言 \u0026ndash;\u0026gt; 高级语言\n计算机的发展趋势（两极分化） 1.微型计算机向更微型化、网络化、高性能、多用途方向发展；\n2.巨型机向更巨型化、超高速、并行处理、智能化方向发展。\n计算机硬件的基本组成 早期冯诺依曼机的结构 ENIAC：需要手动接线来控制计算，需要人工干预，影响计算速度\n冯诺依曼提出“存储程序”的概念：\n将指令以二进制代码的形式事先输入计算机的主存储器（内存），然后按其在存储器中的首地址执行程序的第一条指令，以后就按该程序规定的顺序执行其他指令，直至程序结束。\n第一台采用冯诺依曼结构的计算机：EDVAC（Electronic Discrete Variable Automatic Computer）。\n输入设备：将信息转换成机器能识别的形式；\n存储器：存放数据和程序；\n运算器：进行算术运算和逻辑运算；\n控制器：指挥程序运行；\n输出设备：将结果转换成人们熟悉的形式；\n在计算机系统中，软件和硬件在逻辑上是等效的；\n冯诺依曼计算机的特点：\n1.计算机由五大部件组成；\n2.指令和数据以同等地位存于存储器，可按地址寻访；\n3.指令和数据用二进制表示；\n4.指令有操作码和地址码组成；\n5.存储程序；\n6.以运算器为中心：输入/输出设备与存储器之间的数据传送通过运算器完成；\n现代计算机的结构 以存储器为中心\nCPU = 运算器 + 控制器\n计算机内各个硬件的工作原理 主存储器的基本组成 存储体：数据在存储体内按地址存储，存储体里有一个一个的存储单元，每个存储单元存放一串二进制代码；每个存储单元对应一个地址；\n存储字：存储单元中二进制代码的组合叫做存储字(word)；\n存储字长：存储单元中能够存放的二进制代码位数叫做存储字长，通常为8bit的整数倍；\n存储元：存储二进制的电子元件，每个存储元可存1bit；\nMAR：指明要访问的数据的地址，MAR位数反映存储单元的个数；\nMDR：存放存储单元中取出的数据/需要保存进存储单元的数据，因此MDR字长=存储字长；\n注：MAR，MDR在逻辑上属于主存的一部分，但现代计算机通常把MAR，MDR集成在CPU内。\n运算器的基本组成 运算器：用于实现算术运算（如：加减乘除）、逻辑运算（如：与或非）\nACC：累加器，用于存放操作数，或运算结果；\nMQ：乘商寄存器，在乘、除运算时，用于存放操作数或运算结果；\nX：通用的操作数寄存器，用于存放操作数；\nALU：算术逻辑单元，通过内部复杂的电路实现算术运算、逻辑运算；\n控制器的基本组成 CU：控制单元，分析指令，给出控制信号；\nIR：指令寄存器，存放当前执行的指令；\nPC：程序计数器，存放下一条指令的地址，有自动加1功能；\n计算机系统的层次结构 计算机的性能指标 存储器的性能指标 MAR位数反映存储单元的个数（最多支持多少个）；\nMDR位数 = 存储字长 = 每个存储单元的大小；\n总容量 = 存储单元个数 * 存储字长 bit\n​\t= 存储单元个数 * 存储字长 / 8 Byte\n1 GB = 1024 MB = 1024 * 1024 KB = 1024 * 1024 * 1024 Byte\n1 Byte = 8 bit\nCPU的性能指标 CPU时钟周期：每个脉冲信号的时间，单位：微秒、纳秒；\nCPU主频（时钟频率）= 1 / CPU时钟周期：CPU内数字脉冲信号振荡的频率，单位：Hz；\nCPI(Clock cycle Per Instruction)：执行一条指令所需的时钟周期数；不同的指令，CPI不同；相同的指令，CPI也可能有变化；\n执行一条指令的耗时 = CPI * CPU时钟周期；\nCPU执行时间（整个程序的耗时）= CPU时钟周期数 / 主频 = （指令条数 * CPI）/ 主频；\nIPS(Instruction Per Second) = 主频 / 平均CPI：每秒执行多少条指令；\nFLOPS(Floating-point Operations Per Seconds)：每秒执行所少次浮点运算；\n系统整体性能指标 数据通路带宽：数据总线一次所能并行传送信息的位数（各硬件部件通过数据总线传输数据）；\n吞吐量：系统在单位时间内处理请求的数量；\n响应时间：从用户向计算机发送一个请求，到系统对该请求作出响应并获得它所需要的结果的等待时间；\n","date":"2024-02-27T10:13:54+08:00","image":"https://chaihaojian.github.io/post/computer_composition_principles/chapter_1/cover_huc74df9617fcc19736cc959ce67738010_601682_120x120_fill_q75_box_smart1.JPG","permalink":"https://chaihaojian.github.io/post/computer_composition_principles/chapter_1/","title":"计算机系统概述"},{"content":"二叉搜索树 如果左子节点存在，则左子节点的值小于当前节点的值； 如果右子节点存在，则右子节点的值大于当前节点的值。 对于二叉搜索树中的一个节点，可以根据上述性质确定由根节点到该节点的路径。 1func getPath(root, target *TreeNode)(path []*TreeNode){ 2​\tnode := root 3​\tfor node != target { 4​\tpath = append(path, node) 5​\tif node.Val \u0026gt; target.Val { 6​\tnode = node.Left 7​\t}else { 8​\tnode = node.Right 9​\t} 10​\t} 11​\tpath = append(path, node) 12​\treturn 13} ","date":"2024-02-25T22:01:10+08:00","image":"https://chaihaojian.github.io/post/data_struct/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/cover_hua5b35af258670c5afa4b660f73f4647d_606953_120x120_fill_q75_box_smart1.JPG","permalink":"https://chaihaojian.github.io/post/data_struct/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/","title":"二叉搜索树"}]