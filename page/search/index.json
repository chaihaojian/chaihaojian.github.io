[{"content":"运算符与流程控制 一元运算符的前置与后置操作(++n与n++的区别) 两者在不参与其他运算时结果相同，都是n自增；\n1let a = 1; 2let b = 1; 3++a; 4console.log(a); 5b++; 6console.log(b); 在参与其他运算时，++n先自增，再进行运算；n++先进行运算，再自增。\n1let n = 1; 2let m = 1; 3let f = 2; 4let d = f + ++n;//n先自增，然后运算f + n 5console.log(d); 6console.log(n); 7let e = f + m++;//先运算f + n, 然后n自增 8console.log(e); 9console.log(m); 比较运算符 == 与 === a == b，如果a, b不是相同类型的变量，js会自动将两个变量转换成相同类型再进行比较；a === b 则会直接进行比较。\n1let a = 1; 2let b = \u0026#34;1\u0026#34;; 3console.log(a == b); 4console.log(a \u0026gt;= b); 5console.log(a === b); 逻辑运算符 逻辑与： \u0026amp;\u0026amp;\n逻辑或： ||\n逻辑非： !\n短路运算 1可以表示true；0可以表示false；\n1let a = 1, b = 0; 2console.log(a == true) 3console.log(a == false) 4console.log(b == true) 5console.log(b == false) 在逻辑或进行判断时，如 （a || b）：若a为真，则不再判断b，直接返回真；若a为假，则继续判断b的真假；\n短路运算在赋值中的妙用 1let a = 3; 2let b; 3let c = 4; 4let f = b || a;//b为空，因此将a的值赋给f 5console.log(f); 6let p = c || a;//c不为空，因此不需要判断a，直接将c的值赋给p 7console.log(p); 流程控制 if else 三元表达式 1let h = true?2:5; 2console.log(h); 3let l = false?2:5; 4console.log(l); switch 1let name = \u0026#34;hi\u0026#34; 2switch(name){ 3 case \u0026#34;hello\u0026#34;: 4 console.log(\u0026#34;hello\u0026#34;); 5 break; 6 case \u0026#34;hi\u0026#34;: 7 console.log(\u0026#34;hi\u0026#34;); 8 break; 9 default: 10 console.log(\u0026#34;default\u0026#34;); 11}; while 循环控制 1function genTable(options = {tr: 5, td: 3}){ 2 document.write(`\u0026lt;table border = \u0026#34;1\u0026#34; width=\u0026#34;100%\u0026#34;`); 3 while(options.tr-- != 0){ 4 let td = options.td; 5 document.write(`\u0026lt;tr\u0026gt;`); 6 while(td-- != 0){ 7 document.write(`\u0026lt;td\u0026gt;${td}\u0026lt;/td\u0026gt;`); 8 } 9 document.write(`\u0026lt;/tr\u0026gt;`); 10 } 11 document.write(`\u0026lt;/table\u0026gt;`); 12} 13genTable(); 14document.write(`\u0026lt;br/\u0026gt;`); 15genTable({tr: 3, td: 5}); do while 循环控制 1function genStars(row = 5){ 2 let l = 0; 3 do { 4 let n = 0; 5 do { 6 document.write(\u0026#34;*\u0026#34;); 7 } while (++n \u0026lt;= l); 8 document.write(`\u0026lt;br/\u0026gt;`); 9 } while(++l \u0026lt; row); 10}; 11genStars(); 12document.write(`\u0026lt;br/\u0026gt;`); 13genStars(8); for 循环 1function genStars(row = 5){ 2 for (let i = 1; i \u0026lt;= row; i++){ 3 for (let n = row - i; n \u0026gt; 0; n--){ 4 document.write(`\u0026lt;span style=\u0026#34;color: white\u0026#34;\u0026gt;^\u0026lt;/span\u0026gt;`); 5 } 6 for (let m = i * 2 - 1; m \u0026gt; 0; m--){ 7 document.write(`*`); 8 } 9 document.write(`\u0026lt;br/\u0026gt;`); 10 } 11} 12genStars(); 13document.write(`\u0026lt;br/\u0026gt;`); 14genStars(8); continue 与 break continue：停止当前循环，进行下一次循环；\nbreak：终止当前循环；\n如果需要从子循环直接终止更上一级的循环，需要通过标签：\n1pa: for (let i = 1; i \u0026lt;= 10; i++){ 2 ch: for (let j = 1; j \u0026lt;= 10; j++){ 3 if (j % 2 == 0){ 4 console.log(i, j); 5 } 6 if (i + j \u0026gt; 10){ 7 break pa; 8 }; 9 }; 10}; for-in 与 for-of 1let array = [1, 2, 3, 4]; 2for (let key in array){ 3 console.log(key, array[key]); 4}; 1let array = [1, 2, 3, 4]; 2for (const value of array) { 3 console.log(value); 4}; ","date":"2024-03-06T11:44:29+08:00","permalink":"https://chaihaojian.github.io/post/javascript_note/%E8%BF%90%E7%AE%97%E7%AC%A6%E4%B8%8E%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/","title":"运算符与流程控制"},{"content":"C++基础语法 变量 创建变量 1//数据类型 变量名 = 变量初始值; 2int a = 10; 常量 常量的作用 用于记录程序中不可更改的数据\nC++定义常量的两种方式 1.#define 宏常量 1#include \u0026lt;iostream\u0026gt; 2using namespace std; 3 4#define Day 7 5 6int main() 7{ 8 cout \u0026lt;\u0026lt; Day \u0026lt;\u0026lt; endl; 9 10 return 0; 11} 2.const修饰的变量 1#include \u0026lt;iostream\u0026gt; 2using namespace std; 3 4int main() 5{ 6 const int month = 12; 7 8 cout \u0026lt;\u0026lt; month \u0026lt;\u0026lt; endl; 9 10 return 0; 11} 关键字 关键字是C++中预先保留的单词（标识符），在定义变量或常量时，不要用关键字，否则会产生歧义。\n标识符命名规则 标识符不能是关键字；\n标识符只能由字母、数字、下划线组成；\n第一个字符必须为字母或下划线；\n标识符中的字母区分大小写；\n数据类型（给变量或常量分配合适的内存空间） C++规定在创建一个变量或者常量时，必须要指定相应的数据类型，否则无法给变量分配内存。\nsizeof 关键字 利用sizeof关键字可以统计数据类型所占内存大小：sizeof(数据类型 / 变量)\n1#include \u0026lt;iostream\u0026gt; 2using namespace std; 3 4int main() 5{ 6 short num1 = 10; 7 cout \u0026lt;\u0026lt; \u0026#34;space occupied by num1:\u0026#34; \u0026lt;\u0026lt; sizeof(num1) \u0026lt;\u0026lt; endl; 8 //space occupied by num1:2 9 10 int num2 = 10; 11 cout \u0026lt;\u0026lt; \u0026#34;space occupied by int:\u0026#34; \u0026lt;\u0026lt; sizeof(int) \u0026lt;\u0026lt; endl; 12 //space occupied by int:4 13 14 return 0; 15} 整型 C++中能够表示整型的类型有以下几种方式，区别在于所占内存空间不同：\n数据类型 占用空间 取值范围 short（短整型） 2 字节 （-2^15 - 2^15-1） Int（整型） 4 字节 （-2^31 - 2^31-1） long（长整型） Windows为 4 字节，Linux为 4 字节（32 位），8字节（64 位） （-2^31 - 2^31-1） long long（长长整型） 8 字节 （-2^63 - 2^63-1） 当需要保存的值超出当前数据类型的取值范围时，c++会提示警告超出内存，但不会报错，该变量值会变为在该数据类型的取值范围内最接近该变量值的值：\n1#include \u0026lt;iostream\u0026gt; 2using namespace std; 3 4int main() 5{ 6 //短整型 7 short num1 = 10; 8 //整型 9 int num2 = 10; 10 //长整型 11 long num3 = 10; 12 //长长整型 13 long long num4 = 10; 14 15 cout \u0026lt;\u0026lt; \u0026#34;num1:\u0026#34; \u0026lt;\u0026lt; num1 \u0026lt;\u0026lt; endl; 16 cout \u0026lt;\u0026lt; \u0026#34;num2:\u0026#34; \u0026lt;\u0026lt; num2 \u0026lt;\u0026lt; endl; 17 cout \u0026lt;\u0026lt; \u0026#34;num3:\u0026#34; \u0026lt;\u0026lt; num3 \u0026lt;\u0026lt; endl; 18 cout \u0026lt;\u0026lt; \u0026#34;num4:\u0026#34; \u0026lt;\u0026lt; num4 \u0026lt;\u0026lt; endl; 19 20 num1 = 32768; 21 cout \u0026lt;\u0026lt; \u0026#34;num1:\u0026#34; \u0026lt;\u0026lt; num1 \u0026lt;\u0026lt; endl; 22 23 num1 = -32769; 24 cout \u0026lt;\u0026lt; \u0026#34;num1:\u0026#34; \u0026lt;\u0026lt; num1 \u0026lt;\u0026lt; endl; 25 26 return 0; 27} ","date":"2024-03-05T22:29:24+08:00","permalink":"https://chaihaojian.github.io/post/c_plus_note/chapter1_%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/","title":"C++基础语法"},{"content":"走进JavaScript JS从上到下顺序执行 1\u0026lt;!DOCTYPE html\u0026gt; 2\u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; 3\u0026lt;head\u0026gt; 4 \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; 5 \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; 6 \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; 7 \u0026lt;script\u0026gt; 8 alert(3); 9 \u0026lt;/script\u0026gt; 10\u0026lt;/head\u0026gt; 11\u0026lt;body\u0026gt; 12 \u0026lt;h1\u0026gt;aaaaaaa\u0026lt;/h1\u0026gt; 13\u0026lt;/body\u0026gt; 14\u0026lt;/html\u0026gt; 1\u0026lt;!DOCTYPE html\u0026gt; 2\u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; 3\u0026lt;head\u0026gt; 4 \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; 5 \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; 6 \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; 7\u0026lt;/head\u0026gt; 8\u0026lt;body\u0026gt; 9 \u0026lt;h1\u0026gt;aaaaaaa\u0026lt;/h1\u0026gt; 10 \u0026lt;script\u0026gt; 11 alert(3); 12 \u0026lt;/script\u0026gt; 13\u0026lt;/body\u0026gt; 14\u0026lt;/html\u0026gt; 两种写法的页面效果不同 将js放在前面时，后续内容需要等当前js执行结束再加载，因此一般将js放在页面的最后\n注释 单行注释：//\n多行注释：/*\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;*/\n执行符 js每行结束后必须加分号 ；\n变量声明 1var a = \u0026#34;abcdef\u0026#34;; 2 3var a 4a = \u0026#34;abcdef\u0026#34; 5 6var a = \u0026#34;hello\u0026#34;, age = 18, url = \u0026#34;chai.com\u0026#34;; 7 8var a = b = c = \u0026#34;hello\u0026#34;; 变量提升 在浏览器执行代码前，解析器会先分析代码：\n1var web = \u0026#34;hello\u0026#34;; 2console.log(web); 3var class = \u0026#34;world\u0026#34; 上述代码在执行时会直接报错，因为解析器在执行代码前分析时发现了问题；\n1console.log(web); 2var web = \u0026#34;hello.com\u0026#34;; 3 4//上述代码相当于 5console.log(web); 6var web ; 7web = \u0026#34;hello.com\u0026#34;; 8 9//变量提升 10var web ; 11console.log(web); 12web = \u0026#34;hello.com\u0026#34;; 解析器在分析时，会将变量声明的语句提升，因此执行时会输出undefined；\n1function hd() { 2 if(false) { 3 var web = \u0026#34;hello.com\u0026#34;; 4 } 5 console.log(web); 6} 7hd(); 8 9//变量提升 10function hd() { 11 var web; 12 if(false) { 13 web = \u0026#34;hello.com\u0026#34;; 14 } 15 console.log(web); 16} 17hd(); 使用 let 或 const 声明变量 1console.log(web); 2let web = \u0026#34;hello.com\u0026#34;; 1let web = \u0026#34;hello.com\u0026#34;; 2console.log(web); 使用let声明的变量，必须要先声明，在使用；上述代码的第一种情况会产生临时性死区TDZ；\n块作用域与全局污染 全局污染 1function show() { 2 web = \u0026#34;hello.com\u0026#34;; 3 console.log(web); 4}; 5show(); 6console.log(web); 上述代码中web并没有通过var，let，const声明，但仍可以使用；然而web应该只在show()函数中被使用，但此时在函数外也能使用该变量，这就造成了全局污染。\n使用严格模式 1\u0026#34;use strict\u0026#34; 2function show() { 3 web = \u0026#34;hello.com\u0026#34;; 4 console.log(web); 5}; 6show(); 7console.log(web); 1\u0026#34;use strict\u0026#34; 2function show() { 3 let web = \u0026#34;hello.com\u0026#34;; 4 console.log(web); 5}; 6show(); 7console.log(web); 在js代码中添加\u0026quot;use strict\u0026quot;语句表明使用严格模式，要求变量必须先声明再使用。\n块作用域 var声明的变量只有函数作用域和全局作用域：\n1var i = 99; 2 3for (var i = 0; i \u0026lt; 5; i++) { 4 console.log(\u0026#34;循环内的i：\u0026#34;,i); 5}; 6console.log(\u0026#34;循环外的i：\u0026#34;, i); for循环内声明的i影响到了for循环外的i，造成了污染；\n1var i = 99; 2for (let i = 0; i \u0026lt; 5; i++) { 3 console.log(\u0026#34;循环内的i：\u0026#34;,i); 4}; 5console.log(\u0026#34;循环外的i：\u0026#34;, i); 6 7let i = 99; 8for (let i = 0; i \u0026lt; 5; i++) { 9 console.log(\u0026#34;循环内的i：\u0026#34;,i); 10}; 11console.log(\u0026#34;循环外的i：\u0026#34;, i); let声明的变量拥有块作用域，因此for循环内的i不会影响到for循环外的i。\n对于var拥有函数作用域的进一步解释 1(function(){ 2 var $ = (window.$ = {}); 3 $.web = \u0026#34;hello.com\u0026#34;; 4 var url = \u0026#34;nihao.com\u0026#34;; 5}.bind(window)());//这是一个立即执行函数 6 7console.log(url); 在上述代码中，用var声明的变量$被定义在一个立即执行函数中，由于var拥有函数作用域，因此在这个立即执行函数外无法访问到$；通过在该立即执行函数内声明getUrl()和get$()子函数，可以将在该立即执行函数中的声明的变量暴露给外界使用。\n1(function(){ 2 var $ = (window.$ = {}); 3 $.web = \u0026#34;hello.com\u0026#34;; 4 var url = \u0026#34;nihao.com\u0026#34;; 5 $.getUrl = function() { 6 return url; 7 }; 8 $.get$ = function() { 9 return $; 10 }; 11}.bind(window)()); 12 13console.log($.getUrl()); 14console.log($.get$()); 由于let拥有块作用域，因此上述代码又可以改写为：\n1{ 2 let $ = (window.$ = {}); 3 $.web = \u0026#34;hello.com\u0026#34;; 4 let url = \u0026#34;nihao.com\u0026#34;; 5 }; 6}//变量$, url都在一个用{}包起来的代码块中 7 8console.log(url); 1{ 2 let $ = (window.$ = {}); 3 $.web = \u0026#34;hello.com\u0026#34;; 4 let url = \u0026#34;nihao.com\u0026#34;; 5 $.getUrl = function() { 6 return url; 7 }; 8 $.get$ = function() { 9 return $; 10 }; 11} 12 13console.log($.getUrl()); 14console.log($.get$()); const常量声明 const也拥有块作用域，在同一作用域里，const声明的常量无法更改:\n1const URL = \u0026#34;hello.com\u0026#34;; 2{ 3 const URL = \u0026#34;world.com\u0026#34; 4 console.log(URL); 5} 6console.log(URL); 1const URL = \u0026#34;hello.com\u0026#34;; 2URL = \u0026#34;world.com\u0026#34;; 3console.log(URL); 1const URL = \u0026#34;hello.com\u0026#34;; 2function show() { 3 const URL = \u0026#34;world.com\u0026#34;; 4 console.log(URL); 5} 6show(); 7console.log(URL); 当const声明的常量是引用类型时，可以进行更改：\n1const CONFIG = { 2 URL: \u0026#34;hello.com\u0026#34; 3}; 4console.log(CONFIG); 5CONFIG.URL = \u0026#34;world.com\u0026#34;; 6console.log(CONFIG); 对造成上述结果的分析：\n使用const声明一个基本类型的常量时，当改变该常量的值时，会造成该常量引用的地址发生改变，在上述代码中，\u0026ldquo;hello.com\u0026quot;和\u0026quot;world.com\u0026quot;在计算机中存储的地址不同，因此再次赋值会导致URL所引用的地址发生改变，因此报错；但是声明的是一个引用类型的常量时，由于更改CONFIG.URL并不会导致CONFIG所引用的地址发生改变，因此不会报错。\n对var与let的进一步说明 1var web0 = \u0026#34;hello.com\u0026#34;; 2console.log(window.web0); 3 4let web1 = \u0026#34;world.com\u0026#34;; 5console.log(window.web1); 6console.log(web1); 由var声明的变量会保存到全局对象window中，而let不会；且在同一作用域下，var出现重复声明不会报错，但let和const会报错。\n变量冻结 使用Object.freeze()可以使由const声明的引用类型的常量不发生改变，在严格模式下，对被Object.freeze()冻结的变量进行修改会报错。\n1 \u0026#34;use strict\u0026#34; 2const CONFIG = { 3 URL: \u0026#34;hello.com\u0026#34; 4}; 5console.log(CONFIG); 6Object.freeze(CONFIG); 7CONFIG.URL = \u0026#34;world.com\u0026#34;; 8console.log(CONFIG); \u0026ldquo;use strict\u0026rdquo;\n传值与传址 1//传值 2let a = 1; 3let b = a; 4console.log(a, b); 5b = 2; 6console.log(a, b); 7 8//传址 9let c = {url: \u0026#34;hello.com\u0026#34;}; 10let d = c; 11console.log(c, d); 12d.url = \u0026#34;world.com\u0026#34;; 13console.log(c, d); null与undefined 两者都表示没有值\nnull：当声明了一个引用类型变量，但没有赋值时，此时该引用类型变量为null\nundefin：当声明了一个基本类型变量，但没有赋值时，此时该基本类型变量为null\n在js函数中，当传递的参数，或着返回值没有值时，默认都是undefined\n1function show(name){ 2 console.log(name); 3}; 4console.log(show()); use strict 严格模式 严格模式的作用域包含当前作用域及其子作用域：\n1function show(){ 2 \u0026#34;use strict\u0026#34; 3 web = \u0026#34;hello.com\u0026#34;; 4 console.log(web); 5}; 6function hd(){ 7 site = \u0026#34;world.com\u0026#34;; 8 console.log(site); 9}; 10hd(); 11show(); 1function show(){ 2 web = \u0026#34;hello.com\u0026#34;; 3 console.log(web); 4 function handle(){ 5 \u0026#34;use strict\u0026#34; 6 url = \u0026#34;nihao.com\u0026#34;; 7 console.log(url); 8 }; 9 handle(); 10}; 11function hd(){ 12 site = \u0026#34;world.com\u0026#34;; 13 console.log(site); 14}; 15hd(); 16show(); 推荐在编写js代码时添加严格模式，使代码在更多的环境中运行。\n","date":"2024-02-27T13:42:01+08:00","image":"https://chaihaojian.github.io/post/javascript_note/%E8%B5%B0%E8%BF%9Bjavascript/cover_huf070decc27d1c42dbee75c2bdff912a4_225263_120x120_fill_q75_box_smart1.JPG","permalink":"https://chaihaojian.github.io/post/javascript_note/%E8%B5%B0%E8%BF%9Bjavascript/","title":"走进JavaScript"},{"content":"第一章 计算机系统概述 计算机通过电信号传递数据 低电平表示二进制0\n高电平表示二进制1\n计算机系统 包括硬件和软件两大方面。\n计算机硬件的发展 第一代：第一台电子数字计算机：ENIAC（1946） 逻辑元件：电子管；\n第二代：晶体管 体积、功耗降低 出现面向过程的程序设计语言：FORTRAN 有了操作系统雏形；\n第三代： 中小规模集成电路 计算机主要用于科学计算等专业用途 高级语言迅速发展 开始有了分时操作系统；\n第四代：大规模、超大规模集成电路 开始出现微处理器、微型计算机 个人计算机（PC）萌芽 ；\n微型计算机的发展以微处理器技术为标志；\n机器字长：计算机一次整数运算所能处理的二进制位数；\n摩尔定律：集成电路上可容纳的晶体管数目，约每隔18个月便会增加一倍，整体性能也将提升一倍；该定律揭示了信息技术进步的速度。\n计算机软件的发展 机器语言 \u0026ndash;\u0026gt; 汇编语言 \u0026ndash;\u0026gt; 高级语言\n计算机的发展趋势（两极分化） 1.微型计算机向更微型化、网络化、高性能、多用途方向发展；\n2.巨型机向更巨型化、超高速、并行处理、智能化方向发展。\n计算机硬件的基本组成 早期冯诺依曼机的结构 ENIAC：需要手动接线来控制计算，需要人工干预，影响计算速度\n冯诺依曼提出“存储程序”的概念：\n将指令以二进制代码的形式事先输入计算机的主存储器（内存），然后按其在存储器中的首地址执行程序的第一条指令，以后就按该程序规定的顺序执行其他指令，直至程序结束。\n第一台采用冯诺依曼结构的计算机：EDVAC（Electronic Discrete Variable Automatic Computer）。\n输入设备：将信息转换成机器能识别的形式；\n存储器：存放数据和程序；\n运算器：进行算术运算和逻辑运算；\n控制器：指挥程序运行；\n输出设备：将结果转换成人们熟悉的形式；\n在计算机系统中，软件和硬件在逻辑上是等效的；\n冯诺依曼计算机的特点：\n1.计算机由五大部件组成；\n2.指令和数据以同等地位存于存储器，可按地址寻访；\n3.指令和数据用二进制表示；\n4.指令有操作码和地址码组成；\n5.存储程序；\n6.以运算器为中心：输入/输出设备与存储器之间的数据传送通过运算器完成；\n现代计算机的结构 以存储器为中心\nCPU = 运算器 + 控制器\n计算机内各个硬件的工作原理 主存储器的基本组成 存储体：数据在存储体内按地址存储，存储体里有一个一个的存储单元，每个存储单元存放一串二进制代码；每个存储单元对应一个地址；\n存储字：存储单元中二进制代码的组合叫做存储字(word)；\n存储字长：存储单元中能够存放的二进制代码位数叫做存储字长，通常为8bit的整数倍；\n存储元：存储二进制的电子元件，每个存储元可存1bit；\nMAR：指明要访问的数据的地址，MAR位数反映存储单元的个数；\nMDR：存放存储单元中取出的数据/需要保存进存储单元的数据，因此MDR字长=存储字长；\n注：MAR，MDR在逻辑上属于主存的一部分，但现代计算机通常把MAR，MDR集成在CPU内。\n运算器的基本组成 运算器：用于实现算术运算（如：加减乘除）、逻辑运算（如：与或非）\nACC：累加器，用于存放操作数，或运算结果；\nMQ：乘商寄存器，在乘、除运算时，用于存放操作数或运算结果；\nX：通用的操作数寄存器，用于存放操作数；\nALU：算术逻辑单元，通过内部复杂的电路实现算术运算、逻辑运算；\n控制器的基本组成 CU：控制单元，分析指令，给出控制信号；\nIR：指令寄存器，存放当前执行的指令；\nPC：程序计数器，存放下一条指令的地址，有自动加1功能；\n计算机系统的层次结构 计算机的性能指标 存储器的性能指标 MAR位数反映存储单元的个数（最多支持多少个）；\nMDR位数 = 存储字长 = 每个存储单元的大小；\n总容量 = 存储单元个数 * 存储字长 bit\n​\t= 存储单元个数 * 存储字长 / 8 Byte\n1 GB = 1024 MB = 1024 * 1024 KB = 1024 * 1024 * 1024 Byte\n1 Byte = 8 bit\nCPU的性能指标 CPU时钟周期：每个脉冲信号的时间，单位：微秒、纳秒；\nCPU主频（时钟频率）= 1 / CPU时钟周期：CPU内数字脉冲信号振荡的频率，单位：Hz；\nCPI(Clock cycle Per Instruction)：执行一条指令所需的时钟周期数；不同的指令，CPI不同；相同的指令，CPI也可能有变化；\n执行一条指令的耗时 = CPI * CPU时钟周期；\nCPU执行时间（整个程序的耗时）= CPU时钟周期数 / 主频 = （指令条数 * CPI）/ 主频；\nIPS(Instruction Per Second) = 主频 / 平均CPI：每秒执行多少条指令；\nFLOPS(Floating-point Operations Per Seconds)：每秒执行所少次浮点运算；\n系统整体性能指标 数据通路带宽：数据总线一次所能并行传送信息的位数（各硬件部件通过数据总线传输数据）；\n吞吐量：系统在单位时间内处理请求的数量；\n响应时间：从用户向计算机发送一个请求，到系统对该请求作出响应并获得它所需要的结果的等待时间；\n","date":"2024-02-27T10:13:54+08:00","image":"https://chaihaojian.github.io/post/computer_composition_principles/chapter_1/cover_huf070decc27d1c42dbee75c2bdff912a4_225263_120x120_fill_q75_box_smart1.JPG","permalink":"https://chaihaojian.github.io/post/computer_composition_principles/chapter_1/","title":"计算机系统概述"},{"content":"二叉搜索树 如果左子节点存在，则左子节点的值小于当前节点的值； 如果右子节点存在，则右子节点的值大于当前节点的值。 对于二叉搜索树中的一个节点，可以根据上述性质确定由根节点到该节点的路径。 1func getPath(root, target *TreeNode)(path []*TreeNode){ 2​\tnode := root 3​\tfor node != target { 4​\tpath = append(path, node) 5​\tif node.Val \u0026gt; target.Val { 6​\tnode = node.Left 7​\t}else { 8​\tnode = node.Right 9​\t} 10​\t} 11​\tpath = append(path, node) 12​\treturn 13} ","date":"2024-02-25T22:01:10+08:00","image":"https://chaihaojian.github.io/post/data_struct/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/cover_huf070decc27d1c42dbee75c2bdff912a4_225263_120x120_fill_q75_box_smart1.JPG","permalink":"https://chaihaojian.github.io/post/data_struct/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/","title":"二叉搜索树"}]