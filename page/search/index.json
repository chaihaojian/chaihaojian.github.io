[{"content":"","date":"2024-03-09T13:31:05+08:00","image":"https://chaihaojian.github.io/post/javascript_note/javascript%E5%80%BC%E7%B1%BB%E5%9E%8B%E4%BD%BF%E7%94%A8/cover_hu5d37d57dbb2a2417866d45a70fddc4ea_305553_120x120_fill_q75_box_smart1.JPG","permalink":"https://chaihaojian.github.io/post/javascript_note/javascript%E5%80%BC%E7%B1%BB%E5%9E%8B%E4%BD%BF%E7%94%A8/","title":"Javascript值类型使用"},{"content":"运算符与流程控制 一元运算符的前置与后置操作(++n与n++的区别) 两者在不参与其他运算时结果相同，都是n自增；\n1let a = 1; 2let b = 1; 3++a; 4console.log(a); 5b++; 6console.log(b); 在参与其他运算时，++n先自增，再进行运算；n++先进行运算，再自增。\n1let n = 1; 2let m = 1; 3let f = 2; 4let d = f + ++n;//n先自增，然后运算f + n 5console.log(d); 6console.log(n); 7let e = f + m++;//先运算f + n, 然后n自增 8console.log(e); 9console.log(m); 比较运算符 == 与 === a == b，如果a, b不是相同类型的变量，js会自动将两个变量转换成相同类型再进行比较；a === b 则会直接进行比较。\n1let a = 1; 2let b = \u0026#34;1\u0026#34;; 3console.log(a == b); 4console.log(a \u0026gt;= b); 5console.log(a === b); 逻辑运算符 逻辑与： \u0026amp;\u0026amp;\n逻辑或： ||\n逻辑非： !\n短路运算 1可以表示true；0可以表示false；\n1let a = 1, b = 0; 2console.log(a == true) 3console.log(a == false) 4console.log(b == true) 5console.log(b == false) 在逻辑或进行判断时，如 （a || b）：若a为真，则不再判断b，直接返回真；若a为假，则继续判断b的真假；\n短路运算在赋值中的妙用 1let a = 3; 2let b; 3let c = 4; 4let f = b || a;//b为空，因此将a的值赋给f 5console.log(f); 6let p = c || a;//c不为空，因此不需要判断a，直接将c的值赋给p 7console.log(p); 流程控制 if else 三元表达式 1let h = true?2:5; 2console.log(h); 3let l = false?2:5; 4console.log(l); switch 1let name = \u0026#34;hi\u0026#34; 2switch(name){ 3 case \u0026#34;hello\u0026#34;: 4 console.log(\u0026#34;hello\u0026#34;); 5 break; 6 case \u0026#34;hi\u0026#34;: 7 console.log(\u0026#34;hi\u0026#34;); 8 break; 9 default: 10 console.log(\u0026#34;default\u0026#34;); 11}; while 循环控制 1function genTable(options = {tr: 5, td: 3}){ 2 document.write(`\u0026lt;table border = \u0026#34;1\u0026#34; width=\u0026#34;100%\u0026#34;`); 3 while(options.tr-- != 0){ 4 let td = options.td; 5 document.write(`\u0026lt;tr\u0026gt;`); 6 while(td-- != 0){ 7 document.write(`\u0026lt;td\u0026gt;${td}\u0026lt;/td\u0026gt;`); 8 } 9 document.write(`\u0026lt;/tr\u0026gt;`); 10 } 11 document.write(`\u0026lt;/table\u0026gt;`); 12} 13genTable(); 14document.write(`\u0026lt;br/\u0026gt;`); 15genTable({tr: 3, td: 5}); do while 循环控制 1function genStars(row = 5){ 2 let l = 0; 3 do { 4 let n = 0; 5 do { 6 document.write(\u0026#34;*\u0026#34;); 7 } while (++n \u0026lt;= l); 8 document.write(`\u0026lt;br/\u0026gt;`); 9 } while(++l \u0026lt; row); 10}; 11genStars(); 12document.write(`\u0026lt;br/\u0026gt;`); 13genStars(8); for 循环 1function genStars(row = 5){ 2 for (let i = 1; i \u0026lt;= row; i++){ 3 for (let n = row - i; n \u0026gt; 0; n--){ 4 document.write(`\u0026lt;span style=\u0026#34;color: white\u0026#34;\u0026gt;^\u0026lt;/span\u0026gt;`); 5 } 6 for (let m = i * 2 - 1; m \u0026gt; 0; m--){ 7 document.write(`*`); 8 } 9 document.write(`\u0026lt;br/\u0026gt;`); 10 } 11} 12genStars(); 13document.write(`\u0026lt;br/\u0026gt;`); 14genStars(8); continue 与 break continue：停止当前循环，进行下一次循环；\nbreak：终止当前循环；\n如果需要从子循环直接终止更上一级的循环，需要通过标签：\n1pa: for (let i = 1; i \u0026lt;= 10; i++){ 2 ch: for (let j = 1; j \u0026lt;= 10; j++){ 3 if (j % 2 == 0){ 4 console.log(i, j); 5 } 6 if (i + j \u0026gt; 10){ 7 break pa; 8 }; 9 }; 10}; for-in 与 for-of 1let array = [1, 2, 3, 4]; 2for (let key in array){ 3 console.log(key, array[key]); 4}; 1let array = [1, 2, 3, 4]; 2for (const value of array) { 3 console.log(value); 4}; ","date":"2024-03-06T11:44:29+08:00","image":"https://chaihaojian.github.io/post/javascript_note/%E8%BF%90%E7%AE%97%E7%AC%A6%E4%B8%8E%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/cover_hu7c4cdf01cea81a03b0eb35f8c46fc90c_1264985_120x120_fill_q75_box_smart1.JPG","permalink":"https://chaihaojian.github.io/post/javascript_note/%E8%BF%90%E7%AE%97%E7%AC%A6%E4%B8%8E%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/","title":"运算符与流程控制"},{"content":"C++基础语法 变量 创建变量 1//数据类型 变量名 = 变量初始值; 2int a = 10; 常量 常量的作用 用于记录程序中不可更改的数据\nC++定义常量的两种方式 1.#define 宏常量 1#include \u0026lt;iostream\u0026gt; 2using namespace std; 3 4#define Day 7 5 6int main() 7{ 8 cout \u0026lt;\u0026lt; Day \u0026lt;\u0026lt; endl; 9 10 return 0; 11} 2.const修饰的变量 1#include \u0026lt;iostream\u0026gt; 2using namespace std; 3 4int main() 5{ 6 const int month = 12; 7 8 cout \u0026lt;\u0026lt; month \u0026lt;\u0026lt; endl; 9 10 return 0; 11} 关键字 关键字是C++中预先保留的单词（标识符），在定义变量或常量时，不要用关键字，否则会产生歧义。\n标识符命名规则 标识符不能是关键字；\n标识符只能由字母、数字、下划线组成；\n第一个字符必须为字母或下划线；\n标识符中的字母区分大小写；\n数据类型（给变量或常量分配合适的内存空间） C++规定在创建一个变量或者常量时，必须要指定相应的数据类型，否则无法给变量分配内存。\nsizeof 关键字 利用sizeof关键字可以统计数据类型所占内存大小：sizeof(数据类型 / 变量)\n1#include \u0026lt;iostream\u0026gt; 2using namespace std; 3 4int main() 5{ 6 short num1 = 10; 7 cout \u0026lt;\u0026lt; \u0026#34;space occupied by num1:\u0026#34; \u0026lt;\u0026lt; sizeof(num1) \u0026lt;\u0026lt; endl; 8 //space occupied by num1:2 9 10 int num2 = 10; 11 cout \u0026lt;\u0026lt; \u0026#34;space occupied by int:\u0026#34; \u0026lt;\u0026lt; sizeof(int) \u0026lt;\u0026lt; endl; 12 //space occupied by int:4 13 14 return 0; 15} 整型 C++中能够表示整型的类型有以下几种方式，区别在于所占内存空间不同：\n数据类型 占用空间 取值范围 short（短整型） 2 字节 （-2^15 - 2^15-1） Int（整型） 4 字节 （-2^31 - 2^31-1） long（长整型） Windows为 4 字节，Linux为 4 字节（32 位），8字节（64 位） （-2^31 - 2^31-1） long long（长长整型） 8 字节 （-2^63 - 2^63-1） 当需要保存的值超出当前数据类型的取值范围时，c++会提示警告超出内存，但不会报错，该变量值会变为在该数据类型的取值范围内最接近该变量值的值：\n1#include \u0026lt;iostream\u0026gt; 2using namespace std; 3 4int main() 5{ 6 //短整型 7 short num1 = 10; 8 //整型 9 int num2 = 10; 10 //长整型 11 long num3 = 10; 12 //长长整型 13 long long num4 = 10; 14 15 cout \u0026lt;\u0026lt; \u0026#34;num1:\u0026#34; \u0026lt;\u0026lt; num1 \u0026lt;\u0026lt; endl; 16 cout \u0026lt;\u0026lt; \u0026#34;num2:\u0026#34; \u0026lt;\u0026lt; num2 \u0026lt;\u0026lt; endl; 17 cout \u0026lt;\u0026lt; \u0026#34;num3:\u0026#34; \u0026lt;\u0026lt; num3 \u0026lt;\u0026lt; endl; 18 cout \u0026lt;\u0026lt; \u0026#34;num4:\u0026#34; \u0026lt;\u0026lt; num4 \u0026lt;\u0026lt; endl; 19 20 num1 = 32768; 21 cout \u0026lt;\u0026lt; \u0026#34;num1:\u0026#34; \u0026lt;\u0026lt; num1 \u0026lt;\u0026lt; endl; 22 23 num1 = -32769; 24 cout \u0026lt;\u0026lt; \u0026#34;num1:\u0026#34; \u0026lt;\u0026lt; num1 \u0026lt;\u0026lt; endl; 25 26 return 0; 27} 实型（浮点型） 浮点型变量分为两种：\n单精度 float 双精度 double 两者的区别在于表示的有效数字范围不同。\n数据类型 占用空间 有效数字范围 float 4字节 7位有效数字 double 8字节 15-16位有效数字 1float a = 3.14f;//(float)(3.14F) 建议使用该方法声明一个float变量 2float b = 3.14;//(double)(3.14) 上述两种方法都声明了一个float变量，但第二种方法c++默认值小数3.14是double类型，在声明后需要将double类型的3.14转换为float类型，在变量值后加f则表明3.14是float类型；\n1float a = 3.1415926f; 2float b = 3.14; 3 4cout \u0026lt;\u0026lt; \u0026#34;a = \u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; 5 6double m = 3.1415926; 7cout \u0026lt;\u0026lt; \u0026#34;m = \u0026#34; \u0026lt;\u0026lt; m \u0026lt;\u0026lt; endl; 注意：默认情况下，float和double类型的变量在输出时，都只会显示出6位有效数字。\n科学计数法 1float c = 3e2;//3 * 10^2 2float d = 3e-2;//3 * 10^-2 3cout \u0026lt;\u0026lt; \u0026#34;c = \u0026#34; \u0026lt;\u0026lt; c \u0026lt;\u0026lt; endl; 4cout \u0026lt;\u0026lt; \u0026#34;d = \u0026#34; \u0026lt;\u0026lt; d \u0026lt;\u0026lt; endl; 字符型（表示单个字符） 1char ch = \u0026#39;a\u0026#39;; 2cout \u0026lt;\u0026lt; \u0026#34;ch: \u0026#34; \u0026lt;\u0026lt; ch \u0026lt;\u0026lt; endl; 3cout \u0026lt;\u0026lt; \u0026#34;size of ch: \u0026#34; \u0026lt;\u0026lt; sizeof(ch) \u0026lt;\u0026lt; endl; 4cout \u0026lt;\u0026lt; \u0026#34;ASCII of ch: \u0026#34; \u0026lt;\u0026lt; (int)ch \u0026lt;\u0026lt; endl; 注意：\n在显示字符型变量时，用单引号将字符括起来，不要用双引号； 单引号内只能有一个字符，不可以是字符串； C和C++中字符型变量只占用一个字节； 字符型变量并不是把字符本身放到内存中存储，而是将字符对应的ASCII编码放入到存储单元。 字符型变量对应的ASCII码 a - 97 A - 65 转义字符 用于表示一些不能直接输出的ASCII字符\n转义字符 含义 ASCII码（十进制） \\n 换行 010 \\t 水平制表（跳到下一个TAB位置） 009 \\\\ 代表一个反斜杠字符\u0026quot;\\\u0026quot; 092 字符串型（表示一串字符） C风格字符串 1char str1[] = \u0026#34;hello\u0026#34;; C++风格字符串 1#include\\\u0026lt;string\u0026gt; 2using namespace std； 3 4string str2 = \u0026#34;world\u0026#34;; 注意：使用C++风格字符串需要包含一个头文件 #include\u0026lt;string\u0026gt;和using namespace std\n布尔类型 bool类型只有两个值：\ntrue 表示真，本质是1； false 表示假，本质是0； bool类型占一个字节\n运算符（执行代码的运算） 算数运算符（处理四则运算） 运算符 术语 示例 结果 + - + - * / % 取余 ++ 前置递增（先让变量+1，然后进行表达式运算） a=2; b=++a; a=3; b=3; ++ 后置递增（先进行表达式运算，后让变量+1） a=2; b=a++; a=3; b=2; \u0026ndash; 前置递减 a=2; b=\u0026ndash;a; a=1; b=1; \u0026ndash; 后置递减 a=2; b=a\u0026ndash;; a=1; b=2; 赋值运算符（将表达式的值赋给变量） 运算符 术语 示例 结果 = += -= *= /= %= 比较运算符（用于表达式的比较，返回一个真值或假值） 运算符 术语 示例 结果 == != \u0026lt; \u0026gt; \u0026lt;= \u0026gt;= 逻辑运算符 运算符 术语 示例 结果 ! \u0026amp;\u0026amp; || 程序流程控制结构 顺序结构（程序按顺序执行，不发生跳转） 选择结构（依据条件是否满足，有选择地执行相应功能） if 语句 三目运算符 语法：表达式1 ？表达式2 ：表达式3；\n如果表达式1为真，执行表达式2，并返回表达式2的结果；\n如果表达式1为假，执行表达式3，并返回表达式3的结果；\nswitch 语句 循环结构 数组 数组的特点 数组中的每一个数据元素都是相同的数据类型； 数组是由连续的内存位置组成的； 数组的定义 数据类型 数组名[数组长度]； 数据类型 数组名[数组长度] = {值1，值2 \u0026hellip;}; 数据类型 数组名[] = {值1，值2 \u0026hellip;}; 一维数组 一维数组在内存中的长度 1int arr[5] = {1,2,3,4,5}; 2cout \u0026lt;\u0026lt; \u0026#34;arrdress of arr: \u0026#34; \u0026lt;\u0026lt; arr \u0026lt;\u0026lt; endl; 3cout \u0026lt;\u0026lt; \u0026#34;size of arr: \u0026#34; \u0026lt;\u0026lt; sizeof(arr) \u0026lt;\u0026lt; endl; 4cout \u0026lt;\u0026lt; \u0026#34;size of arr[0]: \u0026#34; \u0026lt;\u0026lt; sizeof(arr[0]) \u0026lt;\u0026lt; endl; 5cout \u0026lt;\u0026lt; \u0026#34;length of arr: \u0026#34; \u0026lt;\u0026lt; sizeof(arr) / sizeof(arr[0]) \u0026lt;\u0026lt; endl; 一维数组的冒泡排序 思路（升序）：\n比较相邻的两个元素，如果第一个比第二个大，就交换它们的位置； 对每一个元素做同样的工作，执行完第一次后，找到数组中的第一个最大值； 重复上述步骤，每次比较次数-1，直到不需要比较； 二维数组 二维数组在内存中的长度 1int arr[2][3] = 2{ 3 {1,2,3}, 4 {4,5,6} 5}; 6 7cout \u0026lt;\u0026lt; \u0026#34;arrdress of arr: \u0026#34; \u0026lt;\u0026lt; arr \u0026lt;\u0026lt; endl; 8cout \u0026lt;\u0026lt; \u0026#34;size of arr: \u0026#34; \u0026lt;\u0026lt; sizeof(arr) \u0026lt;\u0026lt; endl; 9cout \u0026lt;\u0026lt; \u0026#34;size of arr[0]: \u0026#34; \u0026lt;\u0026lt; sizeof(arr[0]) \u0026lt;\u0026lt; endl; 10cout \u0026lt;\u0026lt; \u0026#34;length of arr: \u0026#34; \u0026lt;\u0026lt; sizeof(arr) / sizeof(arr[0]) \u0026lt;\u0026lt; endl; 11cout \u0026lt;\u0026lt; \u0026#34;items of arr: \u0026#34; \u0026lt;\u0026lt; sizeof(arr) / sizeof(arr[0][0]) \u0026lt;\u0026lt; endl; 函数 函数的定义 1//定义一个函数 2返回值类型 函数名（参数列表） 3{ 4 函数体语句 5 6 return表达式 7} 函数的调用 值传递 函数在发生调用时，实参将值传递给形参；\n值传递时，形参发生变化，并不会影响实参；\n函数的声明 作用：提前告诉编译器函数名称及如何调用函数，函数的实际主体可以单独定义；函数的声明可以多次，但是函数的定义只能有一次；\n1int main() 2{ 3 int m = 2; 4 int n = 4; 5 cout \u0026lt;\u0026lt; maxNum(m, n) \u0026lt;\u0026lt; endl; 6 7 return 0; 8} 9 10int maxNum(int a, int b) 11{ 12 return a \u0026gt; b ? a : b; 13} 函数maxNum定义在main函数之后会产生报错；需要在执行main函数之前告诉编译器有maxNum这样一个函数存在，因此可以将maxNum函数定义在main函数之前，或者在main函数之前使用声明语句；\n1int maxNum(int a, int b); 2 3int maxNum(int a, int b) 4{ 5 return a \u0026gt; b ? a : b; 6} 7 8int main() 9{ 10 int m = 2; 11 int n = 4; 12 cout \u0026lt;\u0026lt; maxNum(m, n) \u0026lt;\u0026lt; endl;//4 13 14 return 0; 15} 函数的分文件编写 函数分文件编写的步骤：\n创建后缀名为.h的头文件； 创建后缀名为.cpp的源文件； 在头文件中写函数的声明； 在源文件中写函数的定义； 一个c++项目的文件结构如下：\n1//maxNum.h 2 3#include \u0026lt;iostream\u0026gt; 4using namespace std; 5 6int maxNum(int a, int b); 1//maxNum.cpp 2 3#include \u0026#34;../inc/maxNum.h\u0026#34; 4// #include \u0026lt;iostream\u0026gt; 5// using namespace std; 6 7int maxNum(int a, int b) 8{ 9 cout \u0026lt;\u0026lt; \u0026#34;helllo\u0026#34; \u0026lt;\u0026lt; endl; 10 return a \u0026gt; b ? a : b; 11} 1//main.cpp 2 3int main() 4{ 5 int m = 2; 6 int n = 4; 7 cout \u0026lt;\u0026lt; maxNum(m, n) \u0026lt;\u0026lt; endl; 8 9 return 0; 10} 指针 作用：可以通过指针直接访问内存\n内存编号是从0开始记录的，一般用16进制数字表示；\n可以利用指针变量保存地址；\n指针变量的定义和使用 定义语法：数据类型 * 变量名；\n使用方法：可以通过解引用的方式来找到指针指向的内存中保存的值；指针变量前加*代表解引用，找到指针指向的内存中的数据；\n1int main() 2{ 3 int a = 10; 4 int * p; 5 p = \u0026amp;a; 6 cout \u0026lt;\u0026lt; \u0026#34;the value of a: \u0026#34; \u0026lt;\u0026lt; p \u0026lt;\u0026lt; endl; 7 cout \u0026lt;\u0026lt; \u0026#34;address of a: \u0026#34; \u0026lt;\u0026lt; \u0026amp;a \u0026lt;\u0026lt; endl; 8 cout \u0026lt;\u0026lt; \u0026#34;the value of p: \u0026#34; \u0026lt;\u0026lt; p \u0026lt;\u0026lt; endl; 9 cout \u0026lt;\u0026lt; \u0026#34;the value pointed to by pointer p: \u0026#34; \u0026lt;\u0026lt; *p \u0026lt;\u0026lt; endl; 10 11 *p = 100; 12 cout \u0026lt;\u0026lt; \u0026#34;the value of a: \u0026#34; \u0026lt;\u0026lt; p \u0026lt;\u0026lt; endl; 13 cout \u0026lt;\u0026lt; \u0026#34;address of a: \u0026#34; \u0026lt;\u0026lt; \u0026amp;a \u0026lt;\u0026lt; endl; 14 cout \u0026lt;\u0026lt; \u0026#34;the value of p: \u0026#34; \u0026lt;\u0026lt; p \u0026lt;\u0026lt; endl; 15 cout \u0026lt;\u0026lt; \u0026#34;the value pointed to by pointer p: \u0026#34; \u0026lt;\u0026lt; *p \u0026lt;\u0026lt; endl; 16 17 return 0; 18} 指针类型所占的内存空间 编译器编译的程序是32位时(X86)，指针类型占4个字节的内存空间； 编译器编译的程序是64位时(X64, ARM64)，指针类型占8个字节的内存空间； 空指针和野指针 空指针：指针变量指向内存中编号为0的空间；\n用途：初始化指针变量；\n注意：空指针指向的内存是不可以访问的；\n野指针：指针变量指向非法的内存空间；\n空指针和野指针都不是自己申请的空间，因此不能访问；\n1int main() 2{ 3 //声明了一个空指针p1 4 int * p1 = NULL; 5 *p1 = 10; 6 cout \u0026lt;\u0026lt; \u0026#34;the value pointed to by pointer p1: \u0026#34; \u0026lt;\u0026lt; *p1 \u0026lt;\u0026lt; endl; 7 8 //给指针类型变量p2赋了一个地址值(int *)0x1100， 9 //但该地址值不是本程序申请的，因此无法对该地址指向的内存空间进行读写 10 int * p2 = (int *)0x1100; 11 *p2 = 10; 12 cout \u0026lt;\u0026lt; \u0026#34;the value pointed to by pointer p2: \u0026#34; \u0026lt;\u0026lt; *p2 \u0026lt;\u0026lt; endl; 13 14 return 0; 15} const修饰指针 const修饰指针有三种情况：\nconst修饰指针\t\u0026mdash;常量指针（常量的指针，该指针指向的值是一个常量）； const修饰常量 \u0026mdash;指针常量（该指针类型变量是一个常量）； const既修饰指针，又修饰常量； 常量指针 const int * p = \u0026amp;a; 指针的指向可以修改； 指针指向的值不可以修改； 1int main() 2{ 3 int a = 10; 4 int b = 100; 5 6 const int * p = \u0026amp;a;//声明了一个常量指针p 7 8 *p = 20;//对指针p指向的值进行修改，会报错 9 p = \u0026amp;b;//改变指针p的指向，不会报错 10 11 return 0; 12} 指针常量 int * const p = \u0026amp;a; 指针的指向不可以修改； 指针指向的值可以修改； 1int main() 2{ 3 int a = 10; 4 int b = 100; 5 6 int * const p = \u0026amp;a;//声明了一个指针常量 7 8 *p = 20;//该指针常量指向的值可以修改 9 p = \u0026amp;b;//该指针类型p是一个常量，因此p的值不能修改 10 11 return 0; 12} const既修饰指针，又修饰常量 指针的指向和指针指向的值都不可以修改； 1int main() 2{ 3 int a = 10; 4 int b = 100; 5 const int * const p = \u0026amp;a;//既修饰指针，又修饰常量 6 7 *p = 20;//指针p指向的值是一个常量，因此不可以修改 8 p = \u0026amp;b;//指针p是一个常量，因此指针p的值即指针p的指向不可以修改 9 10 return 0; 11} 指针和数组（利用指针访问数组中的元素） 1 2int main() 3{ 4 int arr[5] = {1,2,3,4,5}; 5 int * p = arr; 6 7 cout \u0026lt;\u0026lt; \u0026#34;pointer p points to the head of arr: \u0026#34; \u0026lt;\u0026lt; *p \u0026lt;\u0026lt; endl; 8 9 p++; 10 cout \u0026lt;\u0026lt; \u0026#34;pointer p points to the second element of arr: \u0026#34; \u0026lt;\u0026lt; *p \u0026lt;\u0026lt; endl; 11 12 return 0; 13} 指针和函数 值传递 1void swap01(int a, int b) 2{ 3 int temp = a; 4 a = b; 5 b = temp; 6 7 cout \u0026lt;\u0026lt; \u0026#34;swap01 a = \u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; 8 cout \u0026lt;\u0026lt; \u0026#34;swap01 b = \u0026#34; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; endl; 9} 10 11int main() 12{ 13 int a = 1; 14 int b = 2; 15 swap01(a, b);//swap01()函数中的参数是值传递，因此不会改变实参的值 16 17 cout \u0026lt;\u0026lt; \u0026#34;main a = \u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; 18 cout \u0026lt;\u0026lt; \u0026#34;main b = \u0026#34; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; endl; 19 return 0; 20} 地址传递 1void swap(int * a, int * b) 2{ 3 int temp = *a; 4 *a = *b; 5 *b = temp; 6 7 cout \u0026lt;\u0026lt; \u0026#34;swap *a = \u0026#34; \u0026lt;\u0026lt; *a \u0026lt;\u0026lt; endl; 8 cout \u0026lt;\u0026lt; \u0026#34;swap *b = \u0026#34; \u0026lt;\u0026lt; *b \u0026lt;\u0026lt; endl; 9} 10 11int main() 12{ 13 int a = 1; 14 int b = 2; 15 swap(\u0026amp;a, \u0026amp;b);//传入swap()函数的是a，b的地址，因此会对实参造成改变 16 17 cout \u0026lt;\u0026lt; \u0026#34;main a = \u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; 18 cout \u0026lt;\u0026lt; \u0026#34;main b = \u0026#34; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; endl; 19 return 0; 20} 结构体 ","date":"2024-03-05T22:29:24+08:00","image":"https://chaihaojian.github.io/post/c_plus_note/chapter1_%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/cover_hudb412b59d0d815ead8ba404fe2018587_757370_120x120_fill_q75_box_smart1.JPG","permalink":"https://chaihaojian.github.io/post/c_plus_note/chapter1_%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/","title":"C++基础语法"},{"content":"走进JavaScript JS从上到下顺序执行 1\u0026lt;!DOCTYPE html\u0026gt; 2\u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; 3\u0026lt;head\u0026gt; 4 \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; 5 \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; 6 \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; 7 \u0026lt;script\u0026gt; 8 alert(3); 9 \u0026lt;/script\u0026gt; 10\u0026lt;/head\u0026gt; 11\u0026lt;body\u0026gt; 12 \u0026lt;h1\u0026gt;aaaaaaa\u0026lt;/h1\u0026gt; 13\u0026lt;/body\u0026gt; 14\u0026lt;/html\u0026gt; 1\u0026lt;!DOCTYPE html\u0026gt; 2\u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; 3\u0026lt;head\u0026gt; 4 \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; 5 \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; 6 \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; 7\u0026lt;/head\u0026gt; 8\u0026lt;body\u0026gt; 9 \u0026lt;h1\u0026gt;aaaaaaa\u0026lt;/h1\u0026gt; 10 \u0026lt;script\u0026gt; 11 alert(3); 12 \u0026lt;/script\u0026gt; 13\u0026lt;/body\u0026gt; 14\u0026lt;/html\u0026gt; 两种写法的页面效果不同 将js放在前面时，后续内容需要等当前js执行结束再加载，因此一般将js放在页面的最后\n注释 单行注释：//\n多行注释：/*\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;*/\n执行符 js每行结束后必须加分号 ；\n变量声明 1var a = \u0026#34;abcdef\u0026#34;; 2 3var a 4a = \u0026#34;abcdef\u0026#34; 5 6var a = \u0026#34;hello\u0026#34;, age = 18, url = \u0026#34;chai.com\u0026#34;; 7 8var a = b = c = \u0026#34;hello\u0026#34;; 变量提升 在浏览器执行代码前，解析器会先分析代码：\n1var web = \u0026#34;hello\u0026#34;; 2console.log(web); 3var class = \u0026#34;world\u0026#34; 上述代码在执行时会直接报错，因为解析器在执行代码前分析时发现了问题；\n1console.log(web); 2var web = \u0026#34;hello.com\u0026#34;; 3 4//上述代码相当于 5console.log(web); 6var web ; 7web = \u0026#34;hello.com\u0026#34;; 8 9//变量提升 10var web ; 11console.log(web); 12web = \u0026#34;hello.com\u0026#34;; 解析器在分析时，会将变量声明的语句提升，因此执行时会输出undefined；\n1function hd() { 2 if(false) { 3 var web = \u0026#34;hello.com\u0026#34;; 4 } 5 console.log(web); 6} 7hd(); 8 9//变量提升 10function hd() { 11 var web; 12 if(false) { 13 web = \u0026#34;hello.com\u0026#34;; 14 } 15 console.log(web); 16} 17hd(); 使用 let 或 const 声明变量 1console.log(web); 2let web = \u0026#34;hello.com\u0026#34;; 1let web = \u0026#34;hello.com\u0026#34;; 2console.log(web); 使用let声明的变量，必须要先声明，在使用；上述代码的第一种情况会产生临时性死区TDZ；\n块作用域与全局污染 全局污染 1function show() { 2 web = \u0026#34;hello.com\u0026#34;; 3 console.log(web); 4}; 5show(); 6console.log(web); 上述代码中web并没有通过var，let，const声明，但仍可以使用；然而web应该只在show()函数中被使用，但此时在函数外也能使用该变量，这就造成了全局污染。\n使用严格模式 1\u0026#34;use strict\u0026#34; 2function show() { 3 web = \u0026#34;hello.com\u0026#34;; 4 console.log(web); 5}; 6show(); 7console.log(web); 1\u0026#34;use strict\u0026#34; 2function show() { 3 let web = \u0026#34;hello.com\u0026#34;; 4 console.log(web); 5}; 6show(); 7console.log(web); 在js代码中添加\u0026quot;use strict\u0026quot;语句表明使用严格模式，要求变量必须先声明再使用。\n块作用域 var声明的变量只有函数作用域和全局作用域：\n1var i = 99; 2 3for (var i = 0; i \u0026lt; 5; i++) { 4 console.log(\u0026#34;循环内的i：\u0026#34;,i); 5}; 6console.log(\u0026#34;循环外的i：\u0026#34;, i); for循环内声明的i影响到了for循环外的i，造成了污染；\n1var i = 99; 2for (let i = 0; i \u0026lt; 5; i++) { 3 console.log(\u0026#34;循环内的i：\u0026#34;,i); 4}; 5console.log(\u0026#34;循环外的i：\u0026#34;, i); 6 7let i = 99; 8for (let i = 0; i \u0026lt; 5; i++) { 9 console.log(\u0026#34;循环内的i：\u0026#34;,i); 10}; 11console.log(\u0026#34;循环外的i：\u0026#34;, i); let声明的变量拥有块作用域，因此for循环内的i不会影响到for循环外的i。\n对于var拥有函数作用域的进一步解释 1(function(){ 2 var $ = (window.$ = {}); 3 $.web = \u0026#34;hello.com\u0026#34;; 4 var url = \u0026#34;nihao.com\u0026#34;; 5}.bind(window)());//这是一个立即执行函数 6 7console.log(url); 在上述代码中，用var声明的变量$被定义在一个立即执行函数中，由于var拥有函数作用域，因此在这个立即执行函数外无法访问到$；通过在该立即执行函数内声明getUrl()和get$()子函数，可以将在该立即执行函数中的声明的变量暴露给外界使用。\n1(function(){ 2 var $ = (window.$ = {}); 3 $.web = \u0026#34;hello.com\u0026#34;; 4 var url = \u0026#34;nihao.com\u0026#34;; 5 $.getUrl = function() { 6 return url; 7 }; 8 $.get$ = function() { 9 return $; 10 }; 11}.bind(window)()); 12 13console.log($.getUrl()); 14console.log($.get$()); 由于let拥有块作用域，因此上述代码又可以改写为：\n1{ 2 let $ = (window.$ = {}); 3 $.web = \u0026#34;hello.com\u0026#34;; 4 let url = \u0026#34;nihao.com\u0026#34;; 5 }; 6}//变量$, url都在一个用{}包起来的代码块中 7 8console.log(url); 1{ 2 let $ = (window.$ = {}); 3 $.web = \u0026#34;hello.com\u0026#34;; 4 let url = \u0026#34;nihao.com\u0026#34;; 5 $.getUrl = function() { 6 return url; 7 }; 8 $.get$ = function() { 9 return $; 10 }; 11} 12 13console.log($.getUrl()); 14console.log($.get$()); const常量声明 const也拥有块作用域，在同一作用域里，const声明的常量无法更改:\n1const URL = \u0026#34;hello.com\u0026#34;; 2{ 3 const URL = \u0026#34;world.com\u0026#34; 4 console.log(URL); 5} 6console.log(URL); 1const URL = \u0026#34;hello.com\u0026#34;; 2URL = \u0026#34;world.com\u0026#34;; 3console.log(URL); 1const URL = \u0026#34;hello.com\u0026#34;; 2function show() { 3 const URL = \u0026#34;world.com\u0026#34;; 4 console.log(URL); 5} 6show(); 7console.log(URL); 当const声明的常量是引用类型时，可以进行更改：\n1const CONFIG = { 2 URL: \u0026#34;hello.com\u0026#34; 3}; 4console.log(CONFIG); 5CONFIG.URL = \u0026#34;world.com\u0026#34;; 6console.log(CONFIG); 对造成上述结果的分析：\n使用const声明一个基本类型的常量时，当改变该常量的值时，会造成该常量引用的地址发生改变，在上述代码中，\u0026ldquo;hello.com\u0026quot;和\u0026quot;world.com\u0026quot;在计算机中存储的地址不同，因此再次赋值会导致URL所引用的地址发生改变，因此报错；但是声明的是一个引用类型的常量时，由于更改CONFIG.URL并不会导致CONFIG所引用的地址发生改变，因此不会报错。\n对var与let的进一步说明 1var web0 = \u0026#34;hello.com\u0026#34;; 2console.log(window.web0); 3 4let web1 = \u0026#34;world.com\u0026#34;; 5console.log(window.web1); 6console.log(web1); 由var声明的变量会保存到全局对象window中，而let不会；且在同一作用域下，var出现重复声明不会报错，但let和const会报错。\n变量冻结 使用Object.freeze()可以使由const声明的引用类型的常量不发生改变，在严格模式下，对被Object.freeze()冻结的变量进行修改会报错。\n1 \u0026#34;use strict\u0026#34; 2const CONFIG = { 3 URL: \u0026#34;hello.com\u0026#34; 4}; 5console.log(CONFIG); 6Object.freeze(CONFIG); 7CONFIG.URL = \u0026#34;world.com\u0026#34;; 8console.log(CONFIG); \u0026ldquo;use strict\u0026rdquo;\n传值与传址 1//传值 2let a = 1; 3let b = a; 4console.log(a, b); 5b = 2; 6console.log(a, b); 7 8//传址 9let c = {url: \u0026#34;hello.com\u0026#34;}; 10let d = c; 11console.log(c, d); 12d.url = \u0026#34;world.com\u0026#34;; 13console.log(c, d); null与undefined 两者都表示没有值\nnull：当声明了一个引用类型变量，但没有赋值时，此时该引用类型变量为null\nundefin：当声明了一个基本类型变量，但没有赋值时，此时该基本类型变量为null\n在js函数中，当传递的参数，或着返回值没有值时，默认都是undefined\n1function show(name){ 2 console.log(name); 3}; 4console.log(show()); use strict 严格模式 严格模式的作用域包含当前作用域及其子作用域：\n1function show(){ 2 \u0026#34;use strict\u0026#34; 3 web = \u0026#34;hello.com\u0026#34;; 4 console.log(web); 5}; 6function hd(){ 7 site = \u0026#34;world.com\u0026#34;; 8 console.log(site); 9}; 10hd(); 11show(); 1function show(){ 2 web = \u0026#34;hello.com\u0026#34;; 3 console.log(web); 4 function handle(){ 5 \u0026#34;use strict\u0026#34; 6 url = \u0026#34;nihao.com\u0026#34;; 7 console.log(url); 8 }; 9 handle(); 10}; 11function hd(){ 12 site = \u0026#34;world.com\u0026#34;; 13 console.log(site); 14}; 15hd(); 16show(); 推荐在编写js代码时添加严格模式，使代码在更多的环境中运行。\n","date":"2024-02-27T13:42:01+08:00","image":"https://chaihaojian.github.io/post/javascript_note/%E8%B5%B0%E8%BF%9Bjavascript/cover_hub8b395643672f7ca335685551bcb8ad3_728006_120x120_fill_q75_box_smart1.JPG","permalink":"https://chaihaojian.github.io/post/javascript_note/%E8%B5%B0%E8%BF%9Bjavascript/","title":"走进JavaScript"},{"content":"第一章 计算机系统概述 计算机通过电信号传递数据 低电平表示二进制0\n高电平表示二进制1\n计算机系统 包括硬件和软件两大方面。\n计算机硬件的发展 第一代：第一台电子数字计算机：ENIAC（1946） 逻辑元件：电子管；\n第二代：晶体管 体积、功耗降低 出现面向过程的程序设计语言：FORTRAN 有了操作系统雏形；\n第三代： 中小规模集成电路 计算机主要用于科学计算等专业用途 高级语言迅速发展 开始有了分时操作系统；\n第四代：大规模、超大规模集成电路 开始出现微处理器、微型计算机 个人计算机（PC）萌芽 ；\n微型计算机的发展以微处理器技术为标志；\n机器字长：计算机一次整数运算所能处理的二进制位数；\n摩尔定律：集成电路上可容纳的晶体管数目，约每隔18个月便会增加一倍，整体性能也将提升一倍；该定律揭示了信息技术进步的速度。\n计算机软件的发展 机器语言 \u0026ndash;\u0026gt; 汇编语言 \u0026ndash;\u0026gt; 高级语言\n计算机的发展趋势（两极分化） 1.微型计算机向更微型化、网络化、高性能、多用途方向发展；\n2.巨型机向更巨型化、超高速、并行处理、智能化方向发展。\n计算机硬件的基本组成 早期冯诺依曼机的结构 ENIAC：需要手动接线来控制计算，需要人工干预，影响计算速度\n冯诺依曼提出“存储程序”的概念：\n将指令以二进制代码的形式事先输入计算机的主存储器（内存），然后按其在存储器中的首地址执行程序的第一条指令，以后就按该程序规定的顺序执行其他指令，直至程序结束。\n第一台采用冯诺依曼结构的计算机：EDVAC（Electronic Discrete Variable Automatic Computer）。\n输入设备：将信息转换成机器能识别的形式；\n存储器：存放数据和程序；\n运算器：进行算术运算和逻辑运算；\n控制器：指挥程序运行；\n输出设备：将结果转换成人们熟悉的形式；\n在计算机系统中，软件和硬件在逻辑上是等效的；\n冯诺依曼计算机的特点：\n1.计算机由五大部件组成；\n2.指令和数据以同等地位存于存储器，可按地址寻访；\n3.指令和数据用二进制表示；\n4.指令有操作码和地址码组成；\n5.存储程序；\n6.以运算器为中心：输入/输出设备与存储器之间的数据传送通过运算器完成；\n现代计算机的结构 以存储器为中心\nCPU = 运算器 + 控制器\n计算机内各个硬件的工作原理 主存储器的基本组成 存储体：数据在存储体内按地址存储，存储体里有一个一个的存储单元，每个存储单元存放一串二进制代码；每个存储单元对应一个地址；\n存储字：存储单元中二进制代码的组合叫做存储字(word)；\n存储字长：存储单元中能够存放的二进制代码位数叫做存储字长，通常为8bit的整数倍；\n存储元：存储二进制的电子元件，每个存储元可存1bit；\nMAR：指明要访问的数据的地址，MAR位数反映存储单元的个数；\nMDR：存放存储单元中取出的数据/需要保存进存储单元的数据，因此MDR字长=存储字长；\n注：MAR，MDR在逻辑上属于主存的一部分，但现代计算机通常把MAR，MDR集成在CPU内。\n运算器的基本组成 运算器：用于实现算术运算（如：加减乘除）、逻辑运算（如：与或非）\nACC：累加器，用于存放操作数，或运算结果；\nMQ：乘商寄存器，在乘、除运算时，用于存放操作数或运算结果；\nX：通用的操作数寄存器，用于存放操作数；\nALU：算术逻辑单元，通过内部复杂的电路实现算术运算、逻辑运算；\n控制器的基本组成 CU：控制单元，分析指令，给出控制信号；\nIR：指令寄存器，存放当前执行的指令；\nPC：程序计数器，存放下一条指令的地址，有自动加1功能；\n计算机系统的层次结构 计算机的性能指标 存储器的性能指标 MAR位数反映存储单元的个数（最多支持多少个）；\nMDR位数 = 存储字长 = 每个存储单元的大小；\n总容量 = 存储单元个数 * 存储字长 bit\n​\t= 存储单元个数 * 存储字长 / 8 Byte\n1 GB = 1024 MB = 1024 * 1024 KB = 1024 * 1024 * 1024 Byte\n1 Byte = 8 bit\nCPU的性能指标 CPU时钟周期：每个脉冲信号的时间，单位：微秒、纳秒；\nCPU主频（时钟频率）= 1 / CPU时钟周期：CPU内数字脉冲信号振荡的频率，单位：Hz；\nCPI(Clock cycle Per Instruction)：执行一条指令所需的时钟周期数；不同的指令，CPI不同；相同的指令，CPI也可能有变化；\n执行一条指令的耗时 = CPI * CPU时钟周期；\nCPU执行时间（整个程序的耗时）= CPU时钟周期数 / 主频 = （指令条数 * CPI）/ 主频；\nIPS(Instruction Per Second) = 主频 / 平均CPI：每秒执行多少条指令；\nFLOPS(Floating-point Operations Per Seconds)：每秒执行所少次浮点运算；\n系统整体性能指标 数据通路带宽：数据总线一次所能并行传送信息的位数（各硬件部件通过数据总线传输数据）；\n吞吐量：系统在单位时间内处理请求的数量；\n响应时间：从用户向计算机发送一个请求，到系统对该请求作出响应并获得它所需要的结果的等待时间；\n","date":"2024-02-27T10:13:54+08:00","image":"https://chaihaojian.github.io/post/computer_composition_principles/chapter_1/cover_huc74df9617fcc19736cc959ce67738010_601682_120x120_fill_q75_box_smart1.JPG","permalink":"https://chaihaojian.github.io/post/computer_composition_principles/chapter_1/","title":"计算机系统概述"},{"content":"二叉搜索树 如果左子节点存在，则左子节点的值小于当前节点的值； 如果右子节点存在，则右子节点的值大于当前节点的值。 对于二叉搜索树中的一个节点，可以根据上述性质确定由根节点到该节点的路径。 1func getPath(root, target *TreeNode)(path []*TreeNode){ 2​\tnode := root 3​\tfor node != target { 4​\tpath = append(path, node) 5​\tif node.Val \u0026gt; target.Val { 6​\tnode = node.Left 7​\t}else { 8​\tnode = node.Right 9​\t} 10​\t} 11​\tpath = append(path, node) 12​\treturn 13} ","date":"2024-02-25T22:01:10+08:00","image":"https://chaihaojian.github.io/post/data_struct/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/cover_hua5b35af258670c5afa4b660f73f4647d_606953_120x120_fill_q75_box_smart1.JPG","permalink":"https://chaihaojian.github.io/post/data_struct/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/","title":"二叉搜索树"}]