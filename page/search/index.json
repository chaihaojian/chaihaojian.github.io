[{"content":"C++的编译 从源码到二进制 从 C++ 源代码到二进制可执行文件的构建过程通常分为以下几个阶段，每个阶段都有明确的任务和输出：\n1. 预处理（Preprocessing） 预处理阶段主要处理以 # 开头的预处理指令（如 #include、#define 等），生成一个纯粹的扩展代码文件。\n任务：\n替换头文件：#include 会用对应头文件的内容替换。 宏展开：#define 和 #undef 被解析。 条件编译：处理 #if、#ifdef 等预处理指令。 删除注释。 输入：源文件（.cpp、.h 等）。\n输出：预处理后的代码文件（通常是扩展的 .i 文件）。\n命令示例：\n1clang++ -E a.cpp -o a.i 2. 编译（Compilation） 编译阶段将预处理后的代码（.i 文件）转换为汇编代码（.s 文件），这是机器指令的可读表示形式。\n任务：\n将 C++ 源代码转换为汇编代码。 检查语法和语义错误。 优化代码（可选）。 输入：预处理后的文件（.i）。\n输出：汇编代码文件（.s）。\n命令示例：\n1clang++ -S a.i -o a.s 3. 汇编（Assembly） 汇编阶段将汇编代码（.s 文件）转换为机器代码的目标文件（.o 文件）。\n任务：\n使用汇编器将汇编代码转化为二进制形式的目标文件。 每个源文件生成一个独立的目标文件。 输入：汇编代码文件（.s）。\n输出：目标文件（.o）。\n命令示例：\n1clang++ -c a.s -o a.o 4. 链接（Linking） 链接阶段将多个目标文件（.o 文件）和依赖库合并，生成最终的可执行文件。\n任务：\n解决符号引用：找到各个目标文件中定义的函数或变量的地址。 合并目标文件：将多个 .o 文件链接到一起。 链接静态库和动态库：整合依赖的库文件。 输入：目标文件（.o 文件）和库文件（.a、.so）。\n输出：二进制可执行文件。\n命令示例：\n1clang++ a.o person.o -o my_program 5. 执行 最终生成的二进制文件可以在目标平台上运行。\n任务：\n加载程序到内存。 操作系统启动程序的执行。 命令示例：\n1./my_program ","date":"2024-12-17T21:19:10+08:00","image":"https://chaihaojian.github.io/cover.JPG","permalink":"https://chaihaojian.github.io/post/c_plus_note/chapter4_%E7%BC%96%E8%AF%91%E7%9B%B8%E5%85%B3/","title":"Chapter4_编译相关"},{"content":"C++提高 模板 C++的另一种编程思想称为范型编程，主要利用的技术就是模板 C++提供两种模板机制：函数模板与类模板 概念 函数模板 基本用法 函数模板的作用：\n建立一个通用函数，其函数返回值类型和形参类型可以不具体指定，用一个虚拟的类型来代表\n语法：\n1template\u0026lt;typename T\u0026gt;//!!!不加分号 2函数声明或定义 1//函数模板 2//考虑写一个两数交换的函数 3//两个函数的区别只在于参数的类型 逻辑则是相同的 4// void swapInt(int \u0026amp;a, int \u0026amp;b) 5// { 6// int temp = a; 7// a = b; 8// b = temp; 9// }; 10// void swapDouble(double \u0026amp;a, double \u0026amp;b) 11// { 12// double temp = a; 13// a = b; 14// b = temp; 15// }; 16 17//通过声明一个模版函数 让一个函数满足多种参数类型 18template\u0026lt;typename T\u0026gt; //表明T是一个未确定的数据类型 19void mySwap(T \u0026amp;a, T \u0026amp;b) 20{ 21 T temp = a; 22 a = b; 23 b = temp; 24}; 25 26int main() 27{ 28 int a = 10; 29 int b = 20; 30 double c = 1.1; 31 double d = 2.2; 32 33 //通过自动类型推导的方式使用模版函数 34 mySwap(a, b); 35 cout \u0026lt;\u0026lt; \u0026#34;a = \u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; 36 cout \u0026lt;\u0026lt; \u0026#34;b = \u0026#34; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; endl; 37 38 //通过显式声明参数类型使用模版函数 39 mySwap\u0026lt;double\u0026gt;(c, d); 40 cout \u0026lt;\u0026lt; \u0026#34;c = \u0026#34; \u0026lt;\u0026lt; c \u0026lt;\u0026lt; endl; 41 cout \u0026lt;\u0026lt; \u0026#34;d = \u0026#34; \u0026lt;\u0026lt; d \u0026lt;\u0026lt; endl; 42 43 return 0; 44}; 注意：\n自动类型推导，必须推导出一致的数据类型T，才可以使用 模版必须要确定出T的数据类型，才可以使用 函数模版案例 1//函数模版的案例 2//一个通用的选择排序模版 3template\u0026lt;typename T\u0026gt; 4void mySwap(T \u0026amp;a, T \u0026amp;b) 5{ 6 T temp = a; 7 a = b; 8 b = temp; 9}; 10 11template\u0026lt;typename T\u0026gt; 12void myPrint(T arr[], int len) 13{ 14 for (int i = 0; i \u0026lt; len; i++) 15 { 16 cout \u0026lt;\u0026lt; arr[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; 17 }; 18 cout \u0026lt;\u0026lt; endl; 19}; 20 21template\u0026lt;typename T\u0026gt; 22void mySort(T arr[], int len) 23{ 24 for (int i = 0; i \u0026lt; len; i++) 25 { 26 int maxIdx = i; 27 for (int j = i + 1; j \u0026lt; len; j++) 28 { 29 if (arr[maxIdx] \u0026lt; arr[j]) 30 { 31 maxIdx = j; 32 }; 33 }; 34 if (maxIdx != i) 35 { 36 mySwap(arr[i], arr[maxIdx]); 37 }; 38 }; 39}; 40 41int main() 42{ 43 int arr1[] = {2, 5, 1, 4, 9}; 44 mySort(arr1, sizeof(arr1) / sizeof(int)); 45 myPrint(arr1, sizeof(arr1) / sizeof(int)); 46 47 char arr2[] = \u0026#34;bhgksa\u0026#34;; 48 mySort(arr2, sizeof(arr2) / sizeof(char)); 49 myPrint(arr2, sizeof(arr2) / sizeof(char)); 50 51 return 0; 52}; 普通函数与模版函数的区别 普通函数调用时可以发生自动类型转换（隐式类型转换） 函数模版调用时，如果利用自动类型推导，不会发生隐式类型转换 如果模版函数调用时显式指定了参数类型，则可以发生类型转换 1//普通函数与模版函数的区别 2int myAdd01(int a, int b) 3{ 4 return a + b; 5}; 6 7template\u0026lt;typename T\u0026gt; 8T myAdd02(T a, T b) 9{ 10 return a + b; 11}; 12 13int main() 14{ 15 int a = 10; 16 int b = 20; 17 char c = \u0026#39;c\u0026#39;; 18 19 cout \u0026lt;\u0026lt; \u0026#34;myAdd01(a + b) = \u0026#34; \u0026lt;\u0026lt; myAdd01(a, b) \u0026lt;\u0026lt; endl; 20 cout \u0026lt;\u0026lt; \u0026#34;myAdd01(a + c) = \u0026#34; \u0026lt;\u0026lt; myAdd01(a, c) \u0026lt;\u0026lt; endl; 21 22 cout \u0026lt;\u0026lt; \u0026#34;myAdd02(a + b) = \u0026#34; \u0026lt;\u0026lt; myAdd02(a, b) \u0026lt;\u0026lt; endl; 23 //发生自动类型推导时 无法进行类型转换 24 //cout \u0026lt;\u0026lt; \u0026#34;myAdd02(a + c) = \u0026#34; \u0026lt;\u0026lt; myAdd02(a, c) \u0026lt;\u0026lt; endl; 25 cout \u0026lt;\u0026lt; \u0026#34;myAdd02(a + c) = \u0026#34; \u0026lt;\u0026lt; myAdd02\u0026lt;int\u0026gt;(a, c) \u0026lt;\u0026lt; endl; 26 return 0; 27}; 普通函数与函数模版的调用规则 调用规则：\n如果函数模版和普通函数都可以调用，优先调用普通函数 可以通过空模版参数列表来强制调用函数模版 函数模版可以发生重载 如果函数模版可以产生更好的匹配，则优先调用函数模版 1//普通函数与函数模版的调用规则 2void myPrint(int a, int b); 3void myPrint(int a, int b) 4{ 5 cout \u0026lt;\u0026lt; \u0026#34;普通函数调用\u0026#34; \u0026lt;\u0026lt; endl; 6}; 7 8template\u0026lt;typename T\u0026gt; 9void myPrint(T a, T b) 10{ 11 cout \u0026lt;\u0026lt; \u0026#34;函数模版调用\u0026#34; \u0026lt;\u0026lt; endl; 12}; 13 14//函数模版可以发生重载 15template\u0026lt;typename T\u0026gt; 16void myPrint(T a, T b, T c) 17{ 18 cout \u0026lt;\u0026lt; \u0026#34;重载的函数模版调用\u0026#34; \u0026lt;\u0026lt; endl; 19}; 20 21int main() 22{ 23 int a = 10; 24 int b = 20; 25 char c = \u0026#39;c\u0026#39;; 26 char d = \u0026#39;d\u0026#39;; 27 //此时调用的是普通函数 28 //但是当普通函数只是声明没有具体实现时，会报错 29 myPrint(a, b); 30 31 //通过空模版参数列表强制调用函数模版 32 myPrint\u0026lt;\u0026gt;(a, b); 33 //调用重载的函数模版 34 myPrint(a, b, 100); 35 36 //此时函数模版可以进行自动类型推导 推导出T为char类型 37 //而如果调用普通函数 则需要发生类型转换 38 //因此编译器认为函数模版产生了更好的匹配 39 myPrint(c, d); 40 return 0; 41} 模版的局限性 模版在一些特定的情况下无法正常使用：\n1template\u0026lt;typename T\u0026gt; 2void func(T a, Tb) 3{ 4 a = b; 5 if (a \u0026gt; b) 6 { 7 ... 8 }; 9}; 当 a 与 b 是数组时，无法进行赋值，或者当 a 与 b 是自定义数据类型时，无法进行比较\n因此，C++为了解决这种问题，提供模版的重载，可以**为这些特定的类型提供具体化的模版 **\n1//模版的局限性 2class Person 3{ 4public: 5 string Name; 6 int Age; 7 Person(string n, int a) 8 { 9 Name = n; 10 Age = a; 11 }; 12}; 13 14template\u0026lt;typename T\u0026gt; 15bool isEqual(T a, T b) 16{ 17 if (a == b) 18 { 19 return true; 20 }; 21 return false; 22}; 23 24//重载一个特定的能够比较Person类的isEqual函数 25bool isEqual(Person \u0026amp;p1, Person \u0026amp;p2) 26{ 27 if (p1.Name == p2.Name \u0026amp;\u0026amp; p1.Age == p2.Age) 28 { 29 return true; 30 }; 31 return false; 32}; 33 34int main() 35{ 36 int a = 10; 37 int b = 20; 38 Person p1(\u0026#34;Tom\u0026#34;, 18); 39 Person p2(\u0026#34;Jim\u0026#34;, 18); 40 cout \u0026lt;\u0026lt; isEqual(a, b) \u0026lt;\u0026lt; endl; 41 cout \u0026lt;\u0026lt; isEqual(p1, p2) \u0026lt;\u0026lt; endl; 42 return 0; 43}; 类模板 基本语法 类模板的作用：\n建立一个通用类，类中的成员数据类型可以不具体指定，用一个虚拟的类型来代表 语法：\n1template\u0026lt;class T\u0026gt; 2类 1//类模版基本用法 2template\u0026lt;class NameType, class AgeType\u0026gt; 3class Person 4{ 5public: 6 NameType Name; 7 AgeType Age; 8 Person(NameType n, AgeType a) 9 { 10 this-\u0026gt;Name = n; 11 this-\u0026gt;Age = a; 12 }; 13 void Show() 14 { 15 cout \u0026lt;\u0026lt; \u0026#34;Name: \u0026#34; \u0026lt;\u0026lt; this-\u0026gt;Name \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; \u0026#34;Age: \u0026#34; \u0026lt;\u0026lt; this-\u0026gt;Age \u0026lt;\u0026lt; endl; 16 }; 17}; 18 19int main() 20{ 21 Person\u0026lt;string, int\u0026gt; p(\u0026#34;Tom\u0026#34;, 18); 22 p.Show(); 23 return 0; 24}; 类模板与函数模板的区别 类模板与函数模板的区别主要有两点：\n类模板没有自动类型推导的使用方式，因此必须要显式指定参数类型 类模板在模板参数列表中可以有默认参数 1//类模板与函数模板的区别 2//template\u0026lt;class NameType, class AgeType\u0026gt; 3//类模板在声明时可以在参数列表中指定默认的参数类型 4template\u0026lt;class NameType = string, class AgeType = int\u0026gt; 5class Person 6{ 7public: 8 NameType Name; 9 AgeType Age; 10 Person(NameType n, AgeType a) 11 { 12 this-\u0026gt;Name = n; 13 this-\u0026gt;Age = a; 14 }; 15 void Show() 16 { 17 cout \u0026lt;\u0026lt; \u0026#34;Name: \u0026#34; \u0026lt;\u0026lt; this-\u0026gt;Name \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; \u0026#34;Age: \u0026#34; \u0026lt;\u0026lt; this-\u0026gt;Age \u0026lt;\u0026lt; endl; 18 }; 19}; 20 21int main() 22{ 23 //如果有默认参数类型 则可以不指定参数类型 24 //如果没有默认参数类型 由于类模板无法进行类型推导 因此会报错 25 Person\u0026lt;\u0026gt; p(\u0026#34;Tom\u0026#34;, 18); 26 p.Show(); 27 return 0; 28}; 类模板中成员函数的创建时机 类模板中成员函数和普通类中成员函数的创建时机是有区别的：\n普通类中的成员函数一开始就可以创建 类模板中的成员函数在调用时才创建 1//类模板中成员函数的创建时机 2class Person 3{ 4public: 5 void show() 6 { 7 8 }; 9}; 10 11template\u0026lt;class P\u0026gt; 12class myPerson 13{ 14public: 15 P obj; 16 void func() 17 { 18 obj.show(); 19 }; 20}; 21 22int main() 23{ 24 //myPerson\u0026lt;Person\u0026gt; p; 25 26 return 0; 27}; 上述代码可以编译成功，obj为未知类型P，上述代码中没有调用obj.show()，且编译成功，因此证明类模板中的成员函数时在调用时才创建\n类模板对象做函数参数 当类模板实例作为参数向函数传递时，一共有三种方法：\n指定传入的类型（最常用） 参数模板化 整个类模板化 1//类模板对象做函数参数 2template\u0026lt;class NameType, class AgeType\u0026gt; 3class Person 4{ 5public: 6 NameType Name; 7 AgeType Age; 8 Person(NameType n, AgeType a) 9 { 10 this-\u0026gt;Name = n; 11 this-\u0026gt;Age = a; 12 }; 13 void Show() 14 { 15 cout \u0026lt;\u0026lt; \u0026#34;Name: \u0026#34; \u0026lt;\u0026lt; this-\u0026gt;Name \u0026lt;\u0026lt; \u0026#34; Age: \u0026#34; \u0026lt;\u0026lt; this-\u0026gt;Age \u0026lt;\u0026lt;endl; 16 }; 17}; 18 19//方式一：指定传入的类型（最常用） 20void ShowPerson1(Person\u0026lt;string, int\u0026gt; \u0026amp;p) 21{ 22 p.Show(); 23}; 24 25//方式二：参数模板化（类模板与函数模板配合使用） 26template\u0026lt;typename NameType, typename AgeType\u0026gt; 27void ShowPerson2(Person\u0026lt;NameType, AgeType\u0026gt; \u0026amp;p) 28{ 29 p.Show(); 30}; 31 32//方式三：将整个类模板化（类模板与函数模板配合使用） 33template\u0026lt;typename PersonType\u0026gt; 34void ShowPerson3(PersonType \u0026amp;p) 35{ 36 p.Show(); 37}; 38 39 40int main() 41{ 42 Person\u0026lt;string, int\u0026gt; p(\u0026#34;Tom\u0026#34;, 18); 43 ShowPerson1(p); 44 ShowPerson2(p); 45 ShowPerson3(p); 46 return 0; 47}; 类模板与继承 当类模板碰到继承时，需要注意以下几点：\n当子类继承的父类是一个类模板时，子类在声明的时候，要指定父类中T的类型 如果不指定，编译器无法给子类分配内存 如果想要灵活的指定父类中T的类型，则需要将子类也声明成类模板 1//类模板与继承 2template\u0026lt;class T\u0026gt; 3class Base 4{ 5public: 6 T arg1; 7}; 8 9//子类在继承一个类模板时，需要指定父类中T的类型 10class Son1 : public Base\u0026lt;int\u0026gt; 11{ 12public: 13 int arg2; 14}; 15 16//或者可以将子类也声明为一个类模板 17//但仍需要指定将哪个类型参数作为父类中T的类型参数 18template\u0026lt;class T1, class T2\u0026gt; 19class Son2 : public Base\u0026lt;T2\u0026gt; //声明中的T2将作为父类中T的类型 20{ 21public: 22 T1 arg3; 23}; 24 25int main() 26{ 27 Son1 s1; 28 Son2\u0026lt;int, char\u0026gt; s2; 29 return 0; 30}; 类模板中成员函数的类外实现 类模板中成员函数在类外实现时，需要加上模板参数列表\n1//类模板中的成员函数的类外实现 2template\u0026lt;class NameType, class AgeType\u0026gt; 3class Person 4{ 5public: 6 NameType Name; 7 AgeType Age; 8 //类内声明 类外实现 9 Person(NameType n, AgeType a); 10 // { 11 // this-\u0026gt;Name = n; 12 // this-\u0026gt;Age = a; 13 // }; 14 void Show(); 15 // { 16 // cout \u0026lt;\u0026lt; \u0026#34;Name: \u0026#34; \u0026lt;\u0026lt; this-\u0026gt;Name \u0026lt;\u0026lt; \u0026#34; Age: \u0026#34; \u0026lt;\u0026lt; this-\u0026gt;Age \u0026lt;\u0026lt; endl; 17 // }; 18}; 19 20//构造函数的类外实现 21template\u0026lt;typename NameType, typename AgeType\u0026gt; 22Person\u0026lt;NameType, AgeType\u0026gt;::Person(NameType n, AgeType a) 23{ 24 this-\u0026gt;Name = n; 25 this-\u0026gt;Age = a; 26}; 27 28//普通成员函数的类外实现 29template\u0026lt;typename NameType, typename AgeType\u0026gt; 30void Person\u0026lt;NameType, AgeType\u0026gt;::Show() 31{ 32 cout \u0026lt;\u0026lt; \u0026#34;Name: \u0026#34; \u0026lt;\u0026lt; this-\u0026gt;Name \u0026lt;\u0026lt; \u0026#34; Age: \u0026#34; \u0026lt;\u0026lt; this-\u0026gt;Age \u0026lt;\u0026lt; endl; 33}; 34 35int main() 36{ 37 Person\u0026lt;string, int\u0026gt; p(\u0026#34;Tom\u0026#34;, 18); 38 p.Show(); 39 return 0; 40}; 类模板分文件编写 问题：\n类模板中的成员函数是在调用阶段再创建的，因此会导致分文件编写时链接不到 1#include \u0026lt;iostream\u0026gt; 2#include \u0026lt;string\u0026gt; 3#include \u0026lt;unistd.h\u0026gt; 4using namespace std; 5 6template\u0026lt;class NameType, class AgeType\u0026gt; 7class Person 8{ 9public: 10 NameType Name; 11 AgeType Age; 12 Person(NameType n, AgeType a); 13 void Show(); 14}; 15 16template\u0026lt;typename NameType, typename AgeType\u0026gt; 17Person\u0026lt;NameType, AgeType\u0026gt;::Person(NameType n, AgeType a) 18{ 19 this-\u0026gt;Name = n; 20 this-\u0026gt;Age = a; 21}; 22 23template\u0026lt;typename NameType, typename AgeType\u0026gt; 24void Person\u0026lt;NameType, AgeType\u0026gt;::Show() 25{ 26 cout \u0026lt;\u0026lt; \u0026#34;Name: \u0026#34; \u0026lt;\u0026lt; this-\u0026gt;Name \u0026lt;\u0026lt; \u0026#34; Age: \u0026#34; \u0026lt;\u0026lt; this-\u0026gt;Age \u0026lt;\u0026lt; endl; 27}; 28 29int main() 30{ 31 Person\u0026lt;string, int\u0026gt; p(\u0026#34;Tom\u0026#34;, 18); 32 p.Show(); 33 return 0; 34}; 上述代码可以分文件编写为：\n./inc/person.h\n1#pragma once 2#include \u0026lt;iostream\u0026gt; 3#include \u0026lt;string\u0026gt; 4using namespace std; 5 6template\u0026lt;class NameType, class AgeType\u0026gt; 7class Person 8{ 9public: 10 NameType Name; 11 AgeType Age; 12 Person(NameType n, AgeType a); 13 void Show(); 14}; ./src/chap3/person.cpp\n1#include \u0026#34;../../inc/person.h\u0026#34; 2 3template\u0026lt;typename NameType, typename AgeType\u0026gt; 4Person\u0026lt;NameType, AgeType\u0026gt;::Person(NameType n, AgeType a) 5{ 6 this-\u0026gt;Name = n; 7 this-\u0026gt;Age = a; 8}; 9 10template\u0026lt;typename NameType, typename AgeType\u0026gt; 11void Person\u0026lt;NameType, AgeType\u0026gt;::Show() 12{ 13 cout \u0026lt;\u0026lt; \u0026#34;Name: \u0026#34; \u0026lt;\u0026lt; this-\u0026gt;Name \u0026lt;\u0026lt; \u0026#34; Age: \u0026#34; \u0026lt;\u0026lt; this-\u0026gt;Age \u0026lt;\u0026lt; endl; 14}; ./src/chap3/main.cpp\n1#include \u0026lt;iostream\u0026gt; 2#include \u0026lt;string\u0026gt; 3#include \u0026lt;unistd.h\u0026gt; 4#include \u0026#34;../../inc/person.h\u0026#34; 5using namespace std; 6 7int main() 8{ 9 //将下面两行代码注释掉 会成功完成编译 10 //因为类模板成员函数只在调用时才创建 11 Person\u0026lt;string, int\u0026gt; p(\u0026#34;Tom\u0026#34;, 18); 12 p.Show(); 13 return 0; 14}; 编译上述3个文件：\nclang++ main.cpp person.cpp -o ../../target/main\n会产生如下报错：\n产生错误的原因分析：\n预处理阶段，main.cpp 中的 #include \u0026quot;../../inc/person.h\u0026quot;会被对应的 person.h文件替换，\n同时person.cpp 中的 #include \u0026quot;../../inc/person.h\u0026quot;也会被 person.h文件替换，\n生成main.i和person.i文件\n编译阶段，将main.cpp和person.cpp分别编译成汇编代码文件，\n生成main.s和person.s文件\n汇编阶段，将main.cpp和person.cpp对应的汇编代码文件转化为二进制文件，\n生成main.o和person.o文件\n链接阶段，将汇编阶段产生的两个二进制文件合并，找到各个目标文件中定义的函数或变量的地址，\n具体到上述案例中则为：链接器需要在person.o中找到main.o中Person\u0026lt;string, int\u0026gt; p(\u0026quot;Tom\u0026quot;, 18)的具体实现，即在person.o中找到Person\u0026lt;string, int\u0026gt;这一具体的类所对应的构造函数，而事实上，由于在person.cpp文件中，并没有实例化Person\u0026lt;string, int\u0026gt;这一个具体的类，因此也不会实例化该类对应的构造函数，因此链接器在person.o中无法找到main.o中Person\u0026lt;string, int\u0026gt; p(\u0026quot;Tom\u0026quot;, 18)的具体实现，void Person\u0026lt;string, int\u0026gt;::show()也是同理。\n总结：类模板的分文件编写，导致具体声明的模板类没有完成实例化，从而导致链接错误。\n解决方式：\n方式一：直接包含.cpp源文件\n1#include \u0026lt;iostream\u0026gt; 2#include \u0026lt;string\u0026gt; 3#include \u0026#34;person.cpp\u0026#34; 4using namespace std; 5 6int main() 7{ 8 Person\u0026lt;string, int\u0026gt; p(\u0026#34;Tom\u0026#34;, 18); 9 p.Show(); 10 return 0; 11}; 方式二：将声明和实现写到同一个文件中，并更改后缀名为.hpp，.hpp是约定的名称，并不是强制\nperson.hpp\n1#pragma once 2#include \u0026lt;iostream\u0026gt; 3#include \u0026lt;string\u0026gt; 4using namespace std; 5 6template\u0026lt;class NameType, class AgeType\u0026gt; 7class Person 8{ 9public: 10 NameType Name; 11 AgeType Age; 12 Person(NameType n, AgeType a); 13 void Show(); 14}; 15 16template\u0026lt;typename NameType, typename AgeType\u0026gt; 17Person\u0026lt;NameType, AgeType\u0026gt;::Person(NameType n, AgeType a) 18{ 19 this-\u0026gt;Name = n; 20 this-\u0026gt;Age = a; 21}; 22 23template\u0026lt;typename NameType, typename AgeType\u0026gt; 24void Person\u0026lt;NameType, AgeType\u0026gt;::Show() 25{ 26 cout \u0026lt;\u0026lt; \u0026#34;Name: \u0026#34; \u0026lt;\u0026lt; this-\u0026gt;Name \u0026lt;\u0026lt; \u0026#34; Age: \u0026#34; \u0026lt;\u0026lt; this-\u0026gt;Age \u0026lt;\u0026lt; endl; 27}; main.cpp\n1#include \u0026lt;iostream\u0026gt; 2#include \u0026lt;string\u0026gt; 3#include \u0026#34;person.hpp\u0026#34; 4using namespace std; 5 6int main() 7{ 8 Person\u0026lt;string, int\u0026gt; p(\u0026#34;Tom\u0026#34;, 18); 9 p.Show(); 10 return 0; 11}; 方式三：显示实例化模板，在类模板定义的.cpp文件中显式实例化所需的模板类型\nperson.cpp\n1#include \u0026#34;../../inc/person.h\u0026#34; 2 3template\u0026lt;typename NameType, typename AgeType\u0026gt; 4Person\u0026lt;NameType, AgeType\u0026gt;::Person(NameType n, AgeType a) 5{ 6 this-\u0026gt;Name = n; 7 this-\u0026gt;Age = a; 8}; 9 10template\u0026lt;typename NameType, typename AgeType\u0026gt; 11void Person\u0026lt;NameType, AgeType\u0026gt;::Show() 12{ 13 cout \u0026lt;\u0026lt; \u0026#34;Name: \u0026#34; \u0026lt;\u0026lt; this-\u0026gt;Name \u0026lt;\u0026lt; \u0026#34; Age: \u0026#34; \u0026lt;\u0026lt; this-\u0026gt;Age \u0026lt;\u0026lt; endl; 14}; 15 16//显式实例化所需的模板类型 17template class Person\u0026lt;string, int\u0026gt;; 类模板与友元 ","date":"2024-12-14T22:59:41+08:00","image":"https://chaihaojian.github.io/post/c_plus_note/chapter3_%E6%8F%90%E9%AB%98/cover_huae254b8ee1ab91911036d94a912fa4f7_868221_120x120_fill_q75_box_smart1.JPG","permalink":"https://chaihaojian.github.io/post/c_plus_note/chapter3_%E6%8F%90%E9%AB%98/","title":"C++提高"},{"content":"数据的表示和运算 数制与编码 进位计数制 r进制计数法 二进制 \u0026lt;\u0026ndash;\u0026gt; 八进制 二进制中的三位数正好可以表示八进制中的一位数\n3位一组，每组转换成对应的8进制符号；首尾如果不足3位，则用0补全\n同理，八进制中的一位数对应二进制中的3位数\n二进制 \u0026lt;\u0026ndash;\u0026gt; 十六进制 二进制中的四位数正好可以表示十六进制中的一位数\n4位一组，每组转换成对应的十六进制符号，首尾如果不足3位，则用0补全\n同理，十六进制中的一位数对应二进制中的4位数\n十进制 \u0026ndash;\u0026gt; 任意进制 上述小数部分的0.3在转换成二进制时会无限循环下去，表明十进制中的0.3无法在二进制中精确表示\n真值和机器数 真值：符合人类习惯的数字，如：2，5，-3，-11\n机器数：数字实际存储到机器里的形式，正负号需要被数字化，在数字开头加 ‘0‘ 或 ’1’ 来表示正负\nBCD码 BCD：Binary-Coded Decimal，用二进制编码的十进制\n8421码 考虑用四个二进制位表示十进制中的0～9\n四个二进制位一共能表示16种状态，十进制0～9表示10种状态，因此这种表示会产生6种冗余状态，需要舍弃\n上述计算结果 13 (1101) 恰好处在8421码需要舍弃的6种状态中，因此通过加 6 (0110) 来剔除这六种冗余，从而得到十进制数13的正确8421码表示\n由于四个二进制码可以表示16种不同的状态，因此在表示十进制中的0～9时，可以产生不同的映射方案\n余3码：8421码 + (0011)2 特点：8421码中，四个二进制位都有其固定的权值，分别为 8 - 4 - 2 - 1，但在余3码中，四个二进制位没有其固定的权值\n2421码：将四个二进制位的权值变为 2 - 4 - 2 - 1 特点：十进制中的4～9在2421码中会有多种编码方式，因此规定在表示5～9时，第一个二进制位即最高位必须是1\n无符号整数的表示和运算 无符号整数的表示 无符号整数的加法运算 从最低位开始，按位相加，并往更高位进位\n无符号整数的减法 运算 被减数不变，减数全部按位取反、末位+1，减法变加法\n带符号整数的表示和运算 带符号整数的原码表示 带符号整数的运算 原码的缺点：由于符号位不能直接参与运算，无法通过两个数的原码直接相加得到正确结果，需要用复杂的电路才能处理\n使用补码可以解决上述问题\n对于计算机，通过将补码的数值位取反，然后末位+1，得到原码（负数）\n原码/反码/补码的特性 带符号整数的移码表示 定点小数 原码表示 定点小数的原/反/补码的转换 定点小数的加/减运算 对定点小数做加/减运算时，需要先转换为补码\n加法：从最低位开始，按位相加（符号位参与运算），并往更高位进位 减法：被减数不变，减数全部按位取反、末位+1，减法变加法 ","date":"2024-07-18T10:08:09+08:00","image":"https://chaihaojian.github.io/post/computer_composition_principles/chapter_2/cover_huc74df9617fcc19736cc959ce67738010_601682_120x120_fill_q75_box_smart1.JPG","permalink":"https://chaihaojian.github.io/post/computer_composition_principles/chapter_2/","title":"数据的表示和运算"},{"content":"数组 数组是多个变量值的集合，数组是Array对象的实例，因此数组可以调用方法\n数组是一个引用类型\n数组的声明 创建数组 1//使用对象方式创建数组 2let arr1 = new Array(1, \u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;); 3console.log(arr1); 4//使用字面量创建数组 推荐做法 5let arr2 = [2, \u0026#34;你好\u0026#34;, \u0026#34;世界\u0026#34;]; 6console.log(arr2); 7//多维数组创建 8let arr3 = [[1, \u0026#34;Tom\u0026#34;],[2, \u0026#34;Mike\u0026#34;, \u0026#34;boy\u0026#34;]]; 9console.log(arr3); 数组是引用类型 数组类型有length属性 数组可以设置任何值 若直接设置一个数组的第三个值，会将该数组的第一、第二个值设置为空值 使用Array.of创建数组 使用Array.of与new Array不同是设置只有一个元素的数组时不会创建空元素数组\n1let arr4 = Array.of(3); 2console.log(arr4); 3let arr5 = Array.of(1, 2, 3); 4console.log(arr5); 5 6let arr6 = new Array(3); 7console.log(arr6); ![Image 1](chap4_ 1.png)\n类型检测 检测变量是否为数组类型\n1console.log(Array.isArray([1, 2, 3])); 2console.log(Array.isArray(3)); ![Image 2](chap4_ 2.png)\n类型转换 可以将数组转换为字符串，也可以将其他类型转换为数组\n将数组转换为字符串 1//可以使用.toString()函数转换为字符串 2console.log(([1, 2, 3]).toString()); 3//可以使用函数String转换为字符串 4console.log(String([1, 2, 3])); 5//使用join连接为字符串 6console.log([1,2,3].join(\u0026#34;-\u0026#34;)); ![Image 3](chap4_ 3.png)\nArray.from 使用Array.from可以将类数组转换为数组，类数组指包含length属性或可迭代的对象\nArray.from()包含两个参数，第一个参数为要转换的数据，第二个参数为类似于map函数的回调方法\n1\u0026lt;body\u0026gt; 2 \u0026lt;button message=\u0026#34;hello\u0026#34;\u0026gt;\u0026lt;/button\u0026gt; 3\u0026lt;button message=\u0026#34;world\u0026#34;\u0026gt;\u0026lt;/button\u0026gt; 4\u0026lt;script\u0026gt; 5 //Array.from 将类数组转换为数组 6 //Array.from()包含两个参数 第一个为需要转换的数据 第二个为一个类似map函数的回调 7 let str = \u0026#34;hello world\u0026#34;; 8\tconsole.log(Array.from(str)) 9 10\t//为对象设置 length 属性后也可以转换为数组 但属性字段名要为数值或数值字符串 11\t//如果字段名是其它 该字段的值将不会被转换 12\tlet user = { 13 0: \u0026#34;hello\u0026#34;, 14 name: \u0026#34;tom\u0026#34;, 15 \u0026#34;1\u0026#34;: 18, 16 length: 2 17\t}; 18\tconsole.log(Array.from(user)); 19 20\t//获取DOM元素将其转换为数组 通过Array.from()的第二个参数 对DOM元素进行操作 21\tlet btns = document.querySelectorAll(\u0026#39;button\u0026#39;); 22\tconsole.log(btns); 23\tArray.from(btns, (item) =\u0026gt; { 24 item.style.background = \u0026#39;red\u0026#39;; 25\t}); 26\u0026lt;/script\u0026gt; 27\u0026lt;/body\u0026gt; ![Image 4](chap4_ 4.png)\n展开语法 展开语法将NodeList类型的数据转换为数组\n1\u0026lt;style\u0026gt; 2 .hide { 3 display: none; 4 } 5\u0026lt;/style\u0026gt; 6 7\u0026lt;body\u0026gt; 8 \u0026lt;div\u0026gt;hdcms\u0026lt;/div\u0026gt; 9\u0026lt;div\u0026gt;houdunren\u0026lt;/div\u0026gt; 10\u0026lt;/body\u0026gt; 11 12\u0026lt;script\u0026gt; 13 let divs = document.querySelectorAll(\u0026#34;div\u0026#34;); 14[...divs].map(function(div) {//[...divs] 展开语法 15 div.addEventListener(\u0026#34;click\u0026#34;, function() { 16 this.classList.toggle(\u0026#34;hide\u0026#34;); 17 }); 18}); 19\u0026lt;/script\u0026gt; 展开语法 数组合并 可以使用展开语法合并数组，使用\u0026hellip;可将数组展开为多个值\n1//展开语法合并数组 2let a = [1, 2, 3]; 3let b = [\u0026#39;a\u0026#39;, \u0026#39;hello\u0026#39;, ...a]; 4console.log(b); 5 6//也可以使用concat方法合并 7let c = [1, 2, 3]; 8let d = a.concat([\u0026#39;a\u0026#39;, \u0026#39;hello\u0026#39;]); 9console.log(d); ![Image 5](chap4_ 5.png)\n在函数中使用展开语法 在函数参数列表中使用展开语法，来接受任意数量的参数\n1//在函数参数列表中使用展开语法 2function test1(...args) { 3 console.log(args); 4} 5test1(1, 2, 3, \u0026#39;a\u0026#39;, \u0026#39;hello\u0026#39;); 6//也可以接受部分参数 7function test2(idx, ...args) { 8 console.log(idx, args); 9} 10test2(\u0026#39;idx000\u0026#39;, 1, 2, 3, \u0026#39;a\u0026#39;, \u0026#39;hello\u0026#39;); ![Image 6](chap4_ 6.png)\n解构赋值 解构是一种更简洁的赋值特性，可以理解为分解一个数据的结构\n1//解构赋值 2let [name, age] = [\u0026#39;Tom\u0026#39;, 18]; 3console.log(name, age); 4 5function test1() { 6 return [\u0026#39;Miki\u0026#39;, 22]; 7}; 8let [a, b] = test1(); 9console.log(a, b); 10 11//剩余结构 通过展开语法 用一个变量来接受剩余参数 12let [c, ...d] = [\u0026#39;idx000\u0026#39;, 1, 2, \u0026#39;hello\u0026#39;]; 13console.log(c, d); 14 15//只赋值部分变量 16let [, n] = [\u0026#39;joe\u0026#39;, 23]; 17console.log(n); ![Image 7](chap4_ 7.png)\n管理数组中的元素 基本用法 数组的索引从0开始 可以通过索引改变数组 也可以向数组追加元素\n1//通过索引修改元素 2let arr = [1, \u0026#39;hello\u0026#39;, \u0026#39;world\u0026#39;]; 3arr[1] = \u0026#39;hi\u0026#39;; 4console.log(arr); 5//向数组追加元素 6arr[arr.length] = \u0026#39;Tom\u0026#39;; 7console.log(arr); ![Image 8](chap4_ 8.png)\n扩展语法 使用展开语法批量向数组追加元素\n1//使用展开语法批量追加元素 2let arr1 = [\u0026#39;hello\u0026#39;, \u0026#39;world\u0026#39;]; 3let arr2 = [\u0026#39;hi\u0026#39;, 18]; 4arr1.push(...arr2); 5console.log(arr1); ![Image 9](chap4_ 9.png)\npush()方法 将元素压入数组，直接改变元数组，返回值为数组元素数量\n1//push()方法 2let arr = [1, \u0026#39;hello\u0026#39;, \u0026#39;world\u0026#39;]; 3console.log(arr.push(\u0026#39;Tom\u0026#39;, 22)); 4console.log(arr); ![Image 10](chap4_ 10.png)\npop()方法 从数组的末尾弹出元素，直接改变元数组，返回值为弹出的元素\n1//pop()方法 2let arr = [1, \u0026#39;hello\u0026#39;, \u0026#39;world\u0026#39;]; 3console.log(arr.pop()); 4console.log(arr); ![Image 11](chap4_ 11.png)\nshift()方法 从数组头部取出一个元素\n1//shift()方法 2let arr = [1, \u0026#39;hello\u0026#39;, \u0026#39;world\u0026#39;]; 3console.log(arr.shift()); 4console.log(arr); ![Image 12](chap4_ 12.png)\nunshift()方法 从数组的头部添加元素\n1//unshift()方法 2let arr = [1, \u0026#39;hello\u0026#39;, \u0026#39;world\u0026#39;]; 3console.log(arr.unshift(\u0026#39;hi\u0026#39;)); 4console.log(arr); ![Image 13](chap4_ 13.png)\nfill()方法 使用fill填充数组元素\n1//fill()方法 2//填充数组 3console.log(Array(4).fill(\u0026#39;hello\u0026#39;)); 4//指定填充位置 5console.log([1, 2, 3, 4].fill(\u0026#39;hello\u0026#39;, 1, 3)); ![Image 14](chap4_ 14.png)\nslice()方法 使用slice方法从数组中截取部分元素组合成新数组（并不会改变原数组），不传第二个参数时，截取到数组的最后元素\n1//slice()方法 2let arr = [0, 1, 2, 3, 4, 5, 6]; 3console.log(arr.slice(1, 3)); 4console.log(arr.slice(2)); 5console.log(arr.slice()); ![Image 15](chap4_ 15.png)\nsplice()方法 使用splice方法可以添加、删除、替换数组中的元素，会对原数组造成改变，返回值为删除的元素\n1let arr = [0, 1, 2, 3, 4, 5, 6]; 2console.log(arr.slice(1, 3)); 3console.log(arr.slice(2)); 4console.log(arr.slice()); 清空数组 将数组指修改为 [] 即可清空数组，如果有多个引用时\n1let user = [{name:\u0026#34;tom\u0026#34;}, {name:\u0026#34;jim\u0026#34;}]; 2let person = user; 3user = []; 4console.log(user); 5console.log(person); ![Image 16](chap4_ 16.png)\n将数组的 length 属性设置为0也可以清空数组\n1let user = [{name:\u0026#34;tom\u0026#34;}, {name:\u0026#34;jim\u0026#34;}]; 2user.length = 0; 3console.log(user); ![Image 17](chap4_ 17.png)\n使用 splice 方法删除所有元素\n1let user = [{name:\u0026#34;tom\u0026#34;}, {name:\u0026#34;jim\u0026#34;}]; 2user.splice(0, user.length); 3console.log(user); ![Image 18](chap4_ 18.png)\n使用 pop/shift 删除所有元素来清空数组\n1let user =[{name:\u0026#34;tom\u0026#34;}, {name:\u0026#34;jim\u0026#34;}]; 2while (user.pop()){}; 3console.log(user); ![Image 19](chap4_ 19.png)\n合并拆分 join 使用 join 将数组元素连接成字符串\n1let arr = [1, \u0026#34;hello\u0026#34;, \u0026#34;tim\u0026#34;]; 2console.log(arr.join(\u0026#39;-\u0026#39;)) ![Image 20](chap4_ 20.png)\nsplit split 方法用于将字符串分割成数组，类似 join 方法的反函数\n1let score = \u0026#34;99,98,78\u0026#34;; 2console.log(score.split(\u0026#34;,\u0026#34;)); ![Image 21](chap4_ 21.png)\nconcat concat 方法用于连接两个或多个数组，元素是值类型的是复制操作，如果是引用类型还是指向同一对象\n1let arr0 = [\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;]; 2let arr1 = [1, 2]; 3let arr2 = [{name: \u0026#34;tom\u0026#34;}, {name: \u0026#34;jim\u0026#34;}]; 4arr1[0] = 3; 5console.log(arr0.concat(arr1, arr2)); 6//arr1中的元素是值类型 而arr2中的元素是引用类型 7arr1[1] = 4; 8arr2[1].name = \u0026#34;mike\u0026#34;; ![Image 22](chap4_ 22.png)\n也可以使用展开语法实现数组连接\n1let arr0 = [\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;]; 2let arr1 = [1, 2]; 3let arr2 = [{name: \u0026#34;tom\u0026#34;}, {name: \u0026#34;jim\u0026#34;}]; 4console.log([...arr0, ...arr1, ...arr2]); ![Image 23](chap4_ 23.png)\ncopyWithin 使用 copyWithin 方法从数组中复制一部分到同数组中的另外位置\n1//array.copyWithin(target, start, end); 2//target: 必需，复制到指定目标索引位置 3//start: 可选，元素复制的起始位置 4//end: 可选，停止复制的索引位置，默认为array.length，负值表示倒数 5const arr = [1, 2, 3, 4]; 6console.log(arr.copyWithin(2, 0, 2)); ![Image 24](chap4_ 24.png)\n查找元素 indexOf 使用 indexOf 方法从前向后查找元素出现的位置，如果找不到返回 -1\n","date":"2024-04-14T21:37:25+08:00","image":"https://chaihaojian.github.io/post/javascript_note/%E6%95%B0%E7%BB%84/cover_hu7c4cdf01cea81a03b0eb35f8c46fc90c_1264985_120x120_fill_q75_box_smart1.JPG","permalink":"https://chaihaojian.github.io/post/javascript_note/%E6%95%B0%E7%BB%84/","title":"数组"},{"content":"C++ 核心编程 内存分区模型 c++程序在执行时，将内存大方向划分为4个区域\n代码区：存放函数体的二进制代码，由操作系统进行管理 全局区：存放全局变量和静态变量以及常量 栈区：由编译器自动分配释放，存放函数的参数值、局部变量等 堆区：由程序员分配和释放，若程序员不释放，程序结束时由操作系统回收 内存四区的意义\n不同区域存放的数据，赋予不同的生命周期，给我们更大的灵活编程\n程序运行前 在程序编译后，生成了exe可执行程序，未执行该程序前分为两个区域\n代码区\n存放CPU执行的机器指令\n代码区是共享的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可\n代码区是只读 的，使其只读的原因是防止程序意外的修改了它的指令\n全局区\n全局变量和静态变量存放在此 全局区还包含了常量区，字符串常量和其他常量也存放在此 该区域的数据在程序结束后由操作系统释放 1//全局变量 2int g_a = 10; 3//全局常量 4const int g_c_a = 10; 5 6int main() 7{ 8 //普通局部变量 9 int a = 10; 10 //const 修饰的局部变量 11 const int l_c_a = 10; 12 cout \u0026lt;\u0026lt; \u0026#34;address of l_c_a: \u0026#34; \u0026lt;\u0026lt; \u0026amp;l_c_a \u0026lt;\u0026lt;endl; 13 //静态变量 14 static int s_a = 10; 15 cout \u0026lt;\u0026lt; \u0026#34;address of a: \u0026#34; \u0026lt;\u0026lt; \u0026amp;a \u0026lt;\u0026lt;endl; 16 cout \u0026lt;\u0026lt; \u0026#34;address of g_a: \u0026#34; \u0026lt;\u0026lt; \u0026amp;g_a \u0026lt;\u0026lt;endl; 17 cout \u0026lt;\u0026lt; \u0026#34;address of s_a: \u0026#34; \u0026lt;\u0026lt; \u0026amp;s_a \u0026lt;\u0026lt;endl; 18 cout \u0026lt;\u0026lt; \u0026#34;address of g_c_a: \u0026#34; \u0026lt;\u0026lt; \u0026amp;g_c_a \u0026lt;\u0026lt;endl; 19 //常量 20 //字符串常量 21 cout \u0026lt;\u0026lt; \u0026#34;address of str: \u0026#34; \u0026lt;\u0026lt; \u0026amp;\u0026#34;world\u0026#34; \u0026lt;\u0026lt;endl; 22 23 return 0; 24} 程序运行后 栈区\n由编译器自动分配释放，存放函数的参数值，局部变量等 注意：不要返回局部变量的地址，栈区开辟的数据由编译器自动释放 1int* func()//如果函数有形参 形参数据也会存放在栈区 2{ 3 int a = 10;//局部变量 存放在栈区 4 return \u0026amp;a; 5}; 6 7int main() 8{ 9 int * p = func(); 10 cout \u0026lt;\u0026lt; *p \u0026lt;\u0026lt; endl;//第一次输出正常 是因为C++编译器会做一次保留 11 cout \u0026lt;\u0026lt; *p \u0026lt;\u0026lt; endl;//第二次访问该地址时 因为编译器已经将内存释放 所以拿到的值不是10 12 13 return 0; 14} 堆区\n由程序员分配释放，若程序员不释放，程序结束时由操作系统回收 在C++中主要利用new在堆区开辟内存 1int* func() 2{ 3 //使用new创建的数据存放在堆区 但是指针变量p的值存放在栈区 因为p是一个局部变量 4 int * p = new int(10);//使用new创建的数据存放在堆区 返回该数据的地址 5 return p; 6}; 7 8int main() 9{ 10 int * p = func();//指针p存的地址在堆区 因此该地址中的数据不会被自动释放 11 cout \u0026lt;\u0026lt; *p \u0026lt;\u0026lt; endl; 12 cout \u0026lt;\u0026lt; *p \u0026lt;\u0026lt; endl; 13 14 return 0; 15} new 操作符 C++中使用new操作符在堆区开辟数据 堆区开辟的数据，由程序员手动开辟，手动释放，释放利用操作符delete 语法：new 数据类型 利用new创建的数据，会返回该数据对应的类型的指针 使用new在堆区创建一个数组\n1void CreateArr() 2{ 3 int * arr = new int[5]; 4 for (int i = 0; i \u0026lt; 5; i++) 5 { 6 arr[i] = i + 10; 7 } 8 for (int i = 0; i \u0026lt; 5; i++) 9 { 10 cout \u0026lt;\u0026lt; arr[i] \u0026lt;\u0026lt; endl; 11 } 12 delete[] arr;//delete[] 告诉编译器释放的内存中是存储的是一个数组 13 for (int i = 0; i \u0026lt; 5; i++) 14 { 15 cout \u0026lt;\u0026lt; arr[i] \u0026lt;\u0026lt; endl; 16 } 17}; 18 19int main() 20{ 21 CreateArr(); 22 23 return 0; 24} 引用 引用的基本使用 **作用：**给变量起别名\n**语法：**数据类型 \u0026amp;别名 = 原名\n1int main() 2{ 3 int a = 10; 4 int \u0026amp;b = a; 5 6 cout \u0026lt;\u0026lt; \u0026#34;a: \u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; 7 cout \u0026lt;\u0026lt; \u0026#34;b: \u0026#34; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; endl; 8 9 b = 100; 10 cout \u0026lt;\u0026lt; \u0026#34;a: \u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; 11 cout \u0026lt;\u0026lt; \u0026#34;b: \u0026#34; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; endl; 12 return 0; 13} 引用的注意事项 引用必须初始化 引用在初始化后，不可以改变 1int main() 2{ 3 int a = 10; 4 //int \u0026amp;b;\t//只声明不初始化会报错 声明的引用必须要初始化 5 int \u0026amp;b = a; 6 int c = 20; 7 cout \u0026lt;\u0026lt; \u0026#34;a:\u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#34; b:\u0026#34; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; \u0026#34; c:\u0026#34; \u0026lt;\u0026lt; c \u0026lt;\u0026lt; endl; 8 //引用在初始化后 不可以改变 9 b = c;//赋值操作，而不是更改引用 10 cout \u0026lt;\u0026lt; \u0026#34;a:\u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#34; b:\u0026#34; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; \u0026#34; c:\u0026#34; \u0026lt;\u0026lt; c \u0026lt;\u0026lt; endl; 11 return 0; 12} 引用做函数参数 作用：函数传参时，可以利用引用的技术让形参修饰实参\n优点：可以简化指针修改实参\n1void swap(int \u0026amp;a, int \u0026amp;b) 2{ 3 int temp = a; 4 a = b; 5 b = temp; 6} 7 8int main() 9{ 10 int a = 10; 11 int b = 20; 12 swap(a, b);//引用传递 形参会修饰实参 13 cout \u0026lt;\u0026lt; \u0026#34;a = \u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#34; b = \u0026#34; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; endl; 14 return 0; 15} 引用做函数返回值 注意：\n不要返回局部变量的引用 1int\u0026amp; func() 2{ 3 int a = 100;//a是局部变量 存放在栈区 4 return a; 5}; 6 7int main() 8{ 9 int \u0026amp;p = func(); 10 cout \u0026lt;\u0026lt; p \u0026lt;\u0026lt; endl;//编译器会对栈区数据做一次保留 因此第一次cout正常 11 cout \u0026lt;\u0026lt; p \u0026lt;\u0026lt; endl;//第二次cout输出的才是内存地址a中的数据 已经被编译器释放 12 13 return 0; 14} 函数的调用可以作为左值 1int\u0026amp; func() 2{ 3 static int a = 100;//a是静态变量 存放在全局区 4 return a; 5}; 6 7int main() 8{ 9 int \u0026amp;p = func(); 10 cout \u0026lt;\u0026lt; p \u0026lt;\u0026lt; endl; 11 cout \u0026lt;\u0026lt; p \u0026lt;\u0026lt; endl; 12 13 func() = 1000;//如果函数的返回值是引用，则这个函数调用可以用作左值 14 cout \u0026lt;\u0026lt; p \u0026lt;\u0026lt; endl; 15 cout \u0026lt;\u0026lt; p \u0026lt;\u0026lt; endl; 16 17 return 0; 18} 引用的本质 引用的本质在C++内部实现是一个指针常量\n1void func(int\u0026amp; ref) 2{ 3 ref = 100; 4} 5 6int main() 7{ 8 int a = 10; 9 10 //发现是引用 自动转换为 int* const ref = \u0026amp;a; 11 //指针常量的指向不可以更改 因此引用在初始化后不可以更改 12 int\u0026amp; ref = a; 13 ref = 20;//发现是引用 自动转换为：*ref = 20 14 cout \u0026lt;\u0026lt; \u0026#34;a = \u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; 15 cout \u0026lt;\u0026lt; \u0026#34;ref = \u0026#34; \u0026lt;\u0026lt; ref \u0026lt;\u0026lt; endl; 16 17 func(a); 18 cout \u0026lt;\u0026lt; \u0026#34;a = \u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; 19 cout \u0026lt;\u0026lt; \u0026#34;ref = \u0026#34; \u0026lt;\u0026lt; ref \u0026lt;\u0026lt; endl; 20 21 return 0; 22} 常量引用 **作用：**常量引用主要用来修饰形参，防止误操作\n在函数的形参列表中，可以加const修饰形参，防止形参改变实参\n1void show(const int\u0026amp; val) 2{ 3 //val = 1000;//如果参数列表中不加const 该行会成功执行 导致main函数中的a的值发生变化 4 cout \u0026lt;\u0026lt; \u0026#34;val = \u0026#34; \u0026lt;\u0026lt; val \u0026lt;\u0026lt; endl; 5}; 6 7int main() 8{ 9 int a = 10; 10 11 //int \u0026amp;ref = 10;这一行会报错 引用必须引一块合法的内存空间 而这里的10只是一个字面量 12 //int \u0026amp;ref = 10; 13 14 //加上const之后 编译器会将代码修改为 15 //int temp = 10; 16 //const int \u0026amp;ref = temp; 17 //因此不会报错 18 const int \u0026amp;ref = 10; 19 20 //ref = 20;//加上const后变为只读 不可以修改 21 cout \u0026lt;\u0026lt; \u0026#34;ref = \u0026#34; \u0026lt;\u0026lt; ref \u0026lt;\u0026lt; endl; 22 23 show(a); 24 cout \u0026lt;\u0026lt; \u0026#34;a in main: \u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; 25 26 return 0; 27} 函数提高 函数默认参数 在C++中，函数的形参列表中的形参是可以有默认值的\n语法：返回值类型 函数名(参数 = 默认值) { }\n注意：\n如果某个位置已经有了默认参数，那么从这个位置往后，从左到右的参数都必须要有默认值 如果函数声明有默认参数，函数实现就不能有默认参数 1int SumNum(int a, int b = 20, int c = 30) 2{ 3 return a + b + c; 4}; 5 6//声明和实现只能有一个有默认参数 7int SumNum1(int a = 10, int b = 20); 8 9//声明中带默认参数 实现中也有默认参数会报错 10// int SumNum1(int a = 30, int b = 40) 11// { 12// return a + b; 13// }; 14 15int SumNum1(int a, int b) 16{ 17 return a + b; 18}; 19 20int main() 21{ 22 cout \u0026lt;\u0026lt; SumNum(10) \u0026lt;\u0026lt; endl; 23 cout \u0026lt;\u0026lt; SumNum(10, 20, 30) \u0026lt;\u0026lt; endl; 24 cout \u0026lt;\u0026lt; SumNum(10, 40, 50) \u0026lt;\u0026lt; endl; 25 26 cout \u0026lt;\u0026lt; SumNum1() \u0026lt;\u0026lt; endl; 27 cout \u0026lt;\u0026lt; SumNum1(40, 50) \u0026lt;\u0026lt; endl; 28 29 return 0; 30} 函数占位参数 C++中函数的形参列表里可以有占位参数，用来做占位，调用函数时必须填补该位置\n语法：返回值类型 函数名(数据类型){ }\n1void func(int a, int)//第二个int类型参数就是占位参数 占位参数可以有默认值 2{ 3 cout \u0026lt;\u0026lt; \u0026#34;hello\u0026#34; \u0026lt;\u0026lt; endl; 4} 5 6int main() 7{ 8 func(10, 10);//调用func函数必须要传入占位参数 否则会报错 9 return 0; 10} 函数重载 作用：允许函数名相同，提高复用性\n函数重载满足条件：\n同一个作用域下 函数名称相同 函数参数类型不同 或者 个数不同 或者顺序不同 注意：函数的返回值不可以作为函数重载的条件\n1void func() 2{ 3 cout \u0026lt;\u0026lt; \u0026#34;func()的调用\u0026#34; \u0026lt;\u0026lt; endl; 4}; 5 6void func(int a) 7{ 8 cout \u0026lt;\u0026lt; \u0026#34;func(int a)的调用\u0026#34; \u0026lt;\u0026lt; endl; 9} 10void func(double a) 11{ 12 cout \u0026lt;\u0026lt; \u0026#34;func(double a)的调用\u0026#34; \u0026lt;\u0026lt; endl; 13} 14 15void func(int a, double b) 16{ 17 cout \u0026lt;\u0026lt; \u0026#34;func(int a, double b)的调用\u0026#34; \u0026lt;\u0026lt; endl; 18} 19 20void func(double a, int b) 21{ 22 cout \u0026lt;\u0026lt; \u0026#34;func(double a, int b)的调用\u0026#34; \u0026lt;\u0026lt; endl; 23} 24 25//int func(double a, int b){} 26//会报错：functions that differ only in their return type cannot be overloaded 27// int func(double a, int b) 28// { 29// cout \u0026lt;\u0026lt; \u0026#34;func(double a, int b)的调用\u0026#34; \u0026lt;\u0026lt; endl; 30// return 10; 31// } 32 33int main() 34{ 35 func(); 36 func(10); 37 func(3.14); 38 func(10, 3.14); 39 func(3.14, 10); 40 return 0; 41} 引用作为重载条件 1//func(int \u0026amp;a)接受 int\u0026amp; 类型的变量 2void func(int \u0026amp;a) 3{ 4 cout \u0026lt;\u0026lt; \u0026#34;func(int \u0026amp;a)的调用\u0026#34; \u0026lt;\u0026lt; endl; 5} 6//func(const int \u0026amp;a)接受 const int\u0026amp; 类型的变量 7//两个函数的参数类型不同 因此可以重载 8void func(const int \u0026amp;a) 9{ 10 cout \u0026lt;\u0026lt; \u0026#34;func(const int \u0026amp;a)的调用\u0026#34; \u0026lt;\u0026lt; endl; 11} 12 13int main() 14{ 15 int a = 10; 16 func(a);//a = 10 是一个变量 因此调用func(int \u0026amp;a) 17 //func(10) 尝试调用func(int \u0026amp;a)时，会发生：int \u0026amp;a = 10; 这是不合法的 因此不会调用func(int \u0026amp;a) 18 //而调用func(const int \u0026amp;a)时，会有 const int \u0026amp;a = 10; 这是合法的 因此会调用func(const int \u0026amp;a) 19 func(10); 20 return 0; 21} 函数重载碰到函数默认参数 1void func(int a, int b = 20) 2{ 3 cout \u0026lt;\u0026lt; \u0026#34;func(int a, int b = 20)的调用\u0026#34; \u0026lt;\u0026lt; endl; 4} 5 6void func(int a) 7{ 8 cout \u0026lt;\u0026lt; \u0026#34;func(int a)的调用\u0026#34; \u0026lt;\u0026lt; endl; 9} 10 11int main() 12{ 13 func(10);//func(10)调用func(int a, int b = 20)和func(int a)都会成功 出现歧义 因此会报错 14 return 0; 15} 类和对象 C++面向对象的三大特性为：封装、继承、多态\nC++认为万事万物皆为对象，对象上有其属性和行为\n封装——面向对象的三大特征之一 封装的意义 将属性和行为作为一个整体，表现生活中的事物 1//设计一个圆类 求圆的周长 2const double PI = 3.14; 3//定义圆类 4class Circle 5{ 6//访问权限 7public:\t//公共权限 8 //圆的属性 9 double m_r; 10 //圆的行为 11 double calculateZC() 12 { 13 return 2 * PI * m_r; 14 } 15}; 16 17int main() 18{ 19 //实例化一个圆类cl 20 Circle cl; 21 cl.m_r = 10; 22 cout \u0026lt;\u0026lt; \u0026#34;圆的周长为：\u0026#34; \u0026lt;\u0026lt; cl.calculateZC() \u0026lt;\u0026lt; endl;//62.8 return 0; 23} 将属性和行为加以权限控制 访问权限有三种：\npublic 公共权限：类内可以访问，类外也可以访问 protected 保护权限：类内可以访问，类外不可以访问，子类可以访问父类中的protected权限的内容 private 私有权限：类内可以访问，类外不可以访问，子类也不可以访问父类中的private权限的内容 1class Person 2{ 3 public: 4 string p_name; 5 int p_age; 6 private: 7 string card_psd; 8 protected: 9 string p_addr; 10 public: 11 void Init() 12 { 13 p_name = \u0026#34;Tom\u0026#34;; 14 p_age = 18; 15 card_psd = \u0026#34;123456\u0026#34;; 16 p_addr = \u0026#34;c_building\u0026#34;; 17 }; 18 //Show函数定义在Person类内 因此可以访问到Person的所有属性 19 void Show() 20 { 21 cout \u0026lt;\u0026lt; \u0026#34;Name: \u0026#34; \u0026lt;\u0026lt; p_name \u0026lt;\u0026lt; \u0026#34;;\u0026#34; \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34; 22 \u0026lt;\u0026lt; \u0026#34;Age: \u0026#34; \u0026lt;\u0026lt; p_age \u0026lt;\u0026lt; \u0026#34;;\u0026#34; \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34; 23 \u0026lt;\u0026lt; \u0026#34;Card_Psd: \u0026#34; \u0026lt;\u0026lt; card_psd \u0026lt;\u0026lt; \u0026#34;;\u0026#34; \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34; 24 \u0026lt;\u0026lt; \u0026#34;Addr: \u0026#34; \u0026lt;\u0026lt; p_addr \u0026lt;\u0026lt; \u0026#34;;\u0026#34; \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34; 25 \u0026lt;\u0026lt; endl; 26 } 27}; 28 29int main() 30{ 31 Person p1; 32 p1.Init(); 33 p1.Show(); 34 p1.p_name = \u0026#34;Mike\u0026#34;; 35 p1.p_age = 20; 36 p1.Show(); 37 38 //以下操作会报错 39 //因为p_addr属性是protected权限，card_psd属性是private权限 40 //两者在类外均不可访问 41 // p1.p_addr = \u0026#34;b_building\u0026#34;; 42 // p1.card_psd = \u0026#34;654321\u0026#34;; 43 // p1.Show(); 44 45 return 0; 46} struct 和 class 的区别 在C++中，struct和class唯一的区别就在于默认的访问权限不同\n区别：\nstruct默认权限为公共 class默认权限为私有 1class C1 2{ 3 //默认为私有权限 4 int c1_v; 5}; 6 7struct S1 8{ 9 //默认为公共权限 10 int s1_v; 11}; 12 13int main() 14{ 15 C1 c; 16 S1 s; 17 c.c1_v = 10;//类外访问私有权限的属性 报错 18 s.s1_v = 10;//该行正常执行 19 20 return 0; 21} 成员属性设置为私有 优点1：将所有成员属性设置为私有，可以自己控制读写权限\n优点2：对于写权限，可以检测数据的有效性\n1class Person 2{ 3 //将属性都设置为私有 4 private: 5 string name; 6 int age; 7 string addr; 8 //通过定义public权限的方法，赋予私有属性读与写权限，以及验证写操作的合法性 9 public: 10 string getName()//赋予name读权限 11 { 12 return name; 13 }; 14 void setName(string s) 15 { 16 name = s; 17 }; 18 void setAge(int a)//赋予age写权限 并且验证age的合法性 19 { 20 if (a \u0026lt;= 0 || a \u0026gt; 150) 21 { 22 cout \u0026lt;\u0026lt; \u0026#34;输入的年龄\u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#34;不合法，\u0026#34; \u0026lt;\u0026lt; \u0026#34;请输入1-150之间的年龄\u0026#34; \u0026lt;\u0026lt; endl; 23 } 24 age = a; 25 }; 26 void show() 27 { 28 cout \u0026lt;\u0026lt; \u0026#34;name: \u0026#34; \u0026lt;\u0026lt; name \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34; 29 \u0026lt;\u0026lt; \u0026#34;age: \u0026#34; \u0026lt;\u0026lt; age \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34; 30 \u0026lt;\u0026lt; endl; 31 }; 32}; 33 34int main() 35{ 36 Person p1; 37 p1.setName(\u0026#34;Tom\u0026#34;); 38 p1.setAge(160); 39 p1.setAge(18); 40 p1.show(); 41 42 return 0; 43} 对象的初始化和清理 构造函数和析构函数 对象的初始化和清理也是两个非常重要的安全问题\n一个对象或者变量没有初始状态，对其使用后果是未知 同样的，使用完一个对象和变量，没有及时清理，也会造成一定的安全问题 C++利用了构造函数和析构函数解决上述问题，这两个函数将会被编译器自动调用，完成对象初始化和清理工作。\n对象的初始化和清理工作时编译器强制要求我们要做的事情，因此如果我们不提供构造和析构，编译器会提供\n编译器提供的构造函数和析构函数是空实现\n构造函数：主要作用在于 创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无需手动调用 析构函数：主要作用在于 对象销毁前系统自动调用，执行一些清理工作 构造函数语法： 类名 ( ) { }\n构造函数，没有返回值也不写void 函数名称与类名相同 构造函数可以有参数，因此可以发生重载 程序在调用对象的时候回自动调用构造函数，无需手动调用，而且只会调用一次 析构函数语法：~类名 ( ) { }\n析构函数，没有返回值也没有void 函数名称与类名相同，在名称前加符号 ~ 析构函数不可以有参数，因此不可以发生重载 程序在对象销毁前回自动调用析构，无需手动调用，而且只会调用一次 1//对象的初始化和清理 2class Person 3{ 4 public: 5 string Name; 6 7 Person() 8 { 9 cout \u0026lt;\u0026lt; \u0026#34;Person 的构造函数\u0026#34; \u0026lt;\u0026lt; endl; 10 }; 11 12 ~Person() 13 { 14 cout \u0026lt;\u0026lt; \u0026#34;Person 的析构函数\u0026#34; \u0026lt;\u0026lt; endl; 15 } 16}; 17 18void Test() 19{ 20 //p是存放在栈上的数据 Test函数执行完毕后 会释放p这个对象 21 //在释放p之前 编译器会自动调用析构函数 22 Person p; 23 p.Name = \u0026#34;Tom\u0026#34;; 24 cout \u0026lt;\u0026lt; p.Name \u0026lt;\u0026lt; endl; 25} 26 27int main() { 28 Test(); 29 30 return 0; 31} 构造函数的分类及调用 两种分类方式：\n按参数分为：有参构造和无参构造 按类型分为：普通构造和拷贝构造 三种调用方式：\n括号法 显示法 隐式转换法 1class Person 2{ 3 public: 4 string Name; 5 int Age; 6 7 Person() 8 { 9 cout \u0026lt;\u0026lt; \u0026#34;Person 的构造函数\u0026#34; \u0026lt;\u0026lt; endl; 10 }; 11 12 Person(int a) 13 { 14 cout \u0026lt;\u0026lt; \u0026#34;Person 的有参构造函数\u0026#34; \u0026lt;\u0026lt; endl; 15 Age = a; 16 }; 17 18 Person(const Person \u0026amp;p)//需要保证被拷贝的对象不会被修改 19 { 20 cout \u0026lt;\u0026lt; \u0026#34;Person 的拷贝构造函数\u0026#34; \u0026lt;\u0026lt; endl; 21 Age = p.Age; 22 }; 23 24 ~Person() 25 { 26 cout \u0026lt;\u0026lt; \u0026#34;Person 的析构函数\u0026#34; \u0026lt;\u0026lt; endl; 27 } 28}; 29 30void Test() 31{ 32 Person p1;//调用默认构造函数 Person(){} 33 p1.Age = 18; 34 cout \u0026lt;\u0026lt; \u0026#34;p1的Age：\u0026#34; \u0026lt;\u0026lt; p1.Age \u0026lt;\u0026lt; endl; 35 cout \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34; \u0026lt;\u0026lt; endl; 36 37 Person p2(10);//括号法 此时调用 Person(int a){} 38 cout \u0026lt;\u0026lt; \u0026#34;p2的Age：\u0026#34; \u0026lt;\u0026lt; p2.Age \u0026lt;\u0026lt; endl; 39 Person p3(p1);//括号法 此时调用 Person(const Person \u0026amp;p){} 40 cout \u0026lt;\u0026lt; \u0026#34;p3的Age：\u0026#34; \u0026lt;\u0026lt; p3.Age \u0026lt;\u0026lt; endl; 41 //发生拷贝构造时不会改变被拷贝对象p1的值 42 cout \u0026lt;\u0026lt; \u0026#34;p1的Age：\u0026#34; \u0026lt;\u0026lt; p1.Age \u0026lt;\u0026lt; endl; 43 //cout \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34; \u0026lt;\u0026lt; endl; 44 45 //注意 默认构造函数的调用不需要加括号 46 //编译器会认为这是一个函数声明 47 //不会报错 但是也不会实例p4 48 Person p4(); 49 cout \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34; \u0026lt;\u0026lt; endl; 50 51 Person p5 = Person(10);//显示法的有参构造 52 cout \u0026lt;\u0026lt; \u0026#34;p5的Age：\u0026#34; \u0026lt;\u0026lt; p5.Age \u0026lt;\u0026lt; endl; 53 Person p6 = Person(p1);//显示法的拷贝构造 54 cout \u0026lt;\u0026lt; \u0026#34;p6的Age：\u0026#34; \u0026lt;\u0026lt; p6.Age \u0026lt;\u0026lt; endl; 55 cout \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34; \u0026lt;\u0026lt; endl; 56 57 //匿名对象 特点：当前行执行结束后就会被释放 58 Person(20); 59 cout \u0026lt;\u0026lt; \u0026#34;aaaaa\u0026#34; \u0026lt;\u0026lt; endl; 60 //注意：不要用拷贝构造函数初始化一个匿名函数 61 //编译器会认为 Person(p1) 等价于 Person p1 62 //因此编译器会报错 p1被重定义 63 //Person(p1); 64 cout \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34; \u0026lt;\u0026lt; endl; 65 66 Person p7 = 22;//隐式转换法 等价于 Person p7 = Person(22) 67 cout \u0026lt;\u0026lt; \u0026#34;p7的Age：\u0026#34; \u0026lt;\u0026lt; p7.Age \u0026lt;\u0026lt; endl; 68 Person p8 = p1;//隐式转换法 等价于 Person p7 = Person(22) 69 cout \u0026lt;\u0026lt; \u0026#34;p8的Age：\u0026#34; \u0026lt;\u0026lt; p8.Age \u0026lt;\u0026lt; endl; 70 cout \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34; \u0026lt;\u0026lt; endl; 71} 72 73int main() { 74 Test(); 75 76 return 0; 77} 拷贝构造函数的调用时机 C++中拷贝构造函数的调用时机通常有三种情况：\n使用一个已经创建完毕的对象来初始化一个新对象 值传递的方式给函数参数传值 以值方式返回局部对象 1//拷贝构造函数的调用时机 2class Person 3{ 4 public: 5 string Name; 6 int Age; 7 8 Person() 9 { 10 cout \u0026lt;\u0026lt; \u0026#34;Person 的默认构造函数\u0026#34; \u0026lt;\u0026lt; endl; 11 }; 12 13 Person(int a) 14 { 15 cout \u0026lt;\u0026lt; \u0026#34;Person 的有参构造函数\u0026#34; \u0026lt;\u0026lt; endl; 16 Age = a; 17 }; 18 19 Person(const Person \u0026amp;p)//需要保证被拷贝的对象不会被修改 20 { 21 cout \u0026lt;\u0026lt; \u0026#34;Person 的拷贝构造函数\u0026#34; \u0026lt;\u0026lt; endl; 22 Age = p.Age; 23 }; 24 25 ~Person() 26 { 27 cout \u0026lt;\u0026lt; \u0026#34;Person 的析构函数\u0026#34; \u0026lt;\u0026lt; endl; 28 } 29}; 30 31void test_1() 32{ 33 cout \u0026lt;\u0026lt; \u0026#34;------使用一个已经创建完毕的对象来初始化一个新对象------\u0026#34; \u0026lt;\u0026lt; endl; 34 Person p1; 35 p1.Age = 18; 36 Person p2(p1);//此时产生了一个p1的副本 p2拷贝的是这个p1的副本 因此p2的修改不会影响p1 37 p2.Age = 22; 38 cout \u0026lt;\u0026lt; \u0026#34;p1.Age: \u0026#34; \u0026lt;\u0026lt; p1.Age \u0026lt;\u0026lt; endl; 39 cout \u0026lt;\u0026lt; \u0026#34;p2.Age: \u0026#34; \u0026lt;\u0026lt; p2.Age \u0026lt;\u0026lt; endl; 40}; 41 42void goWork(Person p) 43{ 44 p.Age = 22; 45 cout \u0026lt;\u0026lt; \u0026#34;p.Age: \u0026#34; \u0026lt;\u0026lt; p.Age \u0026lt;\u0026lt; endl; 46}; 47 48void test_2() 49{ 50 cout \u0026lt;\u0026lt; \u0026#34;------值传递的方式给函数参数传值------\u0026#34; \u0026lt;\u0026lt; endl; 51 Person p1; 52 p1.Age = 18; 53 goWork(p1);//该函数进行值传递 因此会产生一个p1的副本 函数goWork拷贝该副本 54 cout \u0026lt;\u0026lt; \u0026#34;p1.Age: \u0026#34; \u0026lt;\u0026lt; p1.Age \u0026lt;\u0026lt; endl; 55}; 56 57Person goWork() 58{ 59 Person p; 60 p.Age = 18; 61 //cout \u0026lt;\u0026lt; \u0026#34;p.Age: \u0026#34; \u0026lt;\u0026lt; p.Age \u0026lt;\u0026lt; endl; 62 cout \u0026lt;\u0026lt; \u0026#34;address of p: \u0026#34; \u0026lt;\u0026lt; (int*)\u0026amp;p \u0026lt;\u0026lt; endl; 63 return p; 64} 65 66void test_3() 67{ 68 cout \u0026lt;\u0026lt; \u0026#34;------以值方式返回局部对象------\u0026#34; \u0026lt;\u0026lt; endl; 69 Person p1 = goWork(); 70 //cout \u0026lt;\u0026lt; \u0026#34;p1.Age: \u0026#34; \u0026lt;\u0026lt; p1.Age \u0026lt;\u0026lt; endl; 71 cout \u0026lt;\u0026lt; \u0026#34;address of p1: \u0026#34; \u0026lt;\u0026lt; (int*)\u0026amp;p1 \u0026lt;\u0026lt; endl; 72} 73 74int main() 75{ 76 test_1(); 77 test_2(); 78 test_3(); 79 return 0; 80} 注意：在函数 test_3() 中实际需要调用3次构造函数，但在实际编译运行中只调用了一次默认构造函数，且对象p与对象p1的地址相同，这是因为g++编译器默认开启了返回值优化RVO(return value optimization)，通过命令 -fno-elide-constructors 关闭RVO则会输出以下结果：\n1g++ main.cpp -fno-elide-constructors -o ../../target/main \u0026amp;\u0026amp; ../../target/main 构造函数的调用规则 默认情况下，C++编译器至少给一个类添加3个函数：\n默认构造函数（无参，函数体为空） 默认析构函数（无参，函数体为空） 默认拷贝构造函数，对属性进行值拷贝 构造函数的调用规则如下：\n如果用户定义有参构造函数，C++不再提供默认无参构造函数，但是会提供默认拷贝构造 如果用户定义拷贝构造函数，C++不再提供其他构造函数 1//构造函数的调用规则 2class Person 3{ 4 public: 5 int age; 6 7 // Person() 8 // { 9 // cout \u0026lt;\u0026lt; \u0026#34;Person的默认构造\u0026#34; \u0026lt;\u0026lt; endl; 10 // }; 11 Person(int a) 12 { 13 cout \u0026lt;\u0026lt; \u0026#34;Person的有参构造\u0026#34; \u0026lt;\u0026lt; endl; 14 age = a; 15 } 16 // Person(const Person \u0026amp;p) 17 // { 18 // cout \u0026lt;\u0026lt; \u0026#34;Person的拷贝构造\u0026#34; \u0026lt;\u0026lt; endl; 19 // age = p.age; 20 // } 21 ~Person() 22 { 23 cout \u0026lt;\u0026lt; \u0026#34;Person的析构函数\u0026#34; \u0026lt;\u0026lt; endl; 24 } 25}; 26 27void test_1() 28{ 29 // Person p; 30 // p.age = 18; 31 // cout \u0026lt;\u0026lt; \u0026#34;p.age: \u0026#34; \u0026lt;\u0026lt; p.age \u0026lt;\u0026lt; endl; 32 33 Person p1(22); 34 cout \u0026lt;\u0026lt; \u0026#34;p1.age: \u0026#34; \u0026lt;\u0026lt; p1.age \u0026lt;\u0026lt; endl; 35 36 Person p2(p1); 37 cout \u0026lt;\u0026lt; \u0026#34;p2.age: \u0026#34; \u0026lt;\u0026lt; p2.age \u0026lt;\u0026lt; endl; 38} 39 40int main() 41{ 42 test_1(); 43 return 0; 44} 上述程序中，声明了Person类的有参构造函数，但未声明拷贝构造，程序运行结果显示，C++编译器自动为Person添加了一个拷贝构造函数，函数体为空；\n1void test_1() 2{ 3 Person p; 4 p.age = 18; 5 cout \u0026lt;\u0026lt; \u0026#34;p.age: \u0026#34; \u0026lt;\u0026lt; p.age \u0026lt;\u0026lt; endl; 6} 如果在程序中进行上述定义，则会报错，提示Person类没有默认的构造函数：\n深拷贝与浅拷贝 浅拷贝：简单的赋值拷贝操作\n深拷贝：在堆区重新申请空间，进行拷贝操作\n1//深拷贝与浅拷贝 2class Person 3{ 4 public: 5 int age; 6 int* height; 7 8 Person() 9 { 10 cout \u0026lt;\u0026lt; \u0026#34;Person的默认构造\u0026#34; \u0026lt;\u0026lt; endl; 11 }; 12 Person(int a, int h) 13 { 14 cout \u0026lt;\u0026lt; \u0026#34;Person的有参构造\u0026#34; \u0026lt;\u0026lt; endl; 15 age = a; 16 height = new int(h);//返回一个堆区的指针 17 }; 18 ~Person() 19 { 20 cout \u0026lt;\u0026lt; \u0026#34;Person的析构函数\u0026#34; \u0026lt;\u0026lt; endl; 21 if (height != NULL) 22 { 23 delete height; 24 height = NULL; 25 } 26 } 27}; 28 29void test_1() 30{ 31 Person p(18, 180); 32 cout \u0026lt;\u0026lt; \u0026#34;p.age: \u0026#34; \u0026lt;\u0026lt; p.age \u0026lt;\u0026lt; endl; 33 cout \u0026lt;\u0026lt; \u0026#34;p.height: \u0026#34; \u0026lt;\u0026lt; *p.height \u0026lt;\u0026lt; endl; 34 cout \u0026lt;\u0026lt; \u0026#34;adderss of p: \u0026#34; \u0026lt;\u0026lt; \u0026amp;p \u0026lt;\u0026lt; endl; 35 cout \u0026lt;\u0026lt; \u0026#34;adderss of p.height: \u0026#34; \u0026lt;\u0026lt; p.height \u0026lt;\u0026lt; endl; 36 Person p1(p);//p1后入栈，先被析构 37 cout \u0026lt;\u0026lt; \u0026#34;p1.age: \u0026#34; \u0026lt;\u0026lt; p1.age \u0026lt;\u0026lt; endl; 38 cout \u0026lt;\u0026lt; \u0026#34;p1.height: \u0026#34; \u0026lt;\u0026lt; *p1.height \u0026lt;\u0026lt; endl; 39 cout \u0026lt;\u0026lt; \u0026#34;adderss of p1: \u0026#34; \u0026lt;\u0026lt; \u0026amp;p1 \u0026lt;\u0026lt; endl; 40 cout \u0026lt;\u0026lt; \u0026#34;adderss of p1.height: \u0026#34; \u0026lt;\u0026lt; p1.height \u0026lt;\u0026lt; endl; 41}; 42 43int main() 44{ 45 test_1(); 46 return 0; 47}; 上述程序中，由于没有声明拷贝构造函数，因此编译器会调用默认的拷贝构造来生成p1，但由于编译器默认的拷贝构造只执行简单的值拷贝，因此对于声明在堆区的属性 p.height ，默认的拷贝构造只是将p.height的值（一个堆区的地址）复制给了 p1.height ，这就导致 p.height 与 p1.height 都指向了同一个堆区地址，从而导致在执行析构的时候，优先被释放的 p1 会先将 p1.height 所指向的堆区地址释放一次，之后被释放的 p 又会将该地址释放一次，造成重复释放：\n因此需要重新定义Person类的拷贝构造函数，为新构造的Person实例的height在堆区分配新的地址：\n1Person(const Person \u0026amp;p) 2{ 3 cout \u0026lt;\u0026lt; \u0026#34;Person的拷贝构造\u0026#34; \u0026lt;\u0026lt; endl; 4 age = p.age; 5 height = new int(*p.height); 6} 总结：如果对象的属性有在堆区开辟的，一定要自己定义拷贝构造函数，防止浅拷贝带来的问题；同时要注意，在堆区开辟的内存，需要在析构函数中手动释放。\n初始化列表 作用：C++提供了初始化列表语法，用来初始化类的属性\n语法：构造函数( ): 属性1(值1), 属性2(值2) \u0026hellip; { }\n1class Person 2{ 3 public: 4 int age; 5 string name; 6 7 // Person():age(18), name(\u0026#34;tom\u0026#34;) 8 // { 9 10 // }; 11 12 Person(int a, string n):age(a), name(n) 13 { 14 15 }; 16}; 17 18int main() 19{ 20 Person p1(20, \u0026#34;jim\u0026#34;); 21 cout \u0026lt;\u0026lt; \u0026#34;p1.age: \u0026#34; \u0026lt;\u0026lt; p1.age \u0026lt;\u0026lt; endl; 22 cout \u0026lt;\u0026lt; \u0026#34;p1.name: \u0026#34; \u0026lt;\u0026lt; p1.name \u0026lt;\u0026lt; endl; 23 return 0; 24} 类对象作为类成员 C++类中的成员可以是另一个类的对象，称该成员为对象成员\n1//类对象作为类的成员 2class Person 3{ 4 public: 5 int Age; 6 string Name; 7 Person(int age, string name):Age(age), Name(name) 8 { 9 cout \u0026lt;\u0026lt; \u0026#34;Person类的构造函数\u0026#34; \u0026lt;\u0026lt; endl; 10 }; 11 ~Person() 12 { 13 cout \u0026lt;\u0026lt; \u0026#34;Person类的析构函数\u0026#34; \u0026lt;\u0026lt; endl; 14 }; 15}; 16 17class Student 18{ 19 public: 20 Person P; 21 int Score; 22 Student(int age, string name, int score):P(age, name), Score(score) 23 { 24 cout \u0026lt;\u0026lt; \u0026#34;Student类的构造函数\u0026#34; \u0026lt;\u0026lt; endl; 25 }; 26 ~Student() 27 { 28 cout \u0026lt;\u0026lt; \u0026#34;Student类的析构函数\u0026#34; \u0026lt;\u0026lt; endl; 29 }; 30}; 31 32int main() 33{ 34 Student s(18, \u0026#34;Tom\u0026#34;, 88); 35 cout \u0026lt;\u0026lt; \u0026#34;s.age: \u0026#34; \u0026lt;\u0026lt; s.P.Age \u0026lt;\u0026lt; endl; 36 cout \u0026lt;\u0026lt; \u0026#34;s.name: \u0026#34; \u0026lt;\u0026lt; s.P.Name \u0026lt;\u0026lt; endl; 37 cout \u0026lt;\u0026lt; \u0026#34;s.score: \u0026#34; \u0026lt;\u0026lt; s.Score \u0026lt;\u0026lt; endl; 38 return 0; 39} 总结：当构造的类中包含另一个类对象时，先调用被包含的类的构造函数，在调用需要构造的类的构造函数，析构时相反。\n静态成员 在成员变量和成员函数前加上关键词 static，称为静态成员\n静态成员分为：\n静态成员变量 所有对象共享同一份数据 在编译阶段分配内存（全局区） 需要类内声明，类外初始化 静态成员函数 所有对象共享同一个函数 静态成员函数只能访问静态成员变量 1//静态成员变量 2class Person 3{ 4 public: 5 int Age; 6 string Name; 7 static int SSS;//类内声明 8 9 int getPersonRRR()//通过类内的函数将私有属性暴露出去 10 { 11 return RRR; 12 }; 13 14 private: 15 static int RRR;//可以声明私有的静态成员变量 16}; 17int Person::SSS = 100;//类外初始化 通过Person::SSS访问到类内的静态成员变量 18int Person::RRR = 999;//私有的静态成员变量也需要在类外初始化 19 20int main() 21{ 22 Person p1; 23 cout \u0026lt;\u0026lt; \u0026#34;adress of p1.SSS: \u0026#34; \u0026lt;\u0026lt; \u0026amp;p1.SSS \u0026lt;\u0026lt; endl; 24 cout \u0026lt;\u0026lt; \u0026#34;p1.SSS: \u0026#34; \u0026lt;\u0026lt; p1.SSS \u0026lt;\u0026lt; endl; 25 //cout \u0026lt;\u0026lt; \u0026#34;p1.RRR: \u0026#34; \u0026lt;\u0026lt; p1.RRR \u0026lt;\u0026lt; endl;//无法在类外访问私有的静态成员变量 26 cout \u0026lt;\u0026lt; \u0026#34;p1.RRR: \u0026#34; \u0026lt;\u0026lt; p1.getPersonRRR() \u0026lt;\u0026lt; endl; 27 Person p2; 28 p2.SSS = 200;//对p2.SSS的修改会影响所有的Person类 29 cout \u0026lt;\u0026lt; \u0026#34;adress of p2.SSS: \u0026#34; \u0026lt;\u0026lt; \u0026amp;p2.SSS \u0026lt;\u0026lt; endl; 30 cout \u0026lt;\u0026lt; \u0026#34;p1.SSS: \u0026#34; \u0026lt;\u0026lt; p1.SSS \u0026lt;\u0026lt; endl; 31 32 //对于静态成员变量的访问 33 //通过实例化一个类访问 34 Person p3; 35 cout \u0026lt;\u0026lt; \u0026#34;p3.SSS: \u0026#34; \u0026lt;\u0026lt; p3.SSS \u0026lt;\u0026lt; endl; 36 //通过Person::SSS访问 37 cout \u0026lt;\u0026lt; \u0026#34;Person::SSS: \u0026#34; \u0026lt;\u0026lt; Person::SSS \u0026lt;\u0026lt; endl; 38 return 0; 39} 1//静态成员函数 2class Person 3{ 4 public: 5 int Age; 6 static int SSS; 7 static void func1(){ 8 cout \u0026lt;\u0026lt; \u0026#34;func1的调用\u0026#34; \u0026lt;\u0026lt; endl; 9 SSS = 999; 10 //静态成员函数无法访问非静态成员变量 该行会报错 11 //error: invalid use of member \u0026#39;Age\u0026#39; in static member function 12 //Age = 22; 13 }; 14 private: 15 //也可以声明私有的静态成员函数 16 static void func2(){ 17 cout \u0026lt;\u0026lt; \u0026#34;func1的调用\u0026#34; \u0026lt;\u0026lt; endl; 18 }; 19}; 20 21int Person::SSS = 100; 22 23int main() 24{ 25 //通过实例化一个对象调用静态成员函数 26 Person p; 27 cout \u0026lt;\u0026lt; \u0026#34;Person::SSS: \u0026#34; \u0026lt;\u0026lt; Person::SSS \u0026lt;\u0026lt; endl; 28 p.func1(); 29 cout \u0026lt;\u0026lt; \u0026#34;Person::SSS: \u0026#34; \u0026lt;\u0026lt; Person::SSS \u0026lt;\u0026lt; endl; 30 //通过Person::func1()调用静态成员函数 31 p.func1(); 32 cout \u0026lt;\u0026lt; \u0026#34;Person::SSS: \u0026#34; \u0026lt;\u0026lt; Person::SSS \u0026lt;\u0026lt; endl; 33 return 0; 34} C++对象模型和this指针 成员变量和成员函数分开存储 在C++中，类内的成员变量和成员函数分开存储\n只有非静态成员变量才属于类的对象上\n1//成员变量和成员函数分开存储 2//空对象会占用1字节的内存 是为了区分对象在内存中的位置 3class Person 4{ 5 6}; 7 8class Student 9{ 10 public: 11 int Age;//非静态成员变量保存在对象内 12 //int Score; 13 static int RRR;//静态成员变量不在对象内 因此不会影响对象在内存中的大小 14 void func1(){};//成员函数不在对象内 15 static void func2(){};//静态成员函数也不在对象内 16}; 17 18int Student::RRR = 999; 19 20int main() 21{ 22 Person p; 23 cout \u0026lt;\u0026lt; \u0026#34;size of p: \u0026#34; \u0026lt;\u0026lt; sizeof(p) \u0026lt;\u0026lt; endl; 24 25 Student s; 26 cout \u0026lt;\u0026lt; \u0026#34;size of s: \u0026#34; \u0026lt;\u0026lt; sizeof(s) \u0026lt;\u0026lt; endl; 27 return 0; 28} this 指针 由于C++中成员变量与成员函数分开存储，每一个非静态成员函数只会诞生一份函数实例，这表明多个同类型的对象实例会共用一块代码，这会产生一个问题：这块代码如何区分是哪个对象实例调用了它？\nC++通过提供特殊的对象指针，this 指针，来解决上述问题；\nthis 指针指向被调用的成员函数所属的对象\nthis 指针是隐含在每一个非静态成员函数内的一种指针\nthis 指针不需要定义，直接使用即可\nthis 指针的用途：\n当形参和成员变量同名时，可以使用 this 指针来区分 在类的非静态成员函数中返回对象自身，可以使用 return *this 1//this指针的用法 2class Person 3{ 4 public: 5 int age; 6 7 Person(int age) 8 { 9 //age = age; 形参与成员变量名称冲突 赋值失败 10 this-\u0026gt;age = age; 11 }; 12 13 Person\u0026amp; Add(int num)//通过返回对象自身实现链式调用 14 { 15 this-\u0026gt;age += num; 16 return *this; 17 }; 18 19 Person Add000(int num)//如果返回值类型 则无法进行链式调用 因为值类型返回会拷贝一份该对象作为返回 20 { 21 this-\u0026gt;age += num; 22 return *this; 23 }; 24}; 25 26int main() 27{ 28 Person p(18); 29 cout \u0026lt;\u0026lt; \u0026#34;p.age: \u0026#34; \u0026lt;\u0026lt; p.age \u0026lt;\u0026lt; endl; 30 31 p.Add(10).Add(10);//链式调用 32 cout \u0026lt;\u0026lt; \u0026#34;p.age: \u0026#34; \u0026lt;\u0026lt; p.age \u0026lt;\u0026lt; endl; 33 34 p.Add000(10).Add000(10).Add000(10);//返回值类型的函数无法进行链式调用 35 cout \u0026lt;\u0026lt; \u0026#34;p.age: \u0026#34; \u0026lt;\u0026lt; p.age \u0026lt;\u0026lt; endl; 36 return 0; 37} 空指针访问成员函数 C++中空指针也是可以调用成员函数的，但要注意有没有用到this指针\n如果用到了this指针，需要加以判断保证代码的健壮性\n1//空指针访问成员函数 2class Person 3{ 4 public: 5 int Age; 6 7 string GetClassName() 8 { 9 return \u0026#34;Person\u0026#34;; 10 }; 11 12 int GetPersonAge() 13 { 14 //解决空指针调用导致的错误 15 if (this == NULL) { 16 cout \u0026lt;\u0026lt; \u0026#34;error: this指针为空\u0026#34; \u0026lt;\u0026lt; endl; 17 return -1; 18 }; 19 20 return Age;//这里相当于 return this-\u0026gt;Age 21 }; 22}; 23 24int main() 25{ 26 Person p1; 27 p1.Age = 18; 28 cout \u0026lt;\u0026lt; \u0026#34;class name of p1: \u0026#34; \u0026lt;\u0026lt; p1.GetClassName() \u0026lt;\u0026lt; endl; 29 cout \u0026lt;\u0026lt; \u0026#34;age of p1: \u0026#34; \u0026lt;\u0026lt; p1.GetPersonAge() \u0026lt;\u0026lt; endl; 30 31 Person * p2 = NULL; 32 cout \u0026lt;\u0026lt; \u0026#34;class name of p2: \u0026#34; \u0026lt;\u0026lt; p2-\u0026gt;GetClassName() \u0026lt;\u0026lt; endl; 33 cout \u0026lt;\u0026lt; \u0026#34;age of p2: \u0026#34; \u0026lt;\u0026lt; p2-\u0026gt;GetPersonAge() \u0026lt;\u0026lt; endl;//由于p2是空指针，也就是当前的this指针为空，因此会出错 34 35 return 0; 36} const 修饰成员函数 常函数\n成员函数后加 const 修饰，称这个函数为常函数 常函数内不可以修改成员属性 成员属性声明时加关键字 mutable 后，在常函数中依然可以修改 常对象\n声明对象前加 const 修饰，称这个对象为常对象 常对象只能调用常函数 1//常函数与常对象 2class Person 3{ 4 public: 5 int Age; 6 mutable int Score; 7 Person(int age) 8 { 9 Age = age; 10 }; 11 //在成员函数后加const修饰 表明这是一个常函数 12 //常函数内不可以修改一般的成员变量 但可以修改有 mutable 修饰的成员变量 13 //对于 this 指针的进一步解释： 14 //this 指针本质上是一个指针常量 即：Person * const this 15 //因此对于一般的 this 指针 该指针指向的地址不可修改 但是指向的地址保存的值可以修改 16 //常函数后的 const 即对 this 指针再加 const 修饰 17 //表明 this 指针指向的地址保存的值也不可以修改 18 void RevisePerson01(int num) const 19 { 20 //Age = age;一般的成员变量无法再常函数内进行修改 会报错 21 Score = num;//mutable 修饰的成员变量可以在常函数内修改 22 }; 23 void RevisePerson02(int num) 24 { 25 26 }; 27}; 28 29void test01() 30{ 31 Person p1(18); 32 p1.RevisePerson01(20); 33 cout \u0026lt;\u0026lt; \u0026#34;p1.Age: \u0026#34; \u0026lt;\u0026lt; p1.Age \u0026lt;\u0026lt; endl; 34 cout \u0026lt;\u0026lt; \u0026#34;p1.Score: \u0026#34; \u0026lt;\u0026lt; p1.Score \u0026lt;\u0026lt; endl; 35} 36 37void test02() 38{ 39 const Person p2(20); 40 p2.Score = 70; 41 p2.RevisePerson01(80); 42 cout \u0026lt;\u0026lt; \u0026#34;p2.Score: \u0026#34; \u0026lt;\u0026lt; p2.Score \u0026lt;\u0026lt; endl; 43 //常对象调用一般成员函数会报错 44 //如果常函数可以调用一般成员函数 若该函数内有对一般成员变量的修改操作 则还是会造成该变量的修改 45 //p2.RevisePerson02(); 46}; 47 48int main() 49{ 50 test01(); 51 test02(); 52 return 0; 53} 友元 在程序里，有些私有属性需要能够让类外一些特定函数或者类进行访问\n关键字：friend\n全局函数做友元 1class Student 2{ //通过friend关键字 声明全局函数getScore是Student类的一个友元 3 friend void getScore(Student *student); 4 public: 5 string Name; 6 int Age; 7 Student(string n, int a) 8 { 9 Name = n; 10 Age = a; 11 Score = 99; 12 }; 13 private: 14 int Score; 15}; 16 17void getScore(Student *student) 18{ 19 cout \u0026lt;\u0026lt; student-\u0026gt;Score \u0026lt;\u0026lt; endl; 20}; 21 22void test01() 23{ 24 Student p0(\u0026#34;tom\u0026#34;, 18); 25 getScore(\u0026amp;p0); 26}; 27 28int main() 29{ 30 test01(); 31 return 0; 32}; 类做友元 1class Student 2{ 3 //通过friend关键字 声明Teacher类是Student类的一个友元 4 friend class Teacher; 5 public: 6 Student(string name, int age, int score) 7 { 8 Name = name; 9 Age = age; 10 Score = score; 11 }; 12 string Name; 13 int Age; 14 private: 15 int Score; 16}; 17 18class Teacher 19{ 20 public: 21 Teacher(string name, int age) 22 { 23 Name = name; 24 Age = age; 25 }; 26 string Name; 27 int Age; 28 int getScore(Student * student) 29 { 30 return student-\u0026gt;Score; 31 }; 32}; 33 34int main() 35{ 36 Student s1(\u0026#34;tom\u0026#34;, 19, 80); 37 Teacher t1(\u0026#34;jim\u0026#34;, 33); 38 cout \u0026lt;\u0026lt; t1.getScore(\u0026amp;s1) \u0026lt;\u0026lt; endl; 39 return 0; 40} 成员函数做友元 1class Student; 2class Teacher 3{ 4 public: 5 string Name; 6 int Age; 7 Teacher(string name, int age) 8 { 9 Name = name; 10 Age = age; 11 }; 12 //！！！！！需要在Teacher类之前先声明Student类 13 int getScore(Student * stu); 14 //！！！！！如果现在直接定义getScore函数会报错 因为当前声明的Student类中没有Score这个属性 15 //！！！！！需要在Student定义之后再定义getScore函数 16 // int getScore(Student * stu) 17 // { 18 // return stu-\u0026gt;Score; 19 // }; 20}; 21class Student 22{ 23 //通过friend关键字 声明Teacher类下的getScore函数是Student类的一个友元 24 friend int Teacher::getScore(Student * stu); 25 public: 26 Student(string name, int age, int score) 27 { 28 Name = name; 29 Age = age; 30 Score= score; 31 }; 32 string Name; 33 int Age; 34 private: 35 int Score; 36}; 37 38int Teacher::getScore(Student * stu) 39{ 40 return stu-\u0026gt;Score; 41}; 42 43int main() 44{ 45 Student s1(\u0026#34;tom\u0026#34;, 21, 87); 46 Teacher t1(\u0026#34;jim\u0026#34;, 33); 47 cout \u0026lt;\u0026lt; t1.getScore(\u0026amp;s1) \u0026lt;\u0026lt; endl; 48 return 0; 49} ！！！！！特别注意类和成员函数的声明与定义的时机\n运算符重载 概念：对已有的运算符进行重新定义，赋予其另一种功能，以适应不同的数据类型\n加号运算符重载（+） 1//运算符重载 2//加法运算符重载 3class CountNum 4{ 5 public: 6 int Cnt1; 7 int Cnt2; 8 //通过成员函数的方式定义CountNum的加法运算 9 // CountNum AddCountNum(CountNum \u0026amp;c) 10 CountNum operator+(CountNum \u0026amp;c) 11 { 12 CountNum res; 13 res.Cnt1 = this-\u0026gt;Cnt1 + c.Cnt1; 14 res.Cnt2 = this-\u0026gt;Cnt2 + c.Cnt2; 15 return res; 16 }; 17 //运算符重载 可以发生函数重载 18 CountNum operator+(int num) 19 { 20 CountNum res; 21 res.Cnt1 = this-\u0026gt;Cnt1 + num; 22 res.Cnt2 = this-\u0026gt;Cnt2; 23 return res; 24 } 25}; 26//通过全局函数定义CountNum的加法运算 27//CountNum AddCountNum(CountNum \u0026amp;c1, CountNum \u0026amp;c2) 28// CountNum operator+(CountNum \u0026amp;c1, CountNum \u0026amp;c2) 29// { 30// CountNum res; 31// res.Cnt1 = c1.Cnt1 + c2.Cnt1; 32// res.Cnt2 = c1.Cnt2 + c2.Cnt2; 33// return res; 34// }; 35void test() 36{ 37 CountNum c1; 38 c1.Cnt1 = 10; 39 c1.Cnt2 = 20; 40 CountNum c2; 41 c2.Cnt1 = 20; 42 c2.Cnt2 = 10; 43 //CountNum c3 = c1.operator(c2); 44 CountNum c3 = c1 + c2; 45 cout \u0026lt;\u0026lt; c3.Cnt1 \u0026lt;\u0026lt; endl; 46 cout \u0026lt;\u0026lt; c3.Cnt2 \u0026lt;\u0026lt; endl; 47 //CountNum c3 = operator(c1, c2); 48 // CountNum c4 = c1 + c2; 49 // cout \u0026lt;\u0026lt; c4.Cnt1 \u0026lt;\u0026lt; endl; 50 // cout \u0026lt;\u0026lt; c4.Cnt2 \u0026lt;\u0026lt; endl; 51 CountNum c5 = c1 + 30; 52 cout \u0026lt;\u0026lt; c5.Cnt1 \u0026lt;\u0026lt; endl; 53 cout \u0026lt;\u0026lt; c5.Cnt2 \u0026lt;\u0026lt; endl; 54}; 55 56int main() 57{ 58 test(); 59 return 0; 60}; 注意：对于内置的数据类型，不能进行运算符重载\n左移运算符重载（\u0026laquo;） 作用：可以输出自定义数据类型\n1//左移运算符重载 2class CountNum 3{ 4 //可以通过友元加左移运算符重载的方式输出类中的私有属性 5 friend ostream \u0026amp; operator\u0026lt;\u0026lt;(ostream \u0026amp;cout, CountNum \u0026amp;c); 6private: 7 int Cnt = 100; 8public: 9 int Cnt1; 10 int Cnt2; 11 //通过成员函数的方式定义CountNum的左移运算 12 //期望达成的效果 cout \u0026lt;\u0026lt; p 13 //通过成员函数可实现的效果 p.operator\u0026lt;\u0026lt;(cout) 即 p \u0026lt;\u0026lt; cout 14 //因此左移运算符不可以通过成员函数重载 15 // void operator\u0026lt;\u0026lt;(cout) 16 // { 17 // }; 18}; 19//通过全局函数重载左移运算符 20ostream \u0026amp; operator\u0026lt;\u0026lt;(ostream \u0026amp;cout, CountNum \u0026amp;c) 21{ 22 cout \u0026lt;\u0026lt; typeid(c).name() \u0026lt;\u0026lt; \u0026#34;{\u0026#34; \u0026lt;\u0026lt; endl; 23 cout \u0026lt;\u0026lt; \u0026#34; Cnt = \u0026#34; \u0026lt;\u0026lt; c.Cnt \u0026lt;\u0026lt; endl; 24 cout \u0026lt;\u0026lt; \u0026#34; Cnt1 = \u0026#34; \u0026lt;\u0026lt; c.Cnt1 \u0026lt;\u0026lt; endl; 25 cout \u0026lt;\u0026lt; \u0026#34; Cnt2 = \u0026#34; \u0026lt;\u0026lt; c.Cnt2 \u0026lt;\u0026lt; endl; 26 cout \u0026lt;\u0026lt; \u0026#34;};\u0026#34; \u0026lt;\u0026lt; endl; 27 return cout; 28} 29 30int main() 31{ 32 CountNum c1; 33 c1.Cnt1 = 10; 34 c1.Cnt2 = 20; 35 cout \u0026lt;\u0026lt; c1 \u0026lt;\u0026lt; endl; 36 return 0; 37} 递增运算符重载（++） 作用：通过重载递增运算符，实现自己的整型数据\n1//递增运算符重载 2class MyInteger 3{ 4 friend ostream\u0026amp; operator\u0026lt;\u0026lt;(ostream\u0026amp; cout, MyInteger myInt); 5 public: 6 MyInteger() 7 { 8 m_Num = 0; 9 }; 10 //在这个自定义的整型中重载前置递增 11 //注意这里要返回该类型的引用 以保证连续的递增 ++(++myInt) 能够得到预期的结果 12 MyInteger\u0026amp; operator++() 13 { 14 m_Num++; 15 return *this; 16 }; 17 //在这个自定义的整型中重载后置递增 18 //通过添加一个int类型的占位参数 使编译器能够区分前置与后置递增 19 //注意后置递增时返回值类型 20 MyInteger operator++(int) 21 { 22 MyInteger temp = *this; 23 m_Num++; 24 return temp; 25 } 26 private: 27 int m_Num; 28}; 29 30ostream\u0026amp; operator\u0026lt;\u0026lt;(ostream\u0026amp; cout, MyInteger myInt) 31{ 32 cout \u0026lt;\u0026lt; myInt.m_Num; 33 return cout; 34}; 35 36int main() 37{ 38 MyInteger myInt; 39 cout \u0026lt;\u0026lt; myInt \u0026lt;\u0026lt; endl; 40 cout \u0026lt;\u0026lt; ++(++myInt) \u0026lt;\u0026lt; endl; 41 cout \u0026lt;\u0026lt; myInt \u0026lt;\u0026lt; endl; 42 cout \u0026lt;\u0026lt; myInt++\u0026lt;\u0026lt; endl; 43 cout \u0026lt;\u0026lt; myInt++\u0026lt;\u0026lt; endl; 44 cout \u0026lt;\u0026lt; myInt \u0026lt;\u0026lt; endl; 45} 赋值运算符重载（=） C++编译器至少给一个类添加4个函数：\n默认构造函数 默认析构函数 默认拷贝构造函数 赋值运算符 由于编译器提供的赋值运算只进行浅拷贝，因此当类中存在存储在堆区的属性时，在执行析构函数时，会产生堆区内存重复释放的错误\n1//使用默认赋值运算时 如果有存储在堆区的属性 在执行析构函数时 会产生堆区内存重复释放的错误 2class Person 3{ 4 public: 5 int *age; 6 Person(int a) 7 { 8 age = new int(a); 9 }; 10 ~Person() 11 { 12 if (age != NULL) { 13 delete age; 14 age = NULL; 15 }; 16 }; 17}; 18 19int main() 20{ 21 Person p1(18); 22 cout \u0026lt;\u0026lt; \u0026#34;p1.age = \u0026#34; \u0026lt;\u0026lt; p1.age \u0026lt;\u0026lt; \u0026#34;; *p1.age = \u0026#34; \u0026lt;\u0026lt; *p1.age \u0026lt;\u0026lt;endl; 23 Person p2(20); 24 cout \u0026lt;\u0026lt; \u0026#34;p2.age = \u0026#34; \u0026lt;\u0026lt; p2.age \u0026lt;\u0026lt; \u0026#34;; *p2.age = \u0026#34; \u0026lt;\u0026lt; *p2.age \u0026lt;\u0026lt;endl; 25 p2 = p1; 26 cout \u0026lt;\u0026lt; \u0026#34;p2.age = \u0026#34; \u0026lt;\u0026lt; p2.age \u0026lt;\u0026lt; \u0026#34;; *p2.age = \u0026#34; \u0026lt;\u0026lt; *p2.age \u0026lt;\u0026lt;endl; 27 return 0; 28} 在上面的代码中，p2 = p1 只发生了浅拷贝，即将 p1.age 的值（堆区的一个地址）赋值给了 p2.age，这导致 p1.age 与 p2.age 指向了同一块堆区地址，因此在执行析构的时候，会发生堆区内存重复释放\n解决上述问题，需要对赋值运算符进行重载，进行深拷贝\n1//赋值运算符重载 2//使用默认赋值运算时 如果有存储在堆区的属性 在执行析构函数时 会产生堆区内存重复释放的错误 3class Person 4{ 5 public: 6 int *age; 7 Person(int a) 8 { 9 age = new int(a); 10 }; 11 ~Person() 12 { 13 if (age != NULL) { 14 delete age; 15 age = NULL; 16 }; 17 }; 18 //返回引用类型 以保证能够进行连续赋值 19 Person\u0026amp; operator=(Person \u0026amp;p) 20 { 21 //注意 如果赋值前已有堆区数据，要先释放堆区的数据 22 if (age != NULL) 23 { 24 delete age; 25 age = NULL; 26 }; 27 age = new int(*p.age); 28 return *this; 29 } 30}; 31 32int main() 33{ 34 Person p1(18); 35 cout \u0026lt;\u0026lt; \u0026#34;p1.age = \u0026#34; \u0026lt;\u0026lt; p1.age \u0026lt;\u0026lt; \u0026#34;; *p1.age = \u0026#34; \u0026lt;\u0026lt; *p1.age \u0026lt;\u0026lt;endl; 36 Person p2(20); 37 cout \u0026lt;\u0026lt; \u0026#34;p2.age = \u0026#34; \u0026lt;\u0026lt; p2.age \u0026lt;\u0026lt; \u0026#34;; *p2.age = \u0026#34; \u0026lt;\u0026lt; *p2.age \u0026lt;\u0026lt;endl; 38 Person p3(22); 39 cout \u0026lt;\u0026lt; \u0026#34;p3.age = \u0026#34; \u0026lt;\u0026lt; p3.age \u0026lt;\u0026lt; \u0026#34;; *p3.age = \u0026#34; \u0026lt;\u0026lt; *p3.age \u0026lt;\u0026lt;endl; 40 p3 = p2 = p1; 41 cout \u0026lt;\u0026lt; \u0026#34;p1.age = \u0026#34; \u0026lt;\u0026lt; p1.age \u0026lt;\u0026lt; \u0026#34;; *p1.age = \u0026#34; \u0026lt;\u0026lt; *p1.age \u0026lt;\u0026lt;endl; 42 cout \u0026lt;\u0026lt; \u0026#34;p2.age = \u0026#34; \u0026lt;\u0026lt; p2.age \u0026lt;\u0026lt; \u0026#34;; *p2.age = \u0026#34; \u0026lt;\u0026lt; *p2.age \u0026lt;\u0026lt;endl; 43 cout \u0026lt;\u0026lt; \u0026#34;p3.age = \u0026#34; \u0026lt;\u0026lt; p3.age \u0026lt;\u0026lt; \u0026#34;; *p3.age = \u0026#34; \u0026lt;\u0026lt; *p3.age \u0026lt;\u0026lt;endl; 44 return 0; 45} 关系运算符重载 作用：定义自定义类型的比较\n1//关系运算符重载 2class Person 3{ 4 public: 5 string Name; 6 int Age; 7 Person(string n, int a) 8 { 9 Name = n; 10 Age = a; 11 }; 12 13 bool operator==(Person \u0026amp;p) 14 { 15 if (this-\u0026gt;Name == p.Name \u0026amp;\u0026amp; this-\u0026gt;Age == p.Age) 16 { 17 return true; 18 } 19 else 20 { 21 return false; 22 }; 23 }; 24 25 bool operator!=(Person \u0026amp;p) 26 { 27 if (this-\u0026gt;Name == p.Name \u0026amp;\u0026amp; this-\u0026gt;Age == p.Age) 28 { 29 return false; 30 } 31 else 32 { 33 return true; 34 }; 35 }; 36}; 37 38int main() 39{ 40 Person p1(\u0026#34;Tom\u0026#34;, 18); 41 Person p2(\u0026#34;Tom\u0026#34;, 18); 42 Person p3(\u0026#34;Jim\u0026#34;, 22); 43 if (p1 == p2) 44 { 45 cout \u0026lt;\u0026lt; \u0026#34;p1 = p2\u0026#34; \u0026lt;\u0026lt; endl; 46 } 47 else 48 { 49 cout \u0026lt;\u0026lt; \u0026#34;p1 != p2\u0026#34; \u0026lt;\u0026lt; endl; 50 }; 51 if (p1 != p3) 52 { 53 cout \u0026lt;\u0026lt; \u0026#34;p1 != p3\u0026#34; \u0026lt;\u0026lt; endl; 54 } 55 else 56 { 57 cout \u0026lt;\u0026lt; \u0026#34;p1 = p3\u0026#34; \u0026lt;\u0026lt; endl; 58 }; 59} 函数调用运算符重载 函数调用运算符（）也可以重载 由于重载后使用的方式非常像函数的调用，因此称为仿函数 仿函数没有固定写法，非常灵活 1//函数调用运算符重载 2class MyAdd 3{ 4 public: 5 int operator()(int a, int b) 6 { 7 return a + b; 8 }; 9}; 10 11int main() 12{ 13 MyAdd m1; 14 cout \u0026lt;\u0026lt; m1(10, 20) \u0026lt;\u0026lt; endl; 15 //匿名函数对象 16 //MyAdd()创建了一个匿名的MyAdd对象 17 //该匿名对象调用了重载的函数调用运算符 18 cout \u0026lt;\u0026lt; MyAdd()(20, 40) \u0026lt;\u0026lt; endl; 19 return 0; 20} 继承——面向对象的三大特征之一 作用：减少重复代码\n基本语法 $class 子类 : 继承方式 父类$\n1//继承语法： 2//class 子类（派生类） : 继承方式 父类（基类） 3class Person 4{ 5public: 6 string Name; 7 int Age; 8 void getName() 9 { 10 cout \u0026lt;\u0026lt; Name \u0026lt;\u0026lt; endl; 11 }; 12}; 13 14class Student : public Person 15{ 16public: 17 int Score; 18 void getScore() 19 { 20 cout \u0026lt;\u0026lt; Score \u0026lt;\u0026lt; endl; 21 }; 22 Student(string n, int a, int s) 23 { 24 Name = n; 25 Age = a; 26 Score = s; 27 }; 28}; 29ostream\u0026amp; operator\u0026lt;\u0026lt;(ostream \u0026amp;cout, Student \u0026amp;s) 30{ 31 cout \u0026lt;\u0026lt; typeid(s).name() \u0026lt;\u0026lt; \u0026#34;{\u0026#34; \u0026lt;\u0026lt; endl; 32 cout \u0026lt;\u0026lt; \u0026#34; Name = \u0026#34; \u0026lt;\u0026lt; s.Name \u0026lt;\u0026lt; endl; 33 cout \u0026lt;\u0026lt; \u0026#34; Age = \u0026#34; \u0026lt;\u0026lt; s.Age \u0026lt;\u0026lt; endl; 34 cout \u0026lt;\u0026lt; \u0026#34; Score = \u0026#34; \u0026lt;\u0026lt; s.Score \u0026lt;\u0026lt; endl; 35 cout \u0026lt;\u0026lt; \u0026#34;};\u0026#34; \u0026lt;\u0026lt; endl; 36 return cout; 37} 38 39class Teacher : public Person 40{ 41 string Course; 42 void getCourse() 43 { 44 cout \u0026lt;\u0026lt; Course \u0026lt;\u0026lt; endl; 45 }; 46}; 47 48int main() 49{ 50 Student s1(\u0026#34;Tom\u0026#34;, 18, 99); 51 cout \u0026lt;\u0026lt; s1 \u0026lt;\u0026lt; endl; 52 return 0; 53} 继承方式 子类无法访问父类的 private 属性\n公共继承：\n父类中的 public 与 protected 属性在子类中仍是 public 与 protected 属性\n保护继承：\n父类中的 public 属性在子类中变为 protected 属性，\n父类中的 protected 属性在子类中仍是 protected 属性\n私有继承\n父类中的 public 属性在子类中变为 private 属性，\n父类中的 protected 属性在子类中仍是 private 属性\n继承中的对象模型 父类中的所有非静态成员属性都会被子类继承 父类中的 private 属性也会被子类继承，但是被编译器隐藏了，因此子类无法访问 1//继承中的对象模型 2class Person 3{ 4public: 5 int Age; 6protected: 7 int Money; 8private: 9 int Phone; 10}; 11 12class Student : public Person 13{ 14public: 15 int Score; 16}; 17 18int main() 19{ 20 Student s1; 21 cout \u0026lt;\u0026lt; \u0026#34;size of s1: \u0026#34; \u0026lt;\u0026lt; sizeof(s1) \u0026lt;\u0026lt; endl; 22 return 0; 23}; 继承中的构造和析构顺序 子类在继承父类后，当创建子类对象时，也会调用父类的构造函数\n在创建一个子类对象时：\n先构造父类，再构造子类 先析构子类，再析构父类 1//继承中的构造与析构函数 2class Father 3{ 4public: 5 Father() 6 { 7 cout \u0026lt;\u0026lt; \u0026#34;Father的构造调用\u0026#34; \u0026lt;\u0026lt; endl; 8 }; 9 ~Father() 10 { 11 cout \u0026lt;\u0026lt; \u0026#34;Father的析构调用\u0026#34; \u0026lt;\u0026lt; endl; 12 }; 13}; 14 15class Son : public Father 16{ 17public: 18 Son() 19 { 20 cout \u0026lt;\u0026lt; \u0026#34;Son的构造调用\u0026#34; \u0026lt;\u0026lt; endl; 21 }; 22 ~Son() 23 { 24 cout \u0026lt;\u0026lt; \u0026#34;Son的析构调用\u0026#34; \u0026lt;\u0026lt; endl; 25 }; 26}; 27 28int main() 29{ 30 Son s; 31 return 0; 32}; 继承中同名成员的处理方式 当子类与父类中出现同名的成员时：\n访问子类的同名成员属性时，直接访问 访问父类的同名成员属性时，加作用域 如果子类中出现与父类同名的成员函数，子类的同名成员会隐藏掉父类中所有的同名成员函数，需要加作用域访问父类中的同名成员函数 1//继承中同名成员属性的处理方式 2class Father 3{ 4public: 5 int A; 6 Father() 7 { 8 A = 100; 9 }; 10 void func() 11 { 12 cout \u0026lt;\u0026lt; \u0026#34;Father中的func调用\u0026#34; \u0026lt;\u0026lt; endl; 13 }; 14 void func(int a) 15 { 16 cout \u0026lt;\u0026lt; \u0026#34;Father中的func(int a)调用\u0026#34; \u0026lt;\u0026lt; endl; 17 }; 18}; 19 20class Son : public Father 21{ 22public: 23 int A; 24 Son() 25 { 26 A = 200; 27 }; 28 void func() 29 { 30 cout \u0026lt;\u0026lt; \u0026#34;Son中的func调用\u0026#34; \u0026lt;\u0026lt; endl; 31 }; 32}; 33 34int main() 35{ 36 Son s1; 37 cout \u0026lt;\u0026lt; \u0026#34;s1.A: \u0026#34; \u0026lt;\u0026lt; s1.A \u0026lt;\u0026lt; endl; 38 cout \u0026lt;\u0026lt; \u0026#34;s1.Father::A: \u0026#34; \u0026lt;\u0026lt; s1.Father::A \u0026lt;\u0026lt; endl; 39 s1.func(); 40 s1.Father::func(); 41 //如果子类中出现与父类同名的成员函数，子类的同名成员会隐藏掉父类中所有的同名成员函数 42 //即父类中的func(int a)会被隐藏 43 //因此 s1.func(10) 会调用失败: 44 //error: too many arguments to function call, expected 0, have 1; did you mean \u0026#39;Father::func\u0026#39;? 45 //s1.func(10); 46 s1.Father::func(10); 47 return 0; 48}; 继承同名静态成员的处理方式 静态成员和非静态成员出现同名时，处理方式一致：\n访问子类同名成员，直接访问 访问父类同名成员，需要加作用域 如果子类中出现与父类同名的成员函数，子类的同名成员会隐藏掉父类中所有的同名成员函数，需要加作用域访问父类中的同名成员函数 1//继承同名静态成员的处理方式 2class Father 3{ 4public: 5 static int A; 6 static void func() 7 { 8 cout \u0026lt;\u0026lt; \u0026#34;Father中的func调用\u0026#34; \u0026lt;\u0026lt; endl; 9 }; 10 static void func(int a) 11 { 12 cout \u0026lt;\u0026lt; \u0026#34;Father中的func(int a)调用\u0026#34; \u0026lt;\u0026lt; endl; 13 }; 14}; 15int Father::A = 100; 16class Son : public Father 17{ 18public: 19 static int A; 20 static void func() 21 { 22 cout \u0026lt;\u0026lt; \u0026#34;Son中的func调用\u0026#34; \u0026lt;\u0026lt; endl; 23 }; 24}; 25int Son::A = 200; 26 27int main() 28{ 29 Son s1; 30 cout \u0026lt;\u0026lt; \u0026#34;通过对象访问：\u0026#34; \u0026lt;\u0026lt; endl; 31 cout \u0026lt;\u0026lt; \u0026#34;s1.A \u0026#34; \u0026lt;\u0026lt; s1.A \u0026lt;\u0026lt; endl; 32 cout \u0026lt;\u0026lt; \u0026#34;s1.Father::A \u0026#34; \u0026lt;\u0026lt; s1.Father::A \u0026lt;\u0026lt; endl; 33 s1.func(); 34 s1.Father::func(); 35 //s1.func(900); 36 s1.Father::func(900); 37 cout \u0026lt;\u0026lt; \u0026#34;通过类名访问：\u0026#34; \u0026lt;\u0026lt; endl; 38 cout \u0026lt;\u0026lt; \u0026#34;Son::A \u0026#34; \u0026lt;\u0026lt; Son::A \u0026lt;\u0026lt; endl; 39 //Son::表示通过类名Son访问，Father::表示访问父类作用域下 40 cout \u0026lt;\u0026lt; \u0026#34;Son::Father::A \u0026#34; \u0026lt;\u0026lt; Son::Father::A \u0026lt;\u0026lt; endl; 41 Son::func(); 42 Son::Father::func(); 43 //Son::func(900); 44 Son::Father::func(900); 45 return 0; 46}; 多继承语法 C++允许一个类继承多个类\n语法：class 子类 : 继承方式 父类1, 继承方式 父类2...\n多继承可能会引发父类中有同名成员出现，需要加作用域区分\nC++实际开发中不建议使用多继承\n1//多继承 2class Father1 3{ 4public: 5 int A; 6}; 7class Father2 8{ 9public: 10 int A; 11}; 12class Son : public Father1, public Father2 13{ 14public: 15 int A; 16 int B; 17}; 18 19int main() 20{ 21 Son s1; 22 cout \u0026lt;\u0026lt; \u0026#34;size of s1 = \u0026#34; \u0026lt;\u0026lt; sizeof(s1) \u0026lt;\u0026lt; endl; 23 return 0; 24}; 菱形继承 菱形继承概念：\n两个派生类继承同一个基类 又有某个类同时继承这两个派生类 这样的继承被称为菱形继承，或者钻石继承\n菱形继承的案例：\n有一个基类 动物 派生类 驴 和 马 继承基类 动物 骡子 又同时继承了 驴 和 马 这两个派生类 由菱形继承产生的问题：\n骡子 同时继承了 驴 和 马 的属性，驴 和 马 都继承了 动物 的属性，因此在 骡子 中，会产生两份 动物 的属性，即产生二义性 事实上，在 骡子 中，应该只需要一份 动物 的属性 通过虚继承解决菱形继承的问题：\n1//菱形继承 2class Animal 3{ 4public: 5 int Age; 6}; 7//常规的继承 8//class Horse : public Animal{}; 9//class Donkey : public Animal{}; 10//加virtual关键字 表明Horse虚继承Animal 11class Horse : virtual public Animal{}; 12 13class Donkey : virtual public Animal{}; 14 15class Mule : public Horse, public Donkey 16{ 17public: 18 int B; 19}; 20 21int main() 22{ 23 Mule m1; 24 cout \u0026lt;\u0026lt; sizeof(m1) \u0026lt;\u0026lt; endl; 25 return 0; 26} 在clang中通过命令：-Xclang -fdump-record-layouts查看类的内存布局\n使用方法：\n1clang++ -Xclang -fdump-record-layouts source.cpp -o output 可以看到，在使用虚继承之后，Mule0 的内存布局变为 Mule，不再直接存储由 Horse0 与 Donkey0 继承来的 Age 的值，而是转而存储两个叫做 vtable pointer（虚表指针）的指针，这两个指针分别指向各自的vtable（虚表），vtable 中的信息，包括虚函数的布局、偏移量和具体指向的实现。\n在clang中通过命令：-Xclang -fdump-vtable-layouts查看 vtable 的布局\n使用方法：\n1clang++ -Xclang -fdump-vtable-layouts example.cpp -o example vtable for (\u0026lsquo;Horse\u0026rsquo;, 0) 这张表中，base_offset 属性表示在Mule的内存中，Horse vtable pointer 到 从 Animal 继承来的 Age 的偏移量为20位；同理，在vtable for (\u0026lsquo;Donkey\u0026rsquo;, 8) 这张表中，base_offset 属性表示在Mule的内存中，Donkey vtable pointer 到 从 Animal 继承来的 Age 的偏移量为12位；通过偏移，两者都指向了Mule内存中的同一个位置，即从 Animal 继承来的 Age 的位置，通过这种方式，使得 Mule 能够只保存一份 Age 的值。\n多态——面向对象的三大特征之一 多态的基本概念 多态分为两类：\n静态多态：函数重载 和 运算符重载 属于静态多态 动态多态：派生类 和 虚函数 实现运行时多态 静态多态和动态多态的区别：\n静态多态的函数地址早绑定——编译阶段确定函数地址 动态多态的函数地址晚绑定——运行阶段确定函数地址 多态需要满足的条件：\n有继承关系 子类重写父类中的虚函数（重写：函数的 返回值类型 函数名 参数列表 完全一致，注意与重载区分） 多态的使用：\n父类指针或引用指向子类对象 1//多态 2class Animal0 3{ 4public: 5 void Speak() 6 { 7 cout \u0026lt;\u0026lt; \u0026#34;Animal0 speak\u0026#34; \u0026lt;\u0026lt; endl; 8 }; 9}; 10 11class Dog0 : public Animal0 12{ 13public: 14 void Speak() 15 { 16 cout \u0026lt;\u0026lt; \u0026#34;Dog0 speak\u0026#34; \u0026lt;\u0026lt; endl; 17 }; 18}; 19 20class Cat0 : public Animal0 21{ 22public: 23 void Speak() 24 { 25 cout \u0026lt;\u0026lt; \u0026#34;Cat0 speak\u0026#34; \u0026lt;\u0026lt; endl; 26 }; 27}; 28 29class Animal 30{ 31public: 32 virtual void Speak() 33 { 34 cout \u0026lt;\u0026lt; \u0026#34;Animal speak\u0026#34; \u0026lt;\u0026lt; endl; 35 }; 36}; 37 38class Cat : public Animal 39{ 40public: 41 void Speak() 42 { 43 cout \u0026lt;\u0026lt; \u0026#34;Cat speak\u0026#34; \u0026lt;\u0026lt; endl; 44 }; 45}; 46 47class Dog : public Animal 48{ 49public: 50 void Speak() 51 { 52 cout \u0026lt;\u0026lt; \u0026#34;Dog speak\u0026#34; \u0026lt;\u0026lt; endl; 53 }; 54}; 55 56//Animal作为Cat的父类 其引用可以接收子类对象 57//即 允许 doSpeak(cat) 58void doSpeak0(Animal0 \u0026amp; animal0) 59{ 60 animal0.Speak(); 61}; 62 63void doSpeak(Animal \u0026amp; animal) 64{ 65 animal.Speak(); 66}; 67 68int main() 69{ 70 Dog0 dog0; 71 Cat0 cat0; 72 //此时调用的是Animal.Speak() 73 //因为在编译时 doSpeak 中的 animal.Speak() 已经被确定就是Animal.Speak() 74 doSpeak0(dog0); 75 doSpeak0(cat0); 76 cout \u0026lt;\u0026lt; \u0026#34;---------------------\u0026#34; \u0026lt;\u0026lt; endl; 77 Dog dog; 78 Cat cat; 79 //如果要使doSpeak(cat)能够调用Cat.Speak 80 //则需要在声明 Animal.Speak 时 添加 virtual 关键词 81 //表明 Animal 中的 Speak 函数 是一个虚函数 82 //则 doSpeak 中的 animal.Speak 依据具体传入 doSpeak 的对象进行绑定 83 //传入的是cat 因此绑定的是 Cat.Speak 84 doSpeak(cat); 85 //传入的是sheep 因此绑定的是 Sheep.Speak 86 doSpeak(dog); 87 return 0; 88}; 多态的原理 C++中，通过添加virtual关键字，使得父类将原本要存储的函数改为存储一个指针（vfptr），该指针指向原本要存储的函数（事实上，该指针指向一个vtable，在这个vtable中，存储了当前类应该指向哪个函数），当子类继承这个父类时，会将这个指针也继承过来（值拷贝），当子类重写这个函数时，子类中的这个指针就会发生改变，改为指向重写后的函数（即子类的vfptr改为指向属于子类的vtable，在子类的vtable中，指向的的是在子类中被重写后的函数），通过这种方式，使得使得当父类引用或指针接收一个子类对象时，能够成功调用在子类中被重写的函数，且不会对父类造成影响。\n1class Animal 2{ 3public: 4 virtual void Speak() 5 { 6 cout \u0026lt;\u0026lt; \u0026#34;Animal Speak\u0026#34; \u0026lt;\u0026lt; endl; 7 }; 8}; 9 10class Cat : public Animal 11{ 12public: 13 void Speak() 14 { 15 cout \u0026lt;\u0026lt; \u0026#34;Cat Speak\u0026#34; \u0026lt;\u0026lt; endl; 16 }; 17}; 18 19int main() 20{ 21 Cat cat; 22 cout \u0026lt;\u0026lt; \u0026#34;size of cat = \u0026#34; \u0026lt;\u0026lt; sizeof(cat) \u0026lt;\u0026lt; endl; 23 return 0; 24}; 使用命令-Xclang -fdump-record-layouts查看Cat类的内存布局\n使用命令-Xclang -fdump-vtable-layouts查看Cat类中的vtable pointer指向的vtable的具体布局\n多态的案例——实现一个计算器 多态的优点\n代码组织结构清晰 可读性强 利于前期和后期的扩展以及维护 1//多态的案例———实现一个计算器 2//一般的实现方式 3class Calculator 4{ 5public: 6 int num1; 7 int num2; 8 9 int getResult(string oper) 10 { 11 if (oper == \u0026#34;+\u0026#34;) 12 { 13 return num1 + num2; 14 }; 15 //如果后续需要加入减法运算 则需要对 getResule 这个函数做修改 16 if (oper == \u0026#34;-\u0026#34;) 17 { 18 return num1 - num2; 19 }; 20 return -1; 21 }; 22}; 23 24void test01() 25{ 26 Calculator cal; 27 cal.num1 = 20; 28 cal.num2 = 10; 29 cout \u0026lt;\u0026lt; cal.num1 \u0026lt;\u0026lt; \u0026#34;+\u0026#34; \u0026lt;\u0026lt; cal.num2 \u0026lt;\u0026lt; \u0026#34;=\u0026#34; \u0026lt;\u0026lt; cal.getResult(\u0026#34;+\u0026#34;) \u0026lt;\u0026lt; endl; 30 cout \u0026lt;\u0026lt; cal.num1 \u0026lt;\u0026lt; \u0026#34;-\u0026#34; \u0026lt;\u0026lt; cal.num2 \u0026lt;\u0026lt; \u0026#34;=\u0026#34; \u0026lt;\u0026lt; cal.getResult(\u0026#34;-\u0026#34;) \u0026lt;\u0026lt; endl; 31}; 32 33//利用多态实现 34//抽象出一个计算机对象 包含两个int类型的数 以及一个计算方法getResult 35//但getResult中并不定义具体的计算方法 36class AbstractClaculator 37{ 38public: 39 int num1; 40 int num2; 41 42 virtual int getResult() 43 { 44 return 0; 45 }; 46}; 47 48class AddCalculator : public AbstractClaculator 49{ 50public: 51 //在具体的计算方法中重写getResult 52 int getResult() 53 { 54 return num1 + num2; 55 }; 56}; 57 58class SubCalculator : public AbstractClaculator 59{ 60public: 61 //在具体的计算方法中重写getResult 62 int getResult() 63 { 64 return num1 - num2; 65 }; 66}; 67 68void test02() 69{ 70 //通过父类指针指向子类实例的方式触发多态 71 AbstractClaculator * cal = new AddCalculator; 72 cal-\u0026gt;num1 = 20; 73 cal-\u0026gt;num2 = 10; 74 cout \u0026lt;\u0026lt; cal-\u0026gt;num1 \u0026lt;\u0026lt; \u0026#34;+\u0026#34; \u0026lt;\u0026lt; cal-\u0026gt;num2 \u0026lt;\u0026lt; \u0026#34;=\u0026#34; \u0026lt;\u0026lt; cal-\u0026gt;getResult() \u0026lt;\u0026lt; endl; 75 //注意释放堆区内存 76 delete cal; 77 cal = new SubCalculator; 78 cal-\u0026gt;num1 = 20; 79 cal-\u0026gt;num2 = 10; 80 cout \u0026lt;\u0026lt; cal-\u0026gt;num1 \u0026lt;\u0026lt; \u0026#34;-\u0026#34; \u0026lt;\u0026lt; cal-\u0026gt;num2 \u0026lt;\u0026lt; \u0026#34;=\u0026#34; \u0026lt;\u0026lt; cal-\u0026gt;getResult() \u0026lt;\u0026lt; endl; 81 delete cal; 82}; 83 84int main() 85{ 86 cout \u0026lt;\u0026lt; \u0026#34;一般的实现方式:\u0026#34; \u0026lt;\u0026lt; endl; 87 test01(); 88 cout \u0026lt;\u0026lt; \u0026#34;使用多态的实现方式:\u0026#34; \u0026lt;\u0026lt; endl; 89 test02(); 90 return 0; 91}; 纯虚函数和抽象类 在多态中，通常父类中的虚函数的实现是毫无意义的，主要都是调用子类中重写的内容，因此可以将父类中的虚函数改为纯虚函数\n纯虚函数语法：virtual 返回值类型 函数名(参数列表) = 0\n当类中有了纯虚函数，这个类也称为抽象类\n抽象类的特点：\n抽象类无法实例化对象 子类必须重写抽象类中的纯虚函数，否则也属于抽象类 虚析构和纯虚析构 在使用多态时，如果子类中有属性开辟到堆区，那么父类指针在释放时无法调用到子类的析构函数\n解决方式：将父类中的析构函数改为虚析构或者纯虚析构\n虚析构与纯虚析构的共性：\n可以解决父类指针释放子类对象的问题 都需要有具体的函数实现 虚析构与纯虚析构的区别：\n如果是纯虚析构，该类属于抽象类，无法实例化对象 1//虚析构和纯虚析构 2//当父类指针指向子类对象时发生多态， 3//这会产生一个问题：当子类中有开辟到堆区的属性时 4//释放父类指针时只能调用到父类的析构函数，从而导致子类中开辟到堆区的内存无法释放： 5class Animal 6{ 7public: 8 int Age; 9 Animal() 10 { 11 cout \u0026lt;\u0026lt; \u0026#34;Animal的构造函数\u0026#34; \u0026lt;\u0026lt; endl; 12 }; 13 14 //普通的析构函数 15 // ~Animal() 16 // { 17 // cout \u0026lt;\u0026lt; \u0026#34;Animal的析构函数\u0026#34; \u0026lt;\u0026lt; endl; 18 // }; 19 20 //虚析构函数 21 // virtual ~Animal() 22 // { 23 // cout \u0026lt;\u0026lt; \u0026#34;Animal的虚析构函数\u0026#34; \u0026lt;\u0026lt; endl; 24 // }; 25 26 //纯虚析构函数 27 virtual ~Animal() = 0; 28}; 29//注意：当父类中声明的是纯虚析构函数时，还需要额外定义该父类的析构函数的具体实现 30//这是因为 当父类中也有开辟到堆区的属性时，仍需要具体的析构函数去释放 31Animal::~Animal() 32{ 33 cout \u0026lt;\u0026lt; \u0026#34;Animal的纯虚析构函数\u0026#34; \u0026lt;\u0026lt; endl; 34}; 35 36class Cat : public Animal 37{ 38public: 39 string * Name; 40 Cat(string name) 41 { 42 cout \u0026lt;\u0026lt; \u0026#34;Cat的构造函数\u0026#34; \u0026lt;\u0026lt; endl; 43 Name = new string(name); 44 }; 45 ~Cat() 46 { 47 cout \u0026lt;\u0026lt; \u0026#34;Cat的析构函数\u0026#34; \u0026lt;\u0026lt; endl; 48 if(Name != NULL) 49 { 50 delete Name; 51 }; 52 }; 53}; 54 55int main() 56{ 57 Animal * c1 = new Cat(\u0026#34;Tom\u0026#34;); 58 delete c1; 59 return 0; 60} 文件操作 程序运行时产生的数据都属于临时数据，程序一旦运行结束都会被释放\n通过文件可以将数据持久化\nC++中对文件的操作需要包含头文件**\u0026lt;fstream\u0026gt;**\n文件类型分为两种：\n**文本文件：**文件以文本的ASCII码形式存储在计算机中，可以用记事本等程序打开 **二进制文件：**文件以文本的二进制形式存储在计算机中，用户一般不能直接读懂 操作文件的三大类：\nofstream：写操作 ifstream：读操作 fstream：读写操作 文本文件 写文件 写文件的步骤：\n包含头文件 ​\t#inlcude\u0026lt;fstream\u0026gt;\n创建流对象 ​\tofstream ofs\n打开文件 ​\tofs.open(\u0026quot;文件路径\u0026quot;, 打开方式)\n写数据 ​\tofs \u0026lt;\u0026lt; \u0026quot;写入的数据\u0026quot;\n关闭文件 ​\tofs.close()\n文件的打开方式：\n打开方式 解释 ios::in 为读文件而打开文件 ios::out 为写文件而打开文件 ios::ate 初始位置：文件尾，即打开文件后定位到文件尾 ios::app 以追加方式写文件 ios::trunc 如果文件已存在，先删除，再创建 ios::binary 二进制方式 **注意：**文件打开方式可以配合使用，利用 | 操作符\n**例如：**用二进制方式写文件 ios::binary | ios::out\n1#include \u0026lt;fstream\u0026gt; 2 3int main() 4{ 5 ofstream ofs; 6 ofs.open(\u0026#34;./test.txt\u0026#34;, ios::out); 7 ofs \u0026lt;\u0026lt; \u0026#34;hello\u0026#34; \u0026lt;\u0026lt; endl; 8 ofs \u0026lt;\u0026lt; \u0026#34;world\u0026#34;; 9 ofs \u0026lt;\u0026lt; \u0026#34;hi\u0026#34;; 10 ofs.close(); 11 return 0; 12}; 读文件 读文件与写文件的步骤相似，但是读取方式相对比较多\n读文件步骤如下：\n包含头文件\n#include \u0026lt;fstream\u0026gt;\n创建流对象\nifstream ifs\n打开文件并判断文件是否打开成功\nifs.open(\u0026quot;文件路径\u0026quot;, 打开方式)\n读数据\n四种方式读取\n关闭文件\nifs.close()\n1#include \u0026lt;fstream\u0026gt; 2#include \u0026lt;string\u0026gt; 3 4//读文本文件 5int main() 6{ 7 ifstream ifs; 8 ifs.open(\u0026#34;./test.txt\u0026#34;, ios::in); 9 //判断文件是否打开成功 10 if (!ifs.is_open()) 11 { 12 cout \u0026lt;\u0026lt; \u0026#34;Error: open file failed\u0026#34; \u0026lt;\u0026lt; endl; 13 return -1; 14 }; 15 //读取方式一 16 char buf[1024] = { 0 }; 17 while (ifs \u0026gt;\u0026gt; buf) 18 { 19 cout \u0026lt;\u0026lt; buf \u0026lt;\u0026lt;endl; 20 }; 21 22 //读取方式二 23 // char buf[1024] = { 0 }; 24 // while(ifs.getline(buf, sizeof(buf))) 25 // { 26 // cout \u0026lt;\u0026lt; buf \u0026lt;\u0026lt; endl; 27 // }; 28 29 //读取方式三 30 // string buf; 31 // while(getline(ifs, buf)) 32 // { 33 // cout \u0026lt;\u0026lt; buf \u0026lt;\u0026lt; endl; 34 // }; 35 36 //读取方式四 37 // char c; 38 // while((c = ifs.get()) != EOF) // EOF end of file 39 // { 40 // cout \u0026lt;\u0026lt; c; 41 // }; 42 43 ifs.close(); 44 return 0; 45}; 二进制文件 以二进制的方式对文件进行读写操作\n打开方式要指定为 ios::binary\n1#include \u0026lt;fstream\u0026gt; 2 3//读写二进制文件 4class Person 5{ 6public: 7 char Name[64]; 8 int Age; 9}; 10 11int main() 12{ 13 Person p = {\u0026#34;Tom\u0026#34;, 18}; 14 //写文件 15 // ofstream ofs; 16 // ofs.open(\u0026#34;./person.txt\u0026#34;, ios::out | ios::binary); 17 ofstream ofs(\u0026#34;./person.txt\u0026#34;, ios::out | ios::binary); 18 ofs.write((const char *)\u0026amp;p, sizeof(p)); 19 ofs.close(); 20 21 //读文件 22 ifstream ifs(\u0026#34;./person.txt\u0026#34;, ios::in | ios::binary); 23 if (!ifs.is_open()) 24 { 25 cout \u0026lt;\u0026lt; \u0026#34;Error: open file failed\u0026#34; \u0026lt;\u0026lt; endl; 26 }; 27 Person p1; 28 ifs.read((char *)\u0026amp;p1, sizeof(p1)); 29 cout \u0026lt;\u0026lt; \u0026#34;Name: \u0026#34; \u0026lt;\u0026lt; p1.Name \u0026lt;\u0026lt; endl; 30 cout \u0026lt;\u0026lt; \u0026#34;Age: \u0026#34; \u0026lt;\u0026lt; p1.Age \u0026lt;\u0026lt; endl; 31 ifs.close(); 32 return 0; 33} ","date":"2024-03-16T14:18:58+08:00","image":"https://chaihaojian.github.io/post/c_plus_note/chapter2_%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/cover_huae254b8ee1ab91911036d94a912fa4f7_868221_120x120_fill_q75_box_smart1.JPG","permalink":"https://chaihaojian.github.io/post/c_plus_note/chapter2_%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/","title":"C++核心编程"},{"content":"","date":"2024-03-09T13:31:05+08:00","image":"https://chaihaojian.github.io/post/javascript_note/javascript%E5%80%BC%E7%B1%BB%E5%9E%8B%E4%BD%BF%E7%94%A8/cover_hu5d37d57dbb2a2417866d45a70fddc4ea_305553_120x120_fill_q75_box_smart1.JPG","permalink":"https://chaihaojian.github.io/post/javascript_note/javascript%E5%80%BC%E7%B1%BB%E5%9E%8B%E4%BD%BF%E7%94%A8/","title":"Javascript值类型使用"},{"content":"运算符与流程控制 一元运算符的前置与后置操作(++n与n++的区别) 两者在不参与其他运算时结果相同，都是n自增；\n1let a = 1; 2let b = 1; 3++a; 4console.log(a); 5b++; 6console.log(b); 在参与其他运算时，++n先自增，再进行运算；n++先进行运算，再自增。\n1let n = 1; 2let m = 1; 3let f = 2; 4let d = f + ++n;//n先自增，然后运算f + n 5console.log(d); 6console.log(n); 7let e = f + m++;//先运算f + n, 然后n自增 8console.log(e); 9console.log(m); 比较运算符 == 与 === a == b，如果a, b不是相同类型的变量，js会自动将两个变量转换成相同类型再进行比较；a === b 则会直接进行比较。\n1let a = 1; 2let b = \u0026#34;1\u0026#34;; 3console.log(a == b); 4console.log(a \u0026gt;= b); 5console.log(a === b); 逻辑运算符 逻辑与： \u0026amp;\u0026amp;\n逻辑或： ||\n逻辑非： !\n短路运算 1可以表示true；0可以表示false；\n1let a = 1, b = 0; 2console.log(a == true) 3console.log(a == false) 4console.log(b == true) 5console.log(b == false) 在逻辑或进行判断时，如 （a || b）：若a为真，则不再判断b，直接返回真；若a为假，则继续判断b的真假；\n短路运算在赋值中的妙用 1let a = 3; 2let b; 3let c = 4; 4let f = b || a;//b为空，因此将a的值赋给f 5console.log(f); 6let p = c || a;//c不为空，因此不需要判断a，直接将c的值赋给p 7console.log(p); 流程控制 if else 三元表达式 1let h = true?2:5; 2console.log(h); 3let l = false?2:5; 4console.log(l); switch 1let name = \u0026#34;hi\u0026#34; 2switch(name){ 3 case \u0026#34;hello\u0026#34;: 4 console.log(\u0026#34;hello\u0026#34;); 5 break; 6 case \u0026#34;hi\u0026#34;: 7 console.log(\u0026#34;hi\u0026#34;); 8 break; 9 default: 10 console.log(\u0026#34;default\u0026#34;); 11}; while 循环控制 1function genTable(options = {tr: 5, td: 3}){ 2 document.write(`\u0026lt;table border = \u0026#34;1\u0026#34; width=\u0026#34;100%\u0026#34;`); 3 while(options.tr-- != 0){ 4 let td = options.td; 5 document.write(`\u0026lt;tr\u0026gt;`); 6 while(td-- != 0){ 7 document.write(`\u0026lt;td\u0026gt;${td}\u0026lt;/td\u0026gt;`); 8 } 9 document.write(`\u0026lt;/tr\u0026gt;`); 10 } 11 document.write(`\u0026lt;/table\u0026gt;`); 12} 13genTable(); 14document.write(`\u0026lt;br/\u0026gt;`); 15genTable({tr: 3, td: 5}); do while 循环控制 1function genStars(row = 5){ 2 let l = 0; 3 do { 4 let n = 0; 5 do { 6 document.write(\u0026#34;*\u0026#34;); 7 } while (++n \u0026lt;= l); 8 document.write(`\u0026lt;br/\u0026gt;`); 9 } while(++l \u0026lt; row); 10}; 11genStars(); 12document.write(`\u0026lt;br/\u0026gt;`); 13genStars(8); for 循环 1function genStars(row = 5){ 2 for (let i = 1; i \u0026lt;= row; i++){ 3 for (let n = row - i; n \u0026gt; 0; n--){ 4 document.write(`\u0026lt;span style=\u0026#34;color: white\u0026#34;\u0026gt;^\u0026lt;/span\u0026gt;`); 5 } 6 for (let m = i * 2 - 1; m \u0026gt; 0; m--){ 7 document.write(`*`); 8 } 9 document.write(`\u0026lt;br/\u0026gt;`); 10 } 11} 12genStars(); 13document.write(`\u0026lt;br/\u0026gt;`); 14genStars(8); continue 与 break continue：停止当前循环，进行下一次循环；\nbreak：终止当前循环；\n如果需要从子循环直接终止更上一级的循环，需要通过标签：\n1pa: for (let i = 1; i \u0026lt;= 10; i++){ 2 ch: for (let j = 1; j \u0026lt;= 10; j++){ 3 if (j % 2 == 0){ 4 console.log(i, j); 5 } 6 if (i + j \u0026gt; 10){ 7 break pa; 8 }; 9 }; 10}; for-in 与 for-of 1let array = [1, 2, 3, 4]; 2for (let key in array){ 3 console.log(key, array[key]); 4}; 1let array = [1, 2, 3, 4]; 2for (const value of array) { 3 console.log(value); 4}; ","date":"2024-03-06T11:44:29+08:00","image":"https://chaihaojian.github.io/post/javascript_note/%E8%BF%90%E7%AE%97%E7%AC%A6%E4%B8%8E%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/cover_hu7c4cdf01cea81a03b0eb35f8c46fc90c_1264985_120x120_fill_q75_box_smart1.JPG","permalink":"https://chaihaojian.github.io/post/javascript_note/%E8%BF%90%E7%AE%97%E7%AC%A6%E4%B8%8E%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/","title":"运算符与流程控制"},{"content":"C++基础语法 变量 创建变量 1//数据类型 变量名 = 变量初始值; 2int a = 10; 常量 常量的作用 用于记录程序中不可更改的数据\nC++定义常量的两种方式 1.#define 宏常量 1#include \u0026lt;iostream\u0026gt; 2using namespace std; 3 4#define Day 7 5 6int main() 7{ 8 cout \u0026lt;\u0026lt; Day \u0026lt;\u0026lt; endl; 9 10 return 0; 11} 2.const修饰的变量 1#include \u0026lt;iostream\u0026gt; 2using namespace std; 3 4int main() 5{ 6 const int month = 12; 7 8 cout \u0026lt;\u0026lt; month \u0026lt;\u0026lt; endl; 9 10 return 0; 11} 关键字 关键字是C++中预先保留的单词（标识符），在定义变量或常量时，不要用关键字，否则会产生歧义。\n标识符命名规则 标识符不能是关键字；\n标识符只能由字母、数字、下划线组成；\n第一个字符必须为字母或下划线；\n标识符中的字母区分大小写；\n数据类型（给变量或常量分配合适的内存空间） C++规定在创建一个变量或者常量时，必须要指定相应的数据类型，否则无法给变量分配内存。\nsizeof 关键字 利用sizeof关键字可以统计数据类型所占内存大小：sizeof(数据类型 / 变量)\n1#include \u0026lt;iostream\u0026gt; 2using namespace std; 3 4int main() 5{ 6 short num1 = 10; 7 cout \u0026lt;\u0026lt; \u0026#34;space occupied by num1:\u0026#34; \u0026lt;\u0026lt; sizeof(num1) \u0026lt;\u0026lt; endl; 8 //space occupied by num1:2 9 10 int num2 = 10; 11 cout \u0026lt;\u0026lt; \u0026#34;space occupied by int:\u0026#34; \u0026lt;\u0026lt; sizeof(int) \u0026lt;\u0026lt; endl; 12 //space occupied by int:4 13 14 return 0; 15} 整型 C++中能够表示整型的类型有以下几种方式，区别在于所占内存空间不同：\n数据类型 占用空间 取值范围 short（短整型） 2 字节 （-2^15 - 2^15-1） Int（整型） 4 字节 （-2^31 - 2^31-1） long（长整型） Windows为 4 字节，Linux为 4 字节（32 位），8字节（64 位） （-2^31 - 2^31-1） long long（长长整型） 8 字节 （-2^63 - 2^63-1） 当需要保存的值超出当前数据类型的取值范围时，c++会提示警告超出内存，但不会报错，该变量值会变为在该数据类型的取值范围内最接近该变量值的值：\n1#include \u0026lt;iostream\u0026gt; 2using namespace std; 3 4int main() 5{ 6 //短整型 7 short num1 = 10; 8 //整型 9 int num2 = 10; 10 //长整型 11 long num3 = 10; 12 //长长整型 13 long long num4 = 10; 14 15 cout \u0026lt;\u0026lt; \u0026#34;num1:\u0026#34; \u0026lt;\u0026lt; num1 \u0026lt;\u0026lt; endl; 16 cout \u0026lt;\u0026lt; \u0026#34;num2:\u0026#34; \u0026lt;\u0026lt; num2 \u0026lt;\u0026lt; endl; 17 cout \u0026lt;\u0026lt; \u0026#34;num3:\u0026#34; \u0026lt;\u0026lt; num3 \u0026lt;\u0026lt; endl; 18 cout \u0026lt;\u0026lt; \u0026#34;num4:\u0026#34; \u0026lt;\u0026lt; num4 \u0026lt;\u0026lt; endl; 19 20 num1 = 32768; 21 cout \u0026lt;\u0026lt; \u0026#34;num1:\u0026#34; \u0026lt;\u0026lt; num1 \u0026lt;\u0026lt; endl; 22 23 num1 = -32769; 24 cout \u0026lt;\u0026lt; \u0026#34;num1:\u0026#34; \u0026lt;\u0026lt; num1 \u0026lt;\u0026lt; endl; 25 26 return 0; 27} 实型（浮点型） 浮点型变量分为两种：\n单精度 float 双精度 double 两者的区别在于表示的有效数字范围不同。\n数据类型 占用空间 有效数字范围 float 4字节 7位有效数字 double 8字节 15-16位有效数字 1float a = 3.14f;//(float)(3.14F) 建议使用该方法声明一个float变量 2float b = 3.14;//(double)(3.14) 上述两种方法都声明了一个float变量，但第二种方法c++默认值小数3.14是double类型，在声明后需要将double类型的3.14转换为float类型，在变量值后加f则表明3.14是float类型；\n1float a = 3.1415926f; 2float b = 3.14; 3 4cout \u0026lt;\u0026lt; \u0026#34;a = \u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; 5 6double m = 3.1415926; 7cout \u0026lt;\u0026lt; \u0026#34;m = \u0026#34; \u0026lt;\u0026lt; m \u0026lt;\u0026lt; endl; 注意：默认情况下，float和double类型的变量在输出时，都只会显示出6位有效数字。\n科学计数法 1float c = 3e2;//3 * 10^2 2float d = 3e-2;//3 * 10^-2 3cout \u0026lt;\u0026lt; \u0026#34;c = \u0026#34; \u0026lt;\u0026lt; c \u0026lt;\u0026lt; endl; 4cout \u0026lt;\u0026lt; \u0026#34;d = \u0026#34; \u0026lt;\u0026lt; d \u0026lt;\u0026lt; endl; 字符型（表示单个字符） 1char ch = \u0026#39;a\u0026#39;; 2cout \u0026lt;\u0026lt; \u0026#34;ch: \u0026#34; \u0026lt;\u0026lt; ch \u0026lt;\u0026lt; endl; 3cout \u0026lt;\u0026lt; \u0026#34;size of ch: \u0026#34; \u0026lt;\u0026lt; sizeof(ch) \u0026lt;\u0026lt; endl; 4cout \u0026lt;\u0026lt; \u0026#34;ASCII of ch: \u0026#34; \u0026lt;\u0026lt; (int)ch \u0026lt;\u0026lt; endl; 注意：\n在显示字符型变量时，用单引号将字符括起来，不要用双引号； 单引号内只能有一个字符，不可以是字符串； C和C++中字符型变量只占用一个字节； 字符型变量并不是把字符本身放到内存中存储，而是将字符对应的ASCII编码放入到存储单元。 字符型变量对应的ASCII码 a - 97 A - 65 转义字符 用于表示一些不能直接输出的ASCII字符\n转义字符 含义 ASCII码（十进制） \\n 换行 010 \\t 水平制表（跳到下一个TAB位置） 009 \\\\ 代表一个反斜杠字符\u0026quot;\\\u0026quot; 092 字符串型（表示一串字符） C风格字符串 1char str1[] = \u0026#34;hello\u0026#34;; C++风格字符串 1#include\\\u0026lt;string\u0026gt; 2using namespace std； 3 4string str2 = \u0026#34;world\u0026#34;; 注意：使用C++风格字符串需要包含一个头文件 #include\u0026lt;string\u0026gt;和using namespace std\n布尔类型 bool类型只有两个值：\ntrue 表示真，本质是1； false 表示假，本质是0； bool类型占一个字节\n运算符（执行代码的运算） 算数运算符（处理四则运算） 运算符 术语 示例 结果 + - + - * / % 取余 ++ 前置递增（先让变量+1，然后进行表达式运算） a=2; b=++a; a=3; b=3; ++ 后置递增（先进行表达式运算，后让变量+1） a=2; b=a++; a=3; b=2; \u0026ndash; 前置递减 a=2; b=\u0026ndash;a; a=1; b=1; \u0026ndash; 后置递减 a=2; b=a\u0026ndash;; a=1; b=2; 赋值运算符（将表达式的值赋给变量） 运算符 术语 示例 结果 = += -= *= /= %= 比较运算符（用于表达式的比较，返回一个真值或假值） 运算符 术语 示例 结果 == != \u0026lt; \u0026gt; \u0026lt;= \u0026gt;= 逻辑运算符 运算符 术语 示例 结果 ! \u0026amp;\u0026amp; || 程序流程控制结构 顺序结构（程序按顺序执行，不发生跳转） 选择结构（依据条件是否满足，有选择地执行相应功能） if 语句 三目运算符 语法：表达式1 ？表达式2 ：表达式3；\n如果表达式1为真，执行表达式2，并返回表达式2的结果；\n如果表达式1为假，执行表达式3，并返回表达式3的结果；\nswitch 语句 循环结构 数组 数组的特点 数组中的每一个数据元素都是相同的数据类型； 数组是由连续的内存位置组成的； 数组的定义 数据类型 数组名[数组长度]； 数据类型 数组名[数组长度] = {值1，值2 \u0026hellip;}; 数据类型 数组名[] = {值1，值2 \u0026hellip;}; 一维数组 一维数组在内存中的长度 1int arr[5] = {1,2,3,4,5}; 2cout \u0026lt;\u0026lt; \u0026#34;arrdress of arr: \u0026#34; \u0026lt;\u0026lt; arr \u0026lt;\u0026lt; endl; 3cout \u0026lt;\u0026lt; \u0026#34;size of arr: \u0026#34; \u0026lt;\u0026lt; sizeof(arr) \u0026lt;\u0026lt; endl; 4cout \u0026lt;\u0026lt; \u0026#34;size of arr[0]: \u0026#34; \u0026lt;\u0026lt; sizeof(arr[0]) \u0026lt;\u0026lt; endl; 5cout \u0026lt;\u0026lt; \u0026#34;length of arr: \u0026#34; \u0026lt;\u0026lt; sizeof(arr) / sizeof(arr[0]) \u0026lt;\u0026lt; endl; 一维数组的冒泡排序 思路（升序）：\n比较相邻的两个元素，如果第一个比第二个大，就交换它们的位置； 对每一个元素做同样的工作，执行完第一次后，找到数组中的第一个最大值； 重复上述步骤，每次比较次数-1，直到不需要比较； 二维数组 二维数组在内存中的长度 1int arr[2][3] = 2{ 3 {1,2,3}, 4 {4,5,6} 5}; 6 7cout \u0026lt;\u0026lt; \u0026#34;arrdress of arr: \u0026#34; \u0026lt;\u0026lt; arr \u0026lt;\u0026lt; endl; 8cout \u0026lt;\u0026lt; \u0026#34;size of arr: \u0026#34; \u0026lt;\u0026lt; sizeof(arr) \u0026lt;\u0026lt; endl; 9cout \u0026lt;\u0026lt; \u0026#34;size of arr[0]: \u0026#34; \u0026lt;\u0026lt; sizeof(arr[0]) \u0026lt;\u0026lt; endl; 10cout \u0026lt;\u0026lt; \u0026#34;length of arr: \u0026#34; \u0026lt;\u0026lt; sizeof(arr) / sizeof(arr[0]) \u0026lt;\u0026lt; endl; 11cout \u0026lt;\u0026lt; \u0026#34;items of arr: \u0026#34; \u0026lt;\u0026lt; sizeof(arr) / sizeof(arr[0][0]) \u0026lt;\u0026lt; endl; 函数 函数的定义 1//定义一个函数 2返回值类型 函数名（参数列表） 3{ 4 函数体语句 5 6 return表达式 7} 函数的调用 值传递 函数在发生调用时，实参将值传递给形参；\n值传递时，形参发生变化，并不会影响实参；\n函数的声明 作用：提前告诉编译器函数名称及如何调用函数，函数的实际主体可以单独定义；函数的声明可以多次，但是函数的定义只能有一次；\n1int main() 2{ 3 int m = 2; 4 int n = 4; 5 cout \u0026lt;\u0026lt; maxNum(m, n) \u0026lt;\u0026lt; endl; 6 7 return 0; 8} 9 10int maxNum(int a, int b) 11{ 12 return a \u0026gt; b ? a : b; 13} 函数maxNum定义在main函数之后会产生报错；需要在执行main函数之前告诉编译器有maxNum这样一个函数存在，因此可以将maxNum函数定义在main函数之前，或者在main函数之前使用声明语句；\n1int maxNum(int a, int b); 2 3int maxNum(int a, int b) 4{ 5 return a \u0026gt; b ? a : b; 6} 7 8int main() 9{ 10 int m = 2; 11 int n = 4; 12 cout \u0026lt;\u0026lt; maxNum(m, n) \u0026lt;\u0026lt; endl;//4 13 14 return 0; 15} 函数的分文件编写 函数分文件编写的步骤：\n创建后缀名为.h的头文件； 创建后缀名为.cpp的源文件； 在头文件中写函数的声明； 在源文件中写函数的定义； 一个c++项目的文件结构如下：\n1//maxNum.h 2 3#include \u0026lt;iostream\u0026gt; 4using namespace std; 5 6int maxNum(int a, int b); 1//maxNum.cpp 2 3#include \u0026#34;../inc/maxNum.h\u0026#34; 4// #include \u0026lt;iostream\u0026gt; 5// using namespace std; 6 7int maxNum(int a, int b) 8{ 9 cout \u0026lt;\u0026lt; \u0026#34;helllo\u0026#34; \u0026lt;\u0026lt; endl; 10 return a \u0026gt; b ? a : b; 11} 1//main.cpp 2 3int main() 4{ 5 int m = 2; 6 int n = 4; 7 cout \u0026lt;\u0026lt; maxNum(m, n) \u0026lt;\u0026lt; endl; 8 9 return 0; 10} 指针 作用：可以通过指针直接访问内存\n内存编号是从0开始记录的，一般用16进制数字表示；\n可以利用指针变量保存地址；\n指针变量的定义和使用 定义语法：数据类型 * 变量名；\n使用方法：可以通过解引用的方式来找到指针指向的内存中保存的值；指针变量前加*代表解引用，找到指针指向的内存中的数据；\n1int main() 2{ 3 int a = 10; 4 int * p; 5 p = \u0026amp;a; 6 cout \u0026lt;\u0026lt; \u0026#34;the value of a: \u0026#34; \u0026lt;\u0026lt; p \u0026lt;\u0026lt; endl; 7 cout \u0026lt;\u0026lt; \u0026#34;address of a: \u0026#34; \u0026lt;\u0026lt; \u0026amp;a \u0026lt;\u0026lt; endl; 8 cout \u0026lt;\u0026lt; \u0026#34;the value of p: \u0026#34; \u0026lt;\u0026lt; p \u0026lt;\u0026lt; endl; 9 cout \u0026lt;\u0026lt; \u0026#34;the value pointed to by pointer p: \u0026#34; \u0026lt;\u0026lt; *p \u0026lt;\u0026lt; endl; 10 11 *p = 100; 12 cout \u0026lt;\u0026lt; \u0026#34;the value of a: \u0026#34; \u0026lt;\u0026lt; p \u0026lt;\u0026lt; endl; 13 cout \u0026lt;\u0026lt; \u0026#34;address of a: \u0026#34; \u0026lt;\u0026lt; \u0026amp;a \u0026lt;\u0026lt; endl; 14 cout \u0026lt;\u0026lt; \u0026#34;the value of p: \u0026#34; \u0026lt;\u0026lt; p \u0026lt;\u0026lt; endl; 15 cout \u0026lt;\u0026lt; \u0026#34;the value pointed to by pointer p: \u0026#34; \u0026lt;\u0026lt; *p \u0026lt;\u0026lt; endl; 16 17 return 0; 18} 指针类型所占的内存空间 编译器编译的程序是32位时(X86)，指针类型占4个字节的内存空间； 编译器编译的程序是64位时(X64, ARM64)，指针类型占8个字节的内存空间； 空指针和野指针 空指针：指针变量指向内存中编号为0的空间；\n用途：初始化指针变量；\n注意：空指针指向的内存是不可以访问的；\n野指针：指针变量指向非法的内存空间；\n空指针和野指针都不是自己申请的空间，因此不能访问；\n1int main() 2{ 3 //声明了一个空指针p1 4 int * p1 = NULL; 5 *p1 = 10; 6 cout \u0026lt;\u0026lt; \u0026#34;the value pointed to by pointer p1: \u0026#34; \u0026lt;\u0026lt; *p1 \u0026lt;\u0026lt; endl; 7 8 //给指针类型变量p2赋了一个地址值(int *)0x1100， 9 //但该地址值不是本程序申请的，因此无法对该地址指向的内存空间进行读写 10 int * p2 = (int *)0x1100; 11 *p2 = 10; 12 cout \u0026lt;\u0026lt; \u0026#34;the value pointed to by pointer p2: \u0026#34; \u0026lt;\u0026lt; *p2 \u0026lt;\u0026lt; endl; 13 14 return 0; 15} const修饰指针 const修饰指针有三种情况：\nconst修饰指针\t\u0026mdash;常量指针（常量的指针，该指针指向的值是一个常量）； const修饰常量 \u0026mdash;指针常量（该指针类型变量是一个常量）； const既修饰指针，又修饰常量； 常量指针 const int * p = \u0026amp;a; 指针的指向可以修改； 指针指向的值不可以修改； 1int main() 2{ 3 int a = 10; 4 int b = 100; 5 6 const int * p = \u0026amp;a;//声明了一个常量指针p 7 8 *p = 20;//对指针p指向的值进行修改，会报错 9 p = \u0026amp;b;//改变指针p的指向，不会报错 10 11 return 0; 12} 指针常量 int * const p = \u0026amp;a; 指针的指向不可以修改； 指针指向的值可以修改； 1int main() 2{ 3 int a = 10; 4 int b = 100; 5 6 int * const p = \u0026amp;a;//声明了一个指针常量 7 8 *p = 20;//该指针常量指向的值可以修改 9 p = \u0026amp;b;//该指针类型p是一个常量，因此p的值不能修改 10 11 return 0; 12} const既修饰指针，又修饰常量 指针的指向和指针指向的值都不可以修改； 1int main() 2{ 3 int a = 10; 4 int b = 100; 5 const int * const p = \u0026amp;a;//既修饰指针，又修饰常量 6 7 *p = 20;//指针p指向的值是一个常量，因此不可以修改 8 p = \u0026amp;b;//指针p是一个常量，因此指针p的值即指针p的指向不可以修改 9 10 return 0; 11} 指针和数组（利用指针访问数组中的元素） 1 2int main() 3{ 4 int arr[5] = {1,2,3,4,5}; 5 int * p = arr; 6 7 cout \u0026lt;\u0026lt; \u0026#34;pointer p points to the head of arr: \u0026#34; \u0026lt;\u0026lt; *p \u0026lt;\u0026lt; endl; 8 9 p++; 10 cout \u0026lt;\u0026lt; \u0026#34;pointer p points to the second element of arr: \u0026#34; \u0026lt;\u0026lt; *p \u0026lt;\u0026lt; endl; 11 12 return 0; 13} 指针和函数 值传递 1void swap01(int a, int b) 2{ 3 int temp = a; 4 a = b; 5 b = temp; 6 7 cout \u0026lt;\u0026lt; \u0026#34;swap01 a = \u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; 8 cout \u0026lt;\u0026lt; \u0026#34;swap01 b = \u0026#34; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; endl; 9} 10 11int main() 12{ 13 int a = 1; 14 int b = 2; 15 swap01(a, b);//swap01()函数中的参数是值传递，因此不会改变实参的值 16 17 cout \u0026lt;\u0026lt; \u0026#34;main a = \u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; 18 cout \u0026lt;\u0026lt; \u0026#34;main b = \u0026#34; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; endl; 19 return 0; 20} 地址传递 1void swap(int * a, int * b) 2{ 3 int temp = *a; 4 *a = *b; 5 *b = temp; 6 7 cout \u0026lt;\u0026lt; \u0026#34;swap *a = \u0026#34; \u0026lt;\u0026lt; *a \u0026lt;\u0026lt; endl; 8 cout \u0026lt;\u0026lt; \u0026#34;swap *b = \u0026#34; \u0026lt;\u0026lt; *b \u0026lt;\u0026lt; endl; 9} 10 11int main() 12{ 13 int a = 1; 14 int b = 2; 15 swap(\u0026amp;a, \u0026amp;b);//传入swap()函数的是a，b的地址，因此会对实参造成改变 16 17 cout \u0026lt;\u0026lt; \u0026#34;main a = \u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; 18 cout \u0026lt;\u0026lt; \u0026#34;main b = \u0026#34; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; endl; 19 return 0; 20} 结构体 结构体术语用户自定义的数据类型，允许用户存储不同的数据类型 结构体的定义和使用 通过结构体创建变量的方式：\nstruct 结构体名 变量名 struct 结构体名 变量名 = {成员1值，成员2值\u0026hellip;} 定义结构体时顺便创建变量 1struct Student 2{ 3 string Name; 4 int age; 5 float score; 6}s3;//在定义结构体时顺便声明了一个Student类型的结构体s3 7 8int main() 9{ 10 struct Student s1;//声明一个Student类型的结构体s1，并给s1赋值 11 s1.Name = \u0026#34;mike\u0026#34;; 12 s1.age = 22; 13 s1.score = 88.88; 14 cout \u0026lt;\u0026lt; \u0026#34;姓名：\u0026#34; \u0026lt;\u0026lt; s1.Name\u0026lt;\u0026lt; \u0026#34;; \u0026#34; 15 \u0026lt;\u0026lt;\u0026#34;年龄：\u0026#34; \u0026lt;\u0026lt; s1.age \u0026lt;\u0026lt; \u0026#34;; \u0026#34; 16 \u0026lt;\u0026lt; \u0026#34;分数：\u0026#34; \u0026lt;\u0026lt; s1.score \u0026lt;\u0026lt; endl; 17 18 struct Student s2 = {\u0026#34;tom\u0026#34;, 21, 89};//声明s2的同时给s2赋值 19 cout \u0026lt;\u0026lt; \u0026#34;姓名：\u0026#34; \u0026lt;\u0026lt; s2.Name\u0026lt;\u0026lt; \u0026#34;; \u0026#34; 20 \u0026lt;\u0026lt;\u0026#34;年龄：\u0026#34; \u0026lt;\u0026lt; s2.age \u0026lt;\u0026lt; \u0026#34;; \u0026#34; 21 \u0026lt;\u0026lt; \u0026#34;分数：\u0026#34; \u0026lt;\u0026lt; s2.score \u0026lt;\u0026lt; endl; 22 23 s3.Name = \u0026#34;bob\u0026#34;;//在定义结构体时已经声明了s3 24 s3.age = 19; 25 s3.score = 87; 26 cout \u0026lt;\u0026lt; \u0026#34;姓名：\u0026#34; \u0026lt;\u0026lt; s3.Name\u0026lt;\u0026lt; \u0026#34;;\u0026#34; 27 \u0026lt;\u0026lt;\u0026#34;年龄：\u0026#34; \u0026lt;\u0026lt; s3.age \u0026lt;\u0026lt; \u0026#34;; \u0026#34; 28 \u0026lt;\u0026lt; \u0026#34;分数：\u0026#34; \u0026lt;\u0026lt; s3.score \u0026lt;\u0026lt; endl; 29 30 return 0; 31} 结构体数组 1struct Student 2{ 3 string Name; 4 int age; 5 float score; 6}; 7 8int main() 9{ 10 struct Student stuArr[3] = 11 { 12 {\u0026#34;tom\u0026#34;, 15, 88}, 13 {\u0026#34;bob\u0026#34;, 16, 89}, 14 {\u0026#34;mike\u0026#34;, 18, 78} 15 }; 16 17 stuArr[1].score = 92; 18 19 for (int i = 0; i \u0026lt; sizeof(stuArr) / sizeof(stuArr[0]); i++) 20 { 21 cout \u0026lt;\u0026lt; \u0026#34;姓名：\u0026#34; \u0026lt;\u0026lt; stuArr[i].Name\u0026lt;\u0026lt; \u0026#34;;\u0026#34; 22 \u0026lt;\u0026lt;\u0026#34;年龄：\u0026#34; \u0026lt;\u0026lt; stuArr[i].age \u0026lt;\u0026lt; \u0026#34;; \u0026#34; 23 \u0026lt;\u0026lt; \u0026#34;分数：\u0026#34; \u0026lt;\u0026lt; stuArr[i].score \u0026lt;\u0026lt; endl; 24 } 25 26 return 0; 27} 结构体指针 利用操作符 -\u0026gt; 可以通过结构体指针访问结构体属性 1struct Student 2{ 3 string Name; 4 int age; 5 float score; 6}; 7 8int main() 9{ 10 struct Student s1 = {\u0026#34;tom\u0026#34;, 21, 89}; 11 12 struct Student * p = \u0026amp;s1; 13 14 cout \u0026lt;\u0026lt; \u0026#34;姓名：\u0026#34; \u0026lt;\u0026lt; p-\u0026gt;Name\u0026lt;\u0026lt; \u0026#34;; \u0026#34; 15 \u0026lt;\u0026lt;\u0026#34;年龄：\u0026#34; \u0026lt;\u0026lt; p-\u0026gt;age \u0026lt;\u0026lt; \u0026#34;; \u0026#34; 16 \u0026lt;\u0026lt; \u0026#34;分数：\u0026#34; \u0026lt;\u0026lt; p-\u0026gt;score \u0026lt;\u0026lt; endl; 17 18 return 0; 19} 结构体嵌套 1struct Student 2{ 3 string Name; 4 int age; 5 float score; 6}; 7 8struct teacher 9{ 10 string Name; 11 int age; 12 struct Student stuArr[3]; 13}; 14 15int main() 16{ 17 struct teacher t1 = 18 { 19 \u0026#34;tim\u0026#34;, 20 26, 21 { 22 {\u0026#34;tom\u0026#34;, 15, 88}, 23 {\u0026#34;bob\u0026#34;, 16, 89}, 24 {\u0026#34;mike\u0026#34;, 18, 78} 25 } 26 27 }; 28 29 cout \u0026lt;\u0026lt; \u0026#34;教师姓名：\u0026#34; \u0026lt;\u0026lt; t1.Name \u0026lt;\u0026lt; \u0026#34;; \u0026#34; 30 \u0026lt;\u0026lt; \u0026#34;教师年龄：\u0026#34; \u0026lt;\u0026lt; t1.age \u0026lt;\u0026lt; \u0026#34;; \u0026#34; \u0026lt;\u0026lt; endl; 31 32 cout \u0026lt;\u0026lt; \u0026#34;教的学生：\u0026#34; \u0026lt;\u0026lt; endl; 33 for (int i = 0; i \u0026lt; sizeof(t1.stuArr) / sizeof(t1.stuArr[0]); i++) 34 { 35 cout \u0026lt;\u0026lt; \u0026#34;姓名：\u0026#34; \u0026lt;\u0026lt; t1.stuArr[i].Name\u0026lt;\u0026lt; \u0026#34;; \u0026#34; 36 \u0026lt;\u0026lt;\u0026#34;年龄：\u0026#34; \u0026lt;\u0026lt; t1.stuArr[i].age \u0026lt;\u0026lt; \u0026#34;; \u0026#34; 37 \u0026lt;\u0026lt; \u0026#34;分数：\u0026#34; \u0026lt;\u0026lt; t1.stuArr[i].score \u0026lt;\u0026lt; endl; 38 } 39 40 return 0; 41} 结构体做函数参数 传递方式有两种：\n值传递 地址传递 1struct Student 2{ 3 string Name; 4 int age; 5 float score; 6}; 7 8//值传递 9void prtStu01(Student s) 10{ 11 s.age = 22; 12 cout \u0026lt;\u0026lt; \u0026#34;通过值传递prtStu01()中的s：\u0026#34; \u0026lt;\u0026lt; endl; 13 cout \u0026lt;\u0026lt; \u0026#34;姓名：\u0026#34; \u0026lt;\u0026lt; s.Name\u0026lt;\u0026lt; \u0026#34;; \u0026#34; 14 \u0026lt;\u0026lt;\u0026#34;年龄：\u0026#34; \u0026lt;\u0026lt; s.age \u0026lt;\u0026lt; \u0026#34;; \u0026#34; 15 \u0026lt;\u0026lt; \u0026#34;分数：\u0026#34; \u0026lt;\u0026lt; s.score \u0026lt;\u0026lt; endl; 16} 17 18//地址传递 19void prtStu02(Student * s) 20{ 21 s-\u0026gt;age = 22; 22 cout \u0026lt;\u0026lt; \u0026#34;通过地址传递prtStu02()中的s：\u0026#34; \u0026lt;\u0026lt; endl; 23 cout \u0026lt;\u0026lt; \u0026#34;姓名：\u0026#34; \u0026lt;\u0026lt; s-\u0026gt;Name\u0026lt;\u0026lt; \u0026#34;; \u0026#34; 24 \u0026lt;\u0026lt;\u0026#34;年龄：\u0026#34; \u0026lt;\u0026lt; s-\u0026gt;age \u0026lt;\u0026lt; \u0026#34;; \u0026#34; 25 \u0026lt;\u0026lt; \u0026#34;分数：\u0026#34; \u0026lt;\u0026lt; s-\u0026gt;score \u0026lt;\u0026lt; endl; 26} 27 28int main() 29{ 30 struct Student s = {\u0026#34;tom\u0026#34;, 21, 89}; 31 32 prtStu01(s); 33 cout \u0026lt;\u0026lt; \u0026#34;main中的s：\u0026#34; \u0026lt;\u0026lt; endl; 34 cout \u0026lt;\u0026lt; \u0026#34;姓名：\u0026#34; \u0026lt;\u0026lt; s.Name\u0026lt;\u0026lt; \u0026#34;; \u0026#34; 35 \u0026lt;\u0026lt;\u0026#34;年龄：\u0026#34; \u0026lt;\u0026lt; s.age \u0026lt;\u0026lt; \u0026#34;; \u0026#34; 36 \u0026lt;\u0026lt; \u0026#34;分数：\u0026#34; \u0026lt;\u0026lt; s.score \u0026lt;\u0026lt; endl; 37 38 prtStu02(\u0026amp;s); 39 cout \u0026lt;\u0026lt; \u0026#34;main中的s：\u0026#34; \u0026lt;\u0026lt; endl; 40 cout \u0026lt;\u0026lt; \u0026#34;姓名：\u0026#34; \u0026lt;\u0026lt; s.Name\u0026lt;\u0026lt; \u0026#34;; \u0026#34; 41 \u0026lt;\u0026lt;\u0026#34;年龄：\u0026#34; \u0026lt;\u0026lt; s.age \u0026lt;\u0026lt; \u0026#34;; \u0026#34; 42 \u0026lt;\u0026lt; \u0026#34;分数：\u0026#34; \u0026lt;\u0026lt; s.score \u0026lt;\u0026lt; endl; 43 44 return 0; 45} 结构体中使用const防止误操作 1struct Student 2{ 3 string Name; 4 int age; 5 float score; 6}; 7 8//在参数类型前加const修饰表明该函数只对参数有读权限，不能修改参数的值 9void prtStu(const Student * s) 10{ 11 s-\u0026gt;age = 22;//该操作会报错 12 cout \u0026lt;\u0026lt; \u0026#34;通过地址传递prtStu()中的s：\u0026#34; \u0026lt;\u0026lt; endl; 13 cout \u0026lt;\u0026lt; \u0026#34;姓名：\u0026#34; \u0026lt;\u0026lt; s-\u0026gt;Name\u0026lt;\u0026lt; \u0026#34;; \u0026#34; 14 \u0026lt;\u0026lt;\u0026#34;年龄：\u0026#34; \u0026lt;\u0026lt; s-\u0026gt;age \u0026lt;\u0026lt; \u0026#34;; \u0026#34; 15 \u0026lt;\u0026lt; \u0026#34;分数：\u0026#34; \u0026lt;\u0026lt; s-\u0026gt;score \u0026lt;\u0026lt; endl; 16} 17 18int main() 19{ 20 struct Student s = {\u0026#34;tom\u0026#34;, 21, 89}; 21 22 prtStu(\u0026amp;s); 23 24 cout \u0026lt;\u0026lt; \u0026#34;main中的s：\u0026#34; \u0026lt;\u0026lt; endl; 25 cout \u0026lt;\u0026lt; \u0026#34;姓名：\u0026#34; \u0026lt;\u0026lt; s.Name\u0026lt;\u0026lt; \u0026#34;; \u0026#34; 26 \u0026lt;\u0026lt;\u0026#34;年龄：\u0026#34; \u0026lt;\u0026lt; s.age \u0026lt;\u0026lt; \u0026#34;; \u0026#34; 27 \u0026lt;\u0026lt; \u0026#34;分数：\u0026#34; \u0026lt;\u0026lt; s.score \u0026lt;\u0026lt; endl; 28 29 return 0; 30} ","date":"2024-03-05T22:29:24+08:00","image":"https://chaihaojian.github.io/post/c_plus_note/chapter1_%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/cover_hudb412b59d0d815ead8ba404fe2018587_757370_120x120_fill_q75_box_smart1.JPG","permalink":"https://chaihaojian.github.io/post/c_plus_note/chapter1_%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/","title":"C++基础语法"},{"content":"走进JavaScript JS从上到下顺序执行 1\u0026lt;!DOCTYPE html\u0026gt; 2\u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; 3\u0026lt;head\u0026gt; 4 \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; 5 \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; 6 \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; 7 \u0026lt;script\u0026gt; 8 alert(3); 9 \u0026lt;/script\u0026gt; 10\u0026lt;/head\u0026gt; 11\u0026lt;body\u0026gt; 12 \u0026lt;h1\u0026gt;aaaaaaa\u0026lt;/h1\u0026gt; 13\u0026lt;/body\u0026gt; 14\u0026lt;/html\u0026gt; 1\u0026lt;!DOCTYPE html\u0026gt; 2\u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; 3\u0026lt;head\u0026gt; 4 \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; 5 \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; 6 \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; 7\u0026lt;/head\u0026gt; 8\u0026lt;body\u0026gt; 9 \u0026lt;h1\u0026gt;aaaaaaa\u0026lt;/h1\u0026gt; 10 \u0026lt;script\u0026gt; 11 alert(3); 12 \u0026lt;/script\u0026gt; 13\u0026lt;/body\u0026gt; 14\u0026lt;/html\u0026gt; 两种写法的页面效果不同 将js放在前面时，后续内容需要等当前js执行结束再加载，因此一般将js放在页面的最后\n注释 单行注释：//\n多行注释：/*\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;*/\n执行符 js每行结束后必须加分号 ；\n变量声明 1var a = \u0026#34;abcdef\u0026#34;; 2 3var a 4a = \u0026#34;abcdef\u0026#34; 5 6var a = \u0026#34;hello\u0026#34;, age = 18, url = \u0026#34;chai.com\u0026#34;; 7 8var a = b = c = \u0026#34;hello\u0026#34;; 变量提升 在浏览器执行代码前，解析器会先分析代码：\n1var web = \u0026#34;hello\u0026#34;; 2console.log(web); 3var class = \u0026#34;world\u0026#34; 上述代码在执行时会直接报错，因为解析器在执行代码前分析时发现了问题；\n1console.log(web); 2var web = \u0026#34;hello.com\u0026#34;; 3 4//上述代码相当于 5console.log(web); 6var web ; 7web = \u0026#34;hello.com\u0026#34;; 8 9//变量提升 10var web ; 11console.log(web); 12web = \u0026#34;hello.com\u0026#34;; 解析器在分析时，会将变量声明的语句提升，因此执行时会输出undefined；\n1function hd() { 2 if(false) { 3 var web = \u0026#34;hello.com\u0026#34;; 4 } 5 console.log(web); 6} 7hd(); 8 9//变量提升 10function hd() { 11 var web; 12 if(false) { 13 web = \u0026#34;hello.com\u0026#34;; 14 } 15 console.log(web); 16} 17hd(); 使用 let 或 const 声明变量 1console.log(web); 2let web = \u0026#34;hello.com\u0026#34;; 1let web = \u0026#34;hello.com\u0026#34;; 2console.log(web); 使用let声明的变量，必须要先声明，在使用；上述代码的第一种情况会产生临时性死区TDZ；\n块作用域与全局污染 全局污染 1function show() { 2 web = \u0026#34;hello.com\u0026#34;; 3 console.log(web); 4}; 5show(); 6console.log(web); 上述代码中web并没有通过var，let，const声明，但仍可以使用；然而web应该只在show()函数中被使用，但此时在函数外也能使用该变量，这就造成了全局污染。\n使用严格模式 1\u0026#34;use strict\u0026#34; 2function show() { 3 web = \u0026#34;hello.com\u0026#34;; 4 console.log(web); 5}; 6show(); 7console.log(web); 1\u0026#34;use strict\u0026#34; 2function show() { 3 let web = \u0026#34;hello.com\u0026#34;; 4 console.log(web); 5}; 6show(); 7console.log(web); 在js代码中添加\u0026quot;use strict\u0026quot;语句表明使用严格模式，要求变量必须先声明再使用。\n块作用域 var声明的变量只有函数作用域和全局作用域：\n1var i = 99; 2 3for (var i = 0; i \u0026lt; 5; i++) { 4 console.log(\u0026#34;循环内的i：\u0026#34;,i); 5}; 6console.log(\u0026#34;循环外的i：\u0026#34;, i); for循环内声明的i影响到了for循环外的i，造成了污染；\n1var i = 99; 2for (let i = 0; i \u0026lt; 5; i++) { 3 console.log(\u0026#34;循环内的i：\u0026#34;,i); 4}; 5console.log(\u0026#34;循环外的i：\u0026#34;, i); 6 7let i = 99; 8for (let i = 0; i \u0026lt; 5; i++) { 9 console.log(\u0026#34;循环内的i：\u0026#34;,i); 10}; 11console.log(\u0026#34;循环外的i：\u0026#34;, i); let声明的变量拥有块作用域，因此for循环内的i不会影响到for循环外的i。\n对于var拥有函数作用域的进一步解释 1(function(){ 2 var $ = (window.$ = {}); 3 $.web = \u0026#34;hello.com\u0026#34;; 4 var url = \u0026#34;nihao.com\u0026#34;; 5}.bind(window)());//这是一个立即执行函数 6 7console.log(url); 在上述代码中，用var声明的变量$被定义在一个立即执行函数中，由于var拥有函数作用域，因此在这个立即执行函数外无法访问到$；通过在该立即执行函数内声明getUrl()和get$()子函数，可以将在该立即执行函数中的声明的变量暴露给外界使用。\n1(function(){ 2 var $ = (window.$ = {}); 3 $.web = \u0026#34;hello.com\u0026#34;; 4 var url = \u0026#34;nihao.com\u0026#34;; 5 $.getUrl = function() { 6 return url; 7 }; 8 $.get$ = function() { 9 return $; 10 }; 11}.bind(window)()); 12 13console.log($.getUrl()); 14console.log($.get$()); 由于let拥有块作用域，因此上述代码又可以改写为：\n1{ 2 let $ = (window.$ = {}); 3 $.web = \u0026#34;hello.com\u0026#34;; 4 let url = \u0026#34;nihao.com\u0026#34;; 5 }; 6}//变量$, url都在一个用{}包起来的代码块中 7 8console.log(url); 1{ 2 let $ = (window.$ = {}); 3 $.web = \u0026#34;hello.com\u0026#34;; 4 let url = \u0026#34;nihao.com\u0026#34;; 5 $.getUrl = function() { 6 return url; 7 }; 8 $.get$ = function() { 9 return $; 10 }; 11} 12 13console.log($.getUrl()); 14console.log($.get$()); const常量声明 const也拥有块作用域，在同一作用域里，const声明的常量无法更改:\n1const URL = \u0026#34;hello.com\u0026#34;; 2{ 3 const URL = \u0026#34;world.com\u0026#34; 4 console.log(URL); 5} 6console.log(URL); 1const URL = \u0026#34;hello.com\u0026#34;; 2URL = \u0026#34;world.com\u0026#34;; 3console.log(URL); 1const URL = \u0026#34;hello.com\u0026#34;; 2function show() { 3 const URL = \u0026#34;world.com\u0026#34;; 4 console.log(URL); 5} 6show(); 7console.log(URL); 当const声明的常量是引用类型时，可以进行更改：\n1const CONFIG = { 2 URL: \u0026#34;hello.com\u0026#34; 3}; 4console.log(CONFIG); 5CONFIG.URL = \u0026#34;world.com\u0026#34;; 6console.log(CONFIG); 对造成上述结果的分析：\n使用const声明一个基本类型的常量时，当改变该常量的值时，会造成该常量引用的地址发生改变，在上述代码中，\u0026ldquo;hello.com\u0026quot;和\u0026quot;world.com\u0026quot;在计算机中存储的地址不同，因此再次赋值会导致URL所引用的地址发生改变，因此报错；但是声明的是一个引用类型的常量时，由于更改CONFIG.URL并不会导致CONFIG所引用的地址发生改变，因此不会报错。\n对var与let的进一步说明 1var web0 = \u0026#34;hello.com\u0026#34;; 2console.log(window.web0); 3 4let web1 = \u0026#34;world.com\u0026#34;; 5console.log(window.web1); 6console.log(web1); 由var声明的变量会保存到全局对象window中，而let不会；且在同一作用域下，var出现重复声明不会报错，但let和const会报错。\n变量冻结 使用Object.freeze()可以使由const声明的引用类型的常量不发生改变，在严格模式下，对被Object.freeze()冻结的变量进行修改会报错。\n1 \u0026#34;use strict\u0026#34; 2const CONFIG = { 3 URL: \u0026#34;hello.com\u0026#34; 4}; 5console.log(CONFIG); 6Object.freeze(CONFIG); 7CONFIG.URL = \u0026#34;world.com\u0026#34;; 8console.log(CONFIG); \u0026ldquo;use strict\u0026rdquo;\n传值与传址 1//传值 2let a = 1; 3let b = a; 4console.log(a, b); 5b = 2; 6console.log(a, b); 7 8//传址 9let c = {url: \u0026#34;hello.com\u0026#34;}; 10let d = c; 11console.log(c, d); 12d.url = \u0026#34;world.com\u0026#34;; 13console.log(c, d); null与undefined 两者都表示没有值\nnull：当声明了一个引用类型变量，但没有赋值时，此时该引用类型变量为null\nundefin：当声明了一个基本类型变量，但没有赋值时，此时该基本类型变量为null\n在js函数中，当传递的参数，或着返回值没有值时，默认都是undefined\n1function show(name){ 2 console.log(name); 3}; 4console.log(show()); use strict 严格模式 严格模式的作用域包含当前作用域及其子作用域：\n1function show(){ 2 \u0026#34;use strict\u0026#34; 3 web = \u0026#34;hello.com\u0026#34;; 4 console.log(web); 5}; 6function hd(){ 7 site = \u0026#34;world.com\u0026#34;; 8 console.log(site); 9}; 10hd(); 11show(); 1function show(){ 2 web = \u0026#34;hello.com\u0026#34;; 3 console.log(web); 4 function handle(){ 5 \u0026#34;use strict\u0026#34; 6 url = \u0026#34;nihao.com\u0026#34;; 7 console.log(url); 8 }; 9 handle(); 10}; 11function hd(){ 12 site = \u0026#34;world.com\u0026#34;; 13 console.log(site); 14}; 15hd(); 16show(); 推荐在编写js代码时添加严格模式，使代码在更多的环境中运行。\n","date":"2024-02-27T13:42:01+08:00","image":"https://chaihaojian.github.io/post/javascript_note/%E8%B5%B0%E8%BF%9Bjavascript/cover_hub8b395643672f7ca335685551bcb8ad3_728006_120x120_fill_q75_box_smart1.JPG","permalink":"https://chaihaojian.github.io/post/javascript_note/%E8%B5%B0%E8%BF%9Bjavascript/","title":"走进JavaScript"},{"content":"第一章 计算机系统概述 计算机通过电信号传递数据 低电平表示二进制0\n高电平表示二进制1\n计算机系统 包括硬件和软件两大方面。\n计算机硬件的发展 第一代：第一台电子数字计算机：ENIAC（1946） 逻辑元件：电子管；\n第二代：晶体管 体积、功耗降低 出现面向过程的程序设计语言：FORTRAN 有了操作系统雏形；\n第三代： 中小规模集成电路 计算机主要用于科学计算等专业用途 高级语言迅速发展 开始有了分时操作系统；\n第四代：大规模、超大规模集成电路 开始出现微处理器、微型计算机 个人计算机（PC）萌芽 ；\n微型计算机的发展以微处理器技术为标志；\n机器字长：计算机一次整数运算所能处理的二进制位数；\n摩尔定律：集成电路上可容纳的晶体管数目，约每隔18个月便会增加一倍，整体性能也将提升一倍；该定律揭示了信息技术进步的速度。\n计算机软件的发展 机器语言 \u0026ndash;\u0026gt; 汇编语言 \u0026ndash;\u0026gt; 高级语言\n计算机的发展趋势（两极分化） 1.微型计算机向更微型化、网络化、高性能、多用途方向发展；\n2.巨型机向更巨型化、超高速、并行处理、智能化方向发展。\n计算机硬件的基本组成 早期冯诺依曼机的结构 ENIAC：需要手动接线来控制计算，需要人工干预，影响计算速度\n冯诺依曼提出“存储程序”的概念：\n将指令以二进制代码的形式事先输入计算机的主存储器（内存），然后按其在存储器中的首地址执行程序的第一条指令，以后就按该程序规定的顺序执行其他指令，直至程序结束。\n第一台采用冯诺依曼结构的计算机：EDVAC（Electronic Discrete Variable Automatic Computer）。\n输入设备：将信息转换成机器能识别的形式；\n存储器：存放数据和程序；\n运算器：进行算术运算和逻辑运算；\n控制器：指挥程序运行；\n输出设备：将结果转换成人们熟悉的形式；\n在计算机系统中，软件和硬件在逻辑上是等效的；\n冯诺依曼计算机的特点：\n1.计算机由五大部件组成；\n2.指令和数据以同等地位存于存储器，可按地址寻访；\n3.指令和数据用二进制表示；\n4.指令有操作码和地址码组成；\n5.存储程序；\n6.以运算器为中心：输入/输出设备与存储器之间的数据传送通过运算器完成；\n现代计算机的结构 以存储器为中心\nCPU = 运算器 + 控制器\n计算机内各个硬件的工作原理 主存储器的基本组成 存储体：数据在存储体内按地址存储，存储体里有一个一个的存储单元，每个存储单元存放一串二进制代码；每个存储单元对应一个地址；\n存储字：存储单元中二进制代码的组合叫做存储字(word)；\n存储字长：存储单元中能够存放的二进制代码位数叫做存储字长，通常为8bit的整数倍；\n存储元：存储二进制的电子元件，每个存储元可存1bit；\nMAR：指明要访问的数据的地址，MAR位数反映存储单元的个数；\nMDR：存放存储单元中取出的数据/需要保存进存储单元的数据，因此MDR字长=存储字长；\n注：MAR，MDR在逻辑上属于主存的一部分，但现代计算机通常把MAR，MDR集成在CPU内。\n运算器的基本组成 运算器：用于实现算术运算（如：加减乘除）、逻辑运算（如：与或非）\nACC：累加器，用于存放操作数，或运算结果；\nMQ：乘商寄存器，在乘、除运算时，用于存放操作数或运算结果；\nX：通用的操作数寄存器，用于存放操作数；\nALU：算术逻辑单元，通过内部复杂的电路实现算术运算、逻辑运算；\n控制器的基本组成 CU：控制单元，分析指令，给出控制信号；\nIR：指令寄存器，存放当前执行的指令；\nPC：程序计数器，存放下一条指令的地址，有自动加1功能；\n计算机系统的层次结构 计算机的性能指标 存储器的性能指标 MAR位数反映存储单元的个数（最多支持多少个）；\nMDR位数 = 存储字长 = 每个存储单元的大小；\n总容量 = 存储单元个数 * 存储字长 bit\n​\t= 存储单元个数 * 存储字长 / 8 Byte\n1 GB = 1024 MB = 1024 * 1024 KB = 1024 * 1024 * 1024 Byte\n1 Byte = 8 bit\nCPU的性能指标 CPU时钟周期：每个脉冲信号的时间，单位：微秒、纳秒；\nCPU主频（时钟频率）= 1 / CPU时钟周期：CPU内数字脉冲信号振荡的频率，单位：Hz；\nCPI(Clock cycle Per Instruction)：执行一条指令所需的时钟周期数；不同的指令，CPI不同；相同的指令，CPI也可能有变化；\n执行一条指令的耗时 = CPI * CPU时钟周期；\nCPU执行时间（整个程序的耗时）= CPU时钟周期数 / 主频 = （指令条数 * CPI）/ 主频；\nIPS(Instruction Per Second) = 主频 / 平均CPI：每秒执行多少条指令；\nFLOPS(Floating-point Operations Per Seconds)：每秒执行所少次浮点运算；\n系统整体性能指标 数据通路带宽：数据总线一次所能并行传送信息的位数（各硬件部件通过数据总线传输数据）；\n吞吐量：系统在单位时间内处理请求的数量；\n响应时间：从用户向计算机发送一个请求，到系统对该请求作出响应并获得它所需要的结果的等待时间；\n","date":"2024-02-27T10:13:54+08:00","image":"https://chaihaojian.github.io/post/computer_composition_principles/chapter_1/cover_huc74df9617fcc19736cc959ce67738010_601682_120x120_fill_q75_box_smart1.JPG","permalink":"https://chaihaojian.github.io/post/computer_composition_principles/chapter_1/","title":"计算机系统概述"},{"content":"二叉搜索树 如果左子节点存在，则左子节点的值小于当前节点的值； 如果右子节点存在，则右子节点的值大于当前节点的值。 对于二叉搜索树中的一个节点，可以根据上述性质确定由根节点到该节点的路径。 1func getPath(root, target *TreeNode)(path []*TreeNode){ 2​\tnode := root 3​\tfor node != target { 4​\tpath = append(path, node) 5​\tif node.Val \u0026gt; target.Val { 6​\tnode = node.Left 7​\t}else { 8​\tnode = node.Right 9​\t} 10​\t} 11​\tpath = append(path, node) 12​\treturn 13} ","date":"2024-02-25T22:01:10+08:00","image":"https://chaihaojian.github.io/post/data_struct/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/cover_hua5b35af258670c5afa4b660f73f4647d_606953_120x120_fill_q75_box_smart1.JPG","permalink":"https://chaihaojian.github.io/post/data_struct/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/","title":"二叉搜索树"}]